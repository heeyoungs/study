# 12장. 멀티 스레드

---



## 12.1 멀티 스레드 개념

---

### 프로세스와 스레드

프로세스 :  실행중인 하나의 애플리케이션

-> 멀티 프로세스 : 두 가지 이상의 작업을 동시에 처리하는 것



스레드 : 프로세스내에서 실제로 작업을 처리하는 주체 (각 프로세스마다 최소 한개의 스레드가 존재)

-> 멀티 스레드 : 애플리케이션 내부에서의 멀티 태스킹

 ![다운로드 (1).jfif](..\..\..\..\Downloads\다운로드 (1).jfif) 



멀티 프로세스의 경우 각 프로세스는 독립적이여서 서로 영향을 미치지 않으나

멀티 스레드의 경우 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될수 있으므로 예외처리를 잘해야한다!



### 메인 스레드

모든 자바 애플리케이션은 메인 스레드가 메소드를 실행하면서 시작이 된다.

``` java 
public static void main(Stirng[] args){
    String data = null;
    if(...){
        
    }
    while(...){
        
    }
    System.out.println("...");
}
```

-> 마지막 코드를 만나거나, reutrn문을 만나게 되면 실행이 종료된다.



메인 스레드는 작업 스레드들을 만들어 병렬로 코드를 실행할 수 있다.

실행 중인 스레드가 하나라도 있다면, (메인 스레드가 작업 스레드보다 먼저 종료되더라도) 프로세스는 종료되지 않는다.



## 12.2 작업 스레드 생성과 실행

---

멀티 스레드로 실행하려는 애플리케이션을 개발하기전에 작업별 스레드를 생성하기 위해선

`작업 스레드도 객체로 생성되기 떄문에 클래스가 필요하다.`



작업 스레드를 만드는 방법

- java.lang.Thread 클래스를 직접 객체화
- Thread를 상속해서 하위 클래스를 만들어 생성



### Thread 클래스로부터 직접 생성

java.lang.Thread 클래스로부터 작업 스레드 객체를 직접 생성하려면 Runnable을 매개값으로 갖는 생성자를 호출해야 한다.

``` java
Thread thread = new Thread(Runnable target);
```

- Runnable은 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체.
- 인터페이스 타입이기 때문에 구현 객체를 만들어 대입 ( run() 메소드를 재정의)

``` java
class Task implements Runnable{ // Runnable 구현 클래스를 작성하는 방법
    public void run(){
        스레드가 실행할 코드;
    }
}
```



Runnable은 작업 내용을 가지고 있는 객체이지 스레드가 아니기 때문에

이 구현 객체를 매개값으로 Thread 생성자를 호출하면 작업 스레드가 생성된다.

```java
Runnable task = new Task();

Thread thread = new Thread(task);
```

=>

``` java
Thread thread = new Thread( new Runnalbe() { // Thread 생성자를 호출할 때의 코드 절약
    public void run(){
        스레드가 실행할 코드;
    }
});
```



람다식을 매개값으로도 사용할 수 있다.(14장)

``` java
Thread thread = new Thread (()-> {
    스레드가 실행할 코드;
});
```



작업 스레드가 생성되면 start() 메소드를 호출해 실행된다.

``` java
thread.start();
```



메인 스레드에 모두 작성했을 경우.

``` java
import java.awt.*;

public class BeepPrintExample1 {
    public static void main(String[] args){
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for(int i=0;i<5;i++){
            toolkit.beep();
            try{Thread.sleep(500);}catch (Exception e) {}
        }

        for(int i=0;i<5;i++){
            System.out.println("띵");
            try{Thread.sleep(500);}catch (Exception e){}
        }
    }
}
//
소리로 먼저(띵 띵 띵 띵 띵)
띵
띵
띵
띵
띵
```



작업 스레드에 소리, 메인에 출력을 나눠 작성한 경우.

``` java
import java.awt.*;

public class BeepTask implements Runnable{ // 작업 스레드
    @Override
    public void run(){ // 스레드 실행 내용
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for(int i=0;i<5;i++){
            toolkit.beep();
            try{Thread.sleep(500);}catch (Exception e){}
        }
    }
}
```

``` java
public class BeepPrintExample2 {
    public static void main(String[] args){
        Runnable beepTask = new BeepTask();
        Thread thread = new Thread(beepTask);
        thread.start(); // 작업 스레드 실행 

        for(int i=0;i<5;i++){
            System.out.println("띵");
            try{Thread.sleep(500);}
            catch (Exception e){}
        }
    }
}
// 소리도 동시에
띵
띵
띵
띵
띵
```



작업 스레드를 만드는 다른 두가지의 방법

- 익명 객체를 이용

``` java
Thread thread = new Thread(new Runnable(){
    @Override
    public void run(){
        Toolkit toolkit.getDefaultToolkit();
        for(int i=0;i<5;i++){
            toolkit.beep();
            try{Thread.sleep(500);} catch(Exception e){}
        }
    }
});
```



- 람다식 이용

``` java
Thread thread = new Thread(() -> {
    Toolkit toolkit = Toolkit.getDefaultToolkit();
    for (int i = 0; i < 5; i++) {
        toolkit.beep();
        try { Thread.sleep(500); } catch (Exception e) { }
    }
});
```



### Thread 하위 클래스로 부터 생성

Thread클래스를 상속한 후 run 메소드를 재정의해서 스레드가 실행할 코드를 작성하면 된다.

``` java
public class WorkerThread extends Thread{
    @Override
    public void run(){
        // 스레드가 실행할 코드;
    }
}
Thread thread = new WorkerThread();
```

=>

``` java
Thread thread = new Thread(){ // 코드를 절약하기 위해 익명 자식 객체를 사용
    public void run(){
        // 스레드가 실행할 코드;
    }
};
```



생성된 작업 스레드를 start() 메소드를 호출해 실행

``` java
thread.start();
```



비프음이 울리는 예제

``` java
import java.awt.*;

public class BeepThread extends Thread{
    @Override
    public void run(){
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for(int i=0;i<5;i++){
            toolkit.beep();
            try{Thread.sleep(500);}catch (Exception e){}
        }
    }
}
```

``` java
import java.awt.*;

public class BeepPrintExample3 {
    public static void main(String[] args){
        Thread thread = new BeepThread();
        thread.start();

        for(int i=0;i<5;i++){
            System.out.println("띵");
            try{Thread.sleep(500);}
            catch (Exception e){}
        }
    }
}
//
띵
띵
띵
띵
띵
```



작업 스레드를 만드는 또 다른 방법.

``` java
Thread thread = new Thread(){ // 메인 스레드의 3라인을 대체
    @Override
    public void run(){
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for(int i=0;i<5;i++){
            toolkit.beep();
            try{Thread.sleep(500);} catch(Exception e){}
        }
    }
};
```



### 스레드의 이름

우리가 직접 생성한 스레드는 자동적으로 "Thread-n" 이라는 이름으로 설정된다.



다른 이름으로 설정하고 싶을 경우 호출하는 메소드

``` java
thread.setName("스레드 이름");
```



스레드의 이름을 알고 싶을 경우 호출하는 메소드

``` java
thread.getName();
```



위 메소드 둘다 인스턴스 메소드이므로 객체의 참조가 필요하다. 

객체의 참조를 가지고 있지 않다면, Thread의 정적 메소드인 currentThread() 코드를 실행하는 현재 스레드의 참조를 얻을 수 있다.

``` java
Thread thread = Thread.currentThread();
```



스레드의 이름을 설정하고 읽어오는 예제

```java
public class ThreadNameExample {
    public static void main(String[] args){
        Thread mainThread = Thread.currentThread();
        System.out.println("프로그램 시작 스레드 이름: " + mainThread.getName());

        ThreadA threadA = new ThreadA(); // ThreadA 생성
        System.out.println("작업 스레드 이름: " + threadA.getName()); // ThreadA 이름 얻기
        threadA.start(); // ThreadA 시작

        ThreadB threadB = new ThreadB();
        System.out.println("작업 스레드 이름: " + threadB.getName());
        threadB.start();
    }
}
//
프로그램 시작 스레드 이름: main
작업 스레드 이름: ThreadA
ThreadA가 출력한 내용
ThreadA가 출력한 내용
작업 스레드 이름: Thread-1
Thread-1가 출력한 내용
Thread-1가 출력한 내용
```

``` java
public class ThreadA extends Thread{
    public ThreadA(){
        setName("ThreadA"); // ThreadA 로 이름 설정
    }

    public void run(){
        for(int i=0;i<2;i++){
            System.out.println(getName() + "가 출력한 내용"); // 이름 얻기
        }
    }
}
```

```java
public class ThreadB extends Thread{
    public void run(){
        for(int i=0;i<2;i++){
            System.out.println(getName() + "가 출력한 내용"); // 이름 얻기
        }
    }
}
```



## 12.3 스레드 우선 순위

---

- 동시성 : 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질

- 병렬성 : 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질

![다운로드 (1)](C:\Users\user\Downloads\다운로드 (1).png)

싱클 코어 cpu를 이용한 멀티 스레드 작업은 번갈아가며 실행하는 동시성 작업이다.

-> 스레드의 개수가 코어의 수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행시킬지 결정하는 것을 `스케줄링` 이라고 함,



자바의 스레드 스케줄링은

- 우선순위 방식 : 우선 순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케줄링하는 것
- 순환 할당 방식 :  시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식

=> 우선 순위 방식은 개발자가 코드로 제어 가능하나 순환 할당 방식은 자바 가상 기계가 정하기 때문에 코드로 제어 x



우선 순위를 변경하고 싶다면!!! ( 1~10, 1이 가장 낮고 10이 가장 높고 5가 디폴트)



우선 순위를 변경하는 메소드

``` java
thread.setPriority(우선순위);
```



매개값으로 1~10을 직접 줘도 되나 Thread 상수를 사용 가능

```java
thread.setPriority(Thread.MAX_PRIORITY); // 10
thread.setPriority(Thread.NORM_PRIORITY); // 5
thread.setPriority(Thread.MIN_PRIORITY); // 1
```

-> 동일한 작업을 하는 스레드가 있을 때

싱글 코어의 경우 우선순위가 높은 스레드가 더 빨리 계산을 끝내나

쿼드 코어의 경우 4개 이하의 스레드를 실행할 경우 병렬성에 의해 우선순위 방식이 거의 영향을 미치지 않음.



우선 순위를 주고 계산 작업 순서를 보는 예제.

``` java
public class CalcThread extends Thread{
    public CalcThread(String name){ // 생성자
        setName(name); // 스레드 이름 변경
    }

    public void run(){
        for(int i=0;i<2000000000;i++){ // 스레드 실행 내용

        }
        System.out.println(getName());
    }
}
```

``` java
public class PriorityExample {
    public static void main(String[] args){
        for(int i=1;i<=10;i++){
            Thread thread = new CalcThread("thread" + i); // 스레드 이름
            if(i != 10){
                thread.setPriority(Thread.MIN_PRIORITY); // 10이 아닐 경우 1
            }
            else{
                thread.setPriority(Thread.MAX_PRIORITY); // 10에게 10
            }
            thread.start();
        }
    }
}
//
thread10
thread7
thread5
thread6
thread3
thread1
thread9
thread2
thread8
thread4
```



## 12.4 동기화 메소드와 동기화 블록

---

### 공유 객체를 사용할 때의 주의할 점

멀티 스레드 프로그램에서 스레드들이 객체를 공유해서 작업해야 하는 경우

스레드 A를 사용해 하는 객체가 B에 의해 상태가 변경 될 수도 있다.-> 엉터리 값이 나오게 된다.



엉터리 값이 나오는 예제.

``` java
public class MainthreadExample {
    public static void main(String[] args){
        Calculator calculator = new Calculator();

        User1 user1 = new User1(); // User1 스레드 생성
        user1.setCalculator(calculator); // 공유 객체 설정
        user1.start(); // User1 스레드 시작

        User2 user2 = new User2();
        user2.setCalculator(calculator);
        user2.start();
    }
}
//
User1: 50 저장
User2: 50 저장
```

``` java
public class Calculator {
    private int memory;

    public int getMemory(){
        return memory;
    }

    public void setMemory(int memory){ // 계산기에 메모리 값을 저장하는 메소드
        this.memory = memory; // 매개값을 메모리 필드에 저장
        try{
            Thread.sleep(2000); // 2초간 정지
        }catch (Exception e){}
        System.out.println(Thread.currentThread().getName() + ": " + this.memory); // 스레드의 이름과 값 출력
    }
}
```

``` java
public class User1 extends Thread{
    private Calculator calculator;

    public void setCalculator(Calculator calculator){
        this.setName("User1"); // 스레드 이름 User1
        this.calculator = calculator; // 공유 객체인 Calculator를 필드에 저장
    }

    public void run(){
        calculator.setMemory(100); // 메모리 100을 저장
    }
}
```

``` java
public class User2 extends Thread{
    private  Calculator calculator;

    public void setCalculator(Calculator calculator){
        this.setName("User2");
        this.calculator = calculator;
    }

    public void run(){
        calculator.setMemory(50);
    }
}
```



### 동기화 메소드 및 동기화 블록

위 경우를 막기위해 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 잠금을 걸어야 한다.



자바에선 임계 영역을 지정하기 위해서 동기화 메소드와 동기화 블록을 제공한다.

-> 임계 영역 : 멀티 스레드 프로그램에서 단 하나의 스레드만을 실행할 수 있는 코드 영역



`동기화 메소드`를 만들기 위해선 메소드 선언에 synchronized 키워드를 붙이면 된다. ( 인스턴스, 정적 메소드 어디든 가능)

``` java
public synchronized void method(){
    임계 영역; // 단 하나의 스레드만 실행
}
```

-> 동기화 메소드는 메소드 전체 내용이 임계 영역이므로 스레드가 동기화 메소드를 실행하는 즉시 객체에는 잠금이 일어나고,

스레드가 동기화 메소드를 실행 종료하면 잠금이 풀린다.



일부 내용만을 임계 영역으로 만들고 싶다면 `동기화 블록`을 만들면 된다.

``` java
public void method(){
    // 여러 스레드가 실행 가능 영역
    ...
    synchronized(공유객체){ // 동기화 블록 (공유 객체가 자신이면 this를 넣을 수 있다.)
        임계 영역 // 단 하나의 스레드만 실행
    }
    
    // 여러 스레드가 실행 가능 영역
    ...
}
```



이전 예제를 수정한 예제.

``` java
public class Calculator {
    private int memory;

    public int getMemory(){
        return memory;
    }
    
	public synchronized void setMemory(int memory){ // 동기화 메소드로 선언
        this.memory = memory;
        try{
            Thread.sleep(2000);
        }catch (Exception e){}
        System.out.println(Thread.currentThread().getName() + ": " + this.memory);
    }
}
//
User1: 100 저장
User2: 50 저장
```

-> User1 스레드는 Calculator 객체의 동기화 메소드인 setMemory()를 실행하면 Calculator 객체를 잠근다.

메인에서 User2 스레드를 실행시키지만 동기화 메소드인 setMemory()는 실행시키지 못한다.

User1이 setMemory() 메소드의 실행이 끝나고 난 후 실행된다.



동기화 블록으로 선언하는 방법

``` java
public void setMemory(int memory){
    synchronized(this){
        this.memory = memory;
        try{
            Thread.sleep(2000);
        }catch(InterruptException e){}
        System.out.println(Thread.currentThread().getName() + ": " + this.memory + " 저장");
    }
}
```

-> 스레드가 동기화 블록으로 들어가면 Calculator 객체를 잠그고 동기화 블록을 모두 실행 할 때 까지 다른 스레드들은

Calculator의 모든 동기화 메소드 또는 동기화 블록을 실행할 수 없게 된다.



## 12.5 스레드 상태

---

실행 대기 상태 : 아직 스케줄링이 되지 않아서 실행을 기다리고 있는 상태

일시 정지 상태 : 스레드가 실행할 수 없는 상태 ( WAITING, TIMED_WAITING, BLOCKED )

<img src="C:\Users\user\Downloads\다운로드 (2).png" alt="다운로드 (2)" style="zoom: 200%;" />



스레드의 상태 표

| 상태      | 열거 상수     | 설명                                                         |
| --------- | ------------- | ------------------------------------------------------------ |
| 객체 생성 | NEW           | 스레드 객체가 생성, 아직 start() 메소드가 호출되지 않은 상태 |
| 실행 대기 | RUNNALBE      | 실행 상태로 언제든지 갈 수 있는 상태                         |
| 일시 정지 | WAITING       | 다른 스레드가 통지할 때까지 기다리는 상태                    |
| -         | TIMED_WAITING | 주어진 시간 동안 기다리는 상태                               |
| -         | BLOCKED       | 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태        |
| 종료      | TERMINATED    | 실행을 마친 상태                                             |



타겟 스레드의 상태를 출력하는 메소드

``` java
public class StatePrintThread extends Thread{
    private Thread targetThread;

    public StatePrintThread(Thread targetThread){ // 상태를 조사할 스레드
        this.targetThread = targetThread;
    }

    public void run(){
        while(true) {
            Thread.State state = targetThread.getState(); // 스레드의 상태를 얻기
            System.out.println("타겟 스레드 상태: " + state);

            if (state == State.NEW) { // 객체 생성 상태일 경우 실행 대기 상태로 만듬
                targetThread.start();
            }

            if (state == State.TERMINATED) { // 종료 상태일 경우 while문을 종료함
                break;
            }
            try {
                Thread.sleep(500);
            } catch (Exception e) {
            }
        }
    }
}
```

``` java
public class TargetThread extends Thread{
    public void run(){
        for(long i=0;i<1000000000;i++){} // 10억번 루핑을 돌아 RUNNABLE 상태
        try{
            Thread.sleep(1500); // 1.5초간 TIMED_WAITING 상태
        }catch (Exception e){}

        for(long i=0;i<1000000000;i++){} // RUNNABLE
    }
}
```

```java
class ThreadStateExample {
    public static void main(String[] args){
        StatePrintThread statePrintThread =
                new StatePrintThread(new TargetThread());  // NEW
        statePrintThread.start();
    }
}
```



## 12.6 스레드 상태 제어

---

스레드 상태 제어 : 실행 중인 스레드의 상태를 변경하는 것.

![unnamed](C:\Users\user\Downloads\unnamed.png)



스레드의 생테 제어 메소드 표

| 메소드                                                      | 설명                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| interrupt()                                                 | 일시 정지 상태의 스레드에서 InterruptException 예외를 발생시켜, 예외 처리 코드(catch)에서 실행 대기 상태로 가거나 종료 상태로 갈 수 있도록 한다. |
| notify()<br>notifyAll()                                     | 동기화 블록 내에서 wati() 메소드에 의해 일시 정지 상태에 있는 스레드를 실행 대기 상태로 만든다. |
| resume()                                                    | suspend() 메소드에 의해 일시 정지 상태에 있는 스레드를 실행 대기 상태로 만든다. -Deprecated( 대신 notify(), notifyAll() 사용) |
| sleep(long mills)<br>sleep(long millis, int nanos)          | 주어진 시간 동안 스레드를 일시 정지 상태로 만든다. 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다. |
| join()<br>join(long millis)<br>join(long millis, int nanos) | join() 메소드를 호출한 스레드는 일시 정지 상태가 된다. 실행 대기 상태로 가려면, join() 메소드를 멤버로 가지는 스레드가 종료되거나, 매개값으로 주어진 시간이 지나야 한다. |
| wait()<br>wait(long millis)<br>wait(long millis, int nanos) | 동기화(synchronized) 블록 내에서 스레드를 일시 정지 상태로 만든다. 매개값으로 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다. 시간이 주어지지 않으면 notify() , notifyAll() 메소드에 의해 실행 대기 상태로 갈 수 있다. |
| suspend()                                                   | 스레드를 일시 정지 상태로 만든다. resume() 메소드를 호출하면 다시 실행 대기 상태가 된다. -Deprecated( 대신 wait()사용) |
| yield()                                                     | 실행 중에 우선 순위가 동일한 다른 스레드에게 실행을 양보하고 실행 대기 상태가 된다. |
| stop()                                                      | 스레드를 즉시 종료시킨다. -Deprecated                        |



### 주어진 시간동안 일시 정지(sleep())

실행 중인 스레드를 일정 시간 멈추게 할 때 사용 , Thread 클래스의 정적 메소드

``` java 
try{
    Thread.sleep(100);
}catch(InterruptException e){
    // interrupt() 메소드가 호출되면 실행
}
```



sleep() 예제.

``` java
import java.awt.*;

public class SleepExample {
    public static void main(String[] args){
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for(int i=0;i<10;i++){
            toolkit.beep();
            try{
                Thread.sleep(3000); // 3초동안 일시정지
            }catch (InterruptedException e){}
        }
    }
}
```



### 다른 스레드에게 실행 양보(yield())

아래 코드의 경우 run() 메소드를 실행하면 while문을 무한 반복 실행한다.

근데 work의 값이 false거나 false가 되는 시점이 불명확하면 무의미한 반복이 된다.

``` java
public void run() {
    while(true){
        if(work){
            System.out.println("ThreadA 작업 내용");
        }
    }
}
```

-> yield() 메소드를 호출해 실행 대기 상태로 돌아가고 우선 순위가 높거나 동일한 다른 스레드에게 실행 기회를 준다.

``` java
public void run() {
    while(true){
        if(work){
            System.out.println("ThreadA 작업 내용");
        }else{
            Thread.yield();
        }
    }
}
```



yield() 예제.

``` java
public class YieldExample {
    public static void main(String[] args){
        ThreadA_ threadA_ = new ThreadA_();
        ThreadB_ threadB_ = new ThreadB_();

        threadA_.start();
        threadB_.start();
		// ThreadA,B 모두 실행
        try{
            Thread.sleep(3000);
        }catch (Exception e){}
        threadA_.work = false; // ThreadB 만 실행

        try{
            Thread.sleep(3000);
        }catch (Exception e){} 
        threadA_.work = true; // ThreadA,B모두 실행

        try{
            Thread.sleep(3000);
        }catch (Exception e) {}
        threadA_.stop = true;
        threadB_.stop = true; // ThreadA,B 모두 종료
    }
}
```

```java
public class ThreadA_ extends Thread{
    public boolean stop = false;
    public boolean work = true;

    public void run(){
        while(!stop){ // stop이 true가 되면 와일문 종료
            if(work){
                System.out.println("ThreadA_ 작업 내용");
            }
            else{
                Thread.yield(); // work가 false가 되면 다른 스레드에게 실행 양보
            }
        }
        System.out.println("ThreadA 종료");
    }
}
```

```java
public class ThreadB_ extends Thread{
    public boolean stop = false;
    public boolean work = true;

    public void run(){
        while(!stop){ 
            if(work) {
                System.out.println("ThreadB_ 작업 내용");
            }
            else{
                Thread.yield();
            }
        }
        System.out.println("ThreadB 종료");
    }
}
```



### 다른 스레드의 종료를 기다림(join())

다른 스레드가 종료될 때까지 기다렸다가 실행해야 하는 경우 join() 메소드를 사용

![unnamed (2)](C:\Users\user\Downloads\unnamed (2).png)



join() 메소드 예시

```java
public class SumThread extends Thread{
    private long sum;

    public long getSum(){
        return sum;
    }

    public void setSum(long sum){
        this.sum = sum;
    }

    public void run(){
        for(int i=0;i<=100;i++){
            sum += i;
        }
    }
}
```

```java
public class JoinExample {
    public static void main(String[] args){
        SumThread sumThread = new SumThread();
        sumThread.start();

        try{
            sumThread.join(); // sumThread가 종료할 떄까지 메인 스레드를 일시정지 시킴
        }catch (Exception e){} // -> 0

        System.out.println("1~100 합: " + sumThread.getSum());
    }
}
//
1~100 합: 5050
```



### 스레드 간 협업(wait(), notify(), notifyAll())

여러 개의 스레드를 교대로 번갈아 가며 실행해야 할 경우 사용

notify() : 일시 정지 상태인 메소드를 실행 대기 상태로 바꿈.

-> noitfyAll() : 일시 정지된 모든 스레드들을 실행 대기 상태로 바꿈.

wait() : 일시 정지 상태로 바꿈

-> wait(long timeout), wait(long timeout, int nanos) 를 사용하면 notify()를 사용하지 않아도 시간이 지나면 자동적으로 실행 대기 상태로 바꿈



notify(), wait() 예제.

``` java
public class WorkObject {
    public synchronized void methodA(){
        System.out.println("ThreadA의 methodA() 작업 실행");
        notify(); // ThreadB를 실행 대기 상태로
        try{
            wait(); // ThreadA를 일시 정지 상태로
        }catch (Exception e){}
    }

    public synchronized void methodB(){
        System.out.println("ThreadB의 methodB() 작업 실행");
        notify(); // ThreadA를 실행 대기 상태로
        try{
            wait(); // ThreadB를 일시 정지 상태로
        }catch (Exception e){}
    }
}
```

``` java
public class ThreadA extends Thread{
    private WorkObject workObject;

    public ThreadA(WorkObject workObject){
        this.workObject = workObject; // 공유 객체를 매개값으로 받아 필드에 저장
    }

    @Override
    public void run(){
        for(int i=0;i<10;i++){ // 공유 객체의 methodA를 10번 반복 호출
            workObject.methodA();
        }
    }
}
```

``` java
public class ThreadB extends Thread{
    private WorkObject workObject;

    public ThreadB(WorkObject workObject){
        this.workObject = workObject;
    }

    @Override
    public void run(){
        for(int i=0;i<10;i++){
            workObject.methodB();
        }
    }
}
```

``` java
public class WaitNotifyExample {
    public static void main(String[] args){
        WorkObject sharedObject = new WorkObject(); // 공유 객체 생선
        ThreadA threadA = new ThreadA(sharedObject);
        ThreadB threadB = new ThreadB(sharedObject);

        threadA.start();
        threadB.start();
    }
}
//
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
ThreadA의 methodA() 작업 실행
ThreadB의 methodB() 작업 실행
```

-> methodA와 methodB를 번갈아 가면서 호출



notify(), wait() 예제.

``` java
public class DataBox {
    private String data;

    public synchronized String getData(){
        if(this.data == null){ // data필드가 null이면 소비자 스레드를 일시 정지 상태로
            try{
                wait();
            }catch (InterruptedException e){

            }
        }
        String returnValue = data;
        System.out.println("ConsummerThread가 읽은 데이터: "+ returnValue);
        data = null; // data필드를 null로 만들고 생산자 스레드를 실행 대기 상태로 만듬
        notify();
        return returnValue;
    }
    public  synchronized void setData(String data){
        if(this.data != null){ // data필드가 null이 아니면 생산자 스레드를 일시 정지 상태로 만듬
            try{
                wait();
            }catch (InterruptedException e){}
        }
        this.data = data; // data필드에 값을 저장하고 소비자 스레드를 실행 대기 상태로 만듬
        System.out.println("ProducerThread가 생성한 데이터: "+data);
        notify();
    }
}
```

``` java
public class ProducerThread extends Thread{
    private DataBox dataBox;

    public ProducerThread(DataBox dataBox){
        this.dataBox = dataBox; // 공유 객체에 필드값을 저장
    }

    @Override
    public void run(){
        for(int i=1;i<=3;i++){
            String data = "Data-" + i;
            dataBox.setData(data); // 새로운 데이터를 저장
        }
    }
}
```

``` java
public class ConsumerThread extends Thread{
    private DataBox dataBox;

    public ConsumerThread(DataBox dataBox){
        this.dataBox = dataBox;
    }

    @Override
    public void run(){
        for(int i=1;i<=3;i++){
            String data = dataBox.getData(); // 새로운 데이터를 읽음
        }
    }
}
```

``` java
public class WaitNotifyExample_ {
    public static void main(String[] args){
        DataBox dataBox = new DataBox();

        ProducerThread producerThread = new ProducerThread(dataBox);
        ConsumerThread consumerThread = new ConsumerThread(dataBox);

        producerThread.start();
        consumerThread.start();
    }
}
//
ProducerThread가 생성한 데이터: Data-1
ConsummerThread가 읽은 데이터: Data-1
ProducerThread가 생성한 데이터: Data-2
ConsummerThread가 읽은 데이터: Data-2
ProducerThread가 생성한 데이터: Data-3
ConsummerThread가 읽은 데이터: Data-3
```

-> 번갈아가면서 데이터를 공유객체에 저장하고, 읽고 저장하고 읽고를 반복함.



### 스레드의 안전한 종료(stop() 플래그, interruppt())

실행 중인 스레드를 종료시켜주는 메소드



stop() 메소드는 deprecated

-> stop() 메소드로 스레드를 갑자기 종료하면 스레드가 사용중이던 자원들이 불안정 상태로 남겨질 수도 있기 때문이다.!



#### stop 플래그를 이용하는 방법

stop플래그를 사용해 run() 메소드의 종료를 유도한다.

``` java
public class XXXThread extends Thread{
    private boolean stop;
    
    public void run(){
        while(!stop){ // stop이 true가 되면 run을 종료한다.
            스레드가 반복 실행하는 코드;
        }
        // 스레드가 사용한 자원 정리
    }
}
```



stop플래그 사용 예제.

``` java
public class StopFlagExample {
    public static void main(String[] args){
        PrintThread1 PrintThread = new PrintThread1();
        PrintThread.start();

        try{Thread.sleep(1000);} catch (InterruptedException e) {}

        PrintThread.setStop(true); // 스레드를 종료시키기 위해 stop필드를 true로 변경
    }
}
```

``` java
public class PrintThread1 extends Thread{
    private boolean stop;

    public void setStop (boolean stop){
        this.stop = stop;
    }

    public void run(){
        while(!stop){
            System.out.println("실행 중");
        }
        System.out.println("자원 정리");
        System.out.println("실행 종료");
    }
}
```



#### Interrupt() 메소드를 이용하는 방법

InterruptedException예외를 발생시켜 run() 메소드를 정상 종료시킨다.

``` java
public class InterruptExample {
    public static void main(String[] args){
        Thread thread = new PrintThread2();
        thread.start();

        try{ Thread.sleep(1000);} catch (InterruptedException e){}

        thread.interrupt(); // 스레드를 종료시키기 위해 InterruptedExcpetion을 발생시킴.
    }
}
//
실행 중
실행 중
자원 정리
실행 종료
```

``` java
public class PrintThread2 extends Thread{
    public void run(){
        try{
            while(true){
                System.out.println("실행 중");
                Thread.sleep(1); // InterruptedException 발생
            }
        }catch (InterruptedException e){

        }

        System.out.println("자원 정리");
        System.out.println("실행 종료");
    }
}
```

-> 스레드가 실행 대기나 실행 상태일 떄 interrupt() 메소드를 사용하면 즉시 예외가 발생하지 않고

미래에 일시정지 상태가 되면 그 떄 예외가 발생한다. 그래서 위 예제에선 sleep(1)으로 잠시 일시정지상태를 만들었다.



일시 정지 상태를 만들지 않고 Interrupt() 호출 여부를 알 수 있는 방법. ( 무엇을 사용해도 좋다.)

``` java
boolean status = Thread.interrupted(); // 정적 메소드
boolean status = objThread.isInterrupted(); // 인스턴스 메소드
```



위 예제 수정.

``` java
public class PrintThread2 extends Thread{
    public void run(){
        while(true){
            System.out.println("실행 중");
            if(Thread.interrupted()){ // sleep() 대신 interrupt()가 호출되었는지 확인하고 while문을 빠져나가게 됨.
                break;
            }
        }
        System.out.println("자원 정리");
        System.out.println("실행 종료");
    }
}
```



## 12.7 데몬 스레드

---

데몬 스레드 : 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드.

-> 주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료된다.



스레드를 데몬으로 만들기 위해선

``` java
public static void main(String[] args){
    AutoSaveThread thread = new AutoSaveThread(); // 데몬 스레드
    thread.setDaemon(true); // 주 스레드가 될 스레드의 setDaemon(true)를 호출하면 된다.
    thread.start();
    ...
}
```

-> start() 메소드 호출 전에 setDaemon(true)를 호출하면 IllegalThreadStateException예외 발생

/ isDaemon() 메소드의 리턴 값을 사용해 현재 실행 중인 스레드가 데몬 스레드인지 조사할 수 있다.



데몬 스레드 사용 예제.

``` java
public class AutoSaveThread extends Thread{
    public void save(){
        System.out.println("작업 내용을 정리함");
    }

    @Override
    public void run(){
        while(true){
            try{
                Thread.sleep(1000);
            }catch (InterruptedException e){
                break;
            }
            save();
        }
    }
}
```

``` java
public class DaemonExample {
    public static void main(String[] args){
        AutoSaveThread autoSaveThread = new AutoSaveThread();
        autoSaveThread.setDaemon(true);
        autoSaveThread.start();

        try{
            Thread.sleep(3000);
        }catch (InterruptedException e){
        }

        System.out.println("메인 스레드 종료");
    }
}
```



## 12.8 스레드 그룹

---

스레드 그룹 : 관련된 스레드를 묶어서 관리할 목적으로 사용



- JVM이 실행되면 system 스레드 그룹을 만들고, JVM 운영에 필요한 스레드들을 생성해서 system 스레드 그룹에 포함시킨다.

- system의 하위 스레드 그룹으로 main을 만들고 메인 스레드를 main스레드 그룹에 포함시킨다.

=> 명시적으로 스레드 그룹에 포함시키지 않으면 기본적으로 자신을 생성한 스레드와 같은 스레드 그룹으로 속하고 보통 main스레드가 생성한다.

### 스레드 그룹 이름 얻기

현재 스레드가 속한 스레드 그룹의 이름을 얻는 메소드

``` java
ThreadGroup group = Thread.currentThread().getThreadGroup();
String groupName = group.getName();
```



프로세스 내에서 실행하는 모든 스레드에 대한 정보를 얻을 수 있다.(15장)

``` java
Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces(); // 정적 메소드
```



현재 실행하는 스레드의 정보 출력 예제.

``` java
import java.util.Map;
import java.util.Set;

public class ThreadInfoExample {
    public static void main(String[] args){
        AutoSaveThread autoSaveThread = new AutoSaveThread();
        autoSaveThread.setName("AutoSaveThread");
        autoSaveThread.setDaemon(true);
        autoSaveThread.start();

        Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
        Set<Thread> threads = map.keySet();
        for(Thread thread : threads){
            System.out.println("Name: " + thread.getName()
            + ((thread.isDaemon())?"(데몬)":"(주)"));
            System.out.println("\t" + "소속그룹: " + thread.getThreadGroup().getName());
            System.out.println();
        }
    }
}
//
Name: Attach Listener(데몬)
	소속그룹: system

Name: Finalizer(데몬)
	소속그룹: system

Name: Monitor Ctrl-Break(데몬)
	소속그룹: main

Name: AutoSaveThread(데몬)
	소속그룹: main

Name: main(주)
	소속그룹: main

Name: Signal Dispatcher(데몬)
	소속그룹: system

Name: Reference Handler(데몬)
	소속그룹: system
```



### 스레드 그룹 생성

명시적으로 스레드 그룹을 만들고 싶다면,

``` java
ThreadGroup tg = new ThreadGroup(String name); // 스레드 그룹의 이름
ThreadGroup tg = new ThreadGroup(ThreadGroup parent, String name); // 부모 스레드그룹의 이름, 스레드 그룹의 이름
```

-> 생성자 중 하나를 이용해서 ThreadGroup객체를 만들면된다.



``` java
Thread t = new Thread(ThreadGroup group, Runnable target);
Thread t = new Thread(ThreadGroup group, Runnalbe target, String name);
Thread t = new Thread(ThreadGroup group, Runnalbe target, String name, long stackSize);
Thread t = new Thread(ThreadGroup group, String name);
```

새로운 스레드 그룹을 생성한 후, 이 그룹에 스레드를 포함시키려면 Thread객체를 생성할 때 생성자 매개값으로 스레드 그룹을 지정하면 된다.



### 스레드 그룹의 일괄 interrupt()

스레드를 스레드 그룹에 포함시키면 스레드 그룹에서 제공하는 interrupt() 메소드를 이용해서 모든 스레드를 일괄 interrupt할 수 있다.

-> 코드의 반복을 줄여준다.



interrupt() 메소드이외에 일괄적으로 사용할 수 있는 메소드들

| 메소드      |                           | 설명                                                         |
| :---------- | ------------------------- | ------------------------------------------------------------ |
| int         | activeCount()             | 현재 그룹 및 하위 그룹에서 활동 중인 모든 스레드의 수를 말한다 |
| int         | activeGroupCount()        | 현재 그룹에서 활동 중인 모든 하위 그룹의 수를 리턴한다       |
| void        | checkAccess()             | 현재 스레드가 스레드 그룹을 변경할 권한이 있는지 체크한다. 만약 권한이 없으면 SecurityException 을 발생시킨다. |
| void        | destroy()                 | 현재 그룹 및 하위 그룹을 모두 삭제한다. 단, 그룹 내에 포함된 모든 스레드를이 종료 상태가 되어야한다. |
| boolean     | isDestroyed()             | 현재 그룹이 삭제되었는지 여부를 리턴한다.                    |
| int         | getMaxPriority()          | 현재 그룹에 포함된 스레드가 가질 수 있는 최대 우선순위를 리턴한다. |
| void        | setMaxPriority(int pri)   | 현재 그룹에 포함된 스레드가 가질 수 있는 최대 우선순위를 설정한다. |
| String      | getName()                 | 현재 그룹의 이름을 리턴한다.                                 |
| ThreadGroup | getParent()               | 현재 그룹의 부모 그룹을 리턴한다.                            |
| boolean     | parentOf(ThreadGroup g)   | 현재 그룹이 매개값으로 지정한 스레드 그룹의 부모인지 여부를 리턴한다. |
| boolean     | isDaemon()                | 현재 그룹이 데몬 그룹인지 여부를 리턴한다.                   |
| void        | setDaemon(boolean daemon) | 현재 구룹을 데몬 그룹으로 설정한다.                          |
| void        | list()                    | 현재 그룹에 포함된 스레드와 하위 그룹에 대한 정보를 출력한다. |
| void        | interrupt                 | 현재 그룹에 포함된 모든 스레드들을 interrupt 한다.           |



InterruptedException이 발생할 때 스레드가 종료되도록 함.

``` java
public class WorkThread extends Thread{
    public WorkThread(ThreadGroup threadGroup, String threadName){
        super(threadGroup, threadName); // 스레드 그룹과 스레드 이름을 실행
    }

    @Override
    public void run(){
        while(true){
            try{
                Thread.sleep(1000);
            }catch (InterruptedException e){ // InterruptedException이 발생될 때, while문을 빠져나와 스레드를 종료시킴.
                System.out.println(getName() + " interrupted");
                break;
            }
        }
        System.out.println(getName() + " 종료됨");
    }
}
```

``` java
public class ThreadGroupExample {
    public static void main(String[] args){
        ThreadGroup myGroup = new ThreadGroup("myGroup"); // myGroup에 두 스레드를 포함시킴.
        WorkThread workThreadA = new WorkThread(myGroup, "workThreadA");
        WorkThread workThreadB = new WorkThread(myGroup, "workThreadB");

        workThreadA.start();
        workThreadB.start(); // 스레드 실행

        System.out.println("[ main 스레드 그룹의 list() 메소드 출력 내용 ]");
        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();
        mainGroup.list();
        System.out.println();

        try{Thread.sleep(3000);}catch (InterruptedException e){}

        System.out.println("[ myGroup 스레드 그룹의 interrupt() 메소드 호출 ]");
        myGroup.interrupt(); // 마이 그룹 예외
    }
}
//
[ main 스레드 그룹의 list() 메소드 출력 내용 ]
java.lang.ThreadGroup[name=main,maxpri=10]
    Thread[main,5,main]
    Thread[Monitor Ctrl-Break,5,main]
    java.lang.ThreadGroup[name=myGroup,maxpri=10]
        Thread[workThreadA,5,myGroup]
        Thread[workThreadB,5,myGroup]

[ myGroup 스레드 그룹의 interrupt() 메소드 호출 ]
workThreadB interrupted
workThreadB 종료됨
workThreadA interrupted
workThreadA 종료됨
```





## 12.9 스레드 풀

---

스레드 풀이란?? 

작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것.

=> 미리 스레드를 만들어놓고 풀에 넣어두고, 필요할 때마다 꺼내 쓰는 것



만약 스레드 풀을 사용하지 않으면 병령 작업 처리가 많아져서 스레드의 개수가 증가되면 

그에 따른 스레드 생성과 스케줄링으로 인해 cpu가 바빠져 메모리 사용량이 늘어나 성능이 저하될 수도 있다! 



### 스레드풀 생성 및 종료

#### 스레드풀 생성

java.util.concurrent패키지에서  ExecutorService 인터페이스와 Executors 클래스를 통해 스래드풀을 생성하고 사용할 수 있다.

Executors의 다양한 정적 메소드를 통해 ExecutorService 구현 객체를 만들 수 있는데, 이것이 스레드 풀이다.

| 메소드명(매개 변수)              | 초기 스레드 수 | 코어 스레드 수 | 최대 스레드 수    |
| -------------------------------- | -------------- | -------------- | ----------------- |
| newCachedThreadPool()            | 0              | 0              | Integer.MAX_VALUE |
| newFixedThreadPool(int nThreads) | 0              | nThreads       | nThreads          |

초기 스레드 수 : ExecutorService 객체가 생성될 때 기본적으로 생성되는 스레드 수

코어 스레드 수 : 스레드 수가 증가된 후 사용되지 않는 스레드를 스레드풀에서 제거할 때 최소한 유지해야 할 스레드 수

최대 스레드 수 : 스레드풀에서 관리하는 최대 스레드 수 



newCachedThreadPool() 메소드

- 스레드 개수보다 작업 개수가 많으면 새 스레드를 생성시켜 작업을 처리

- 이론적으론 int값의 최대값만큼 스레드가 추가되지만, 운영체제의 성능에 따라 달라짐
- 1개 이상의 스레드가 추가되었을 경우, 60초 동안 추가된 스레드가 아무 작업을 하지 않으면 종료하고 제거한다.

``` java
ExecutorService executorService = Executors.newCachedThreadPool();
```



newFixedThreadPool(int nThreads) 메소드

- 스레드 개수보다 작업 개수가 많으면 새 스레드를 생성시켜 작업을 처리
- 최대 스레드는 매개값으로 준 nThreads
- 스레드가 놀고 있더라도 스레드의 개수는 줄지 않는다.

``` java
ExecutorService executorService = Executors.newFixedThreadPool(
	Runtime.getRuntime().availableProcessors()
)
```



ThreadPoolExecutor() 메소드

- 코어 스레드개수와 최대 스레드 개수를 직접 설정하고 싶을 때 사용

- 위 두가지 메소드 둘다 내부적으론 ThreadPoolExecutor 객체를 생성해서 리턴한다.

``` java
ExecutorService threadPool = new ThreadPoolExecutor(
	3, 			// 코어 스레드 개수
    100,		// 최대 스레드 개수
    120L, 		// 놀고 있는 시간
    TimeUnit.SECONDS,	// 놀고 있는 시간 단위
    new SynchronousQueue<Runnable>()	// 작업 큐
)
```

=> 초기 스레드 개수 0, 코어 스레드 개수 3, 최대 스레드 개수 100, 120초 동안 놀고 있을경우 스레드를 제거



#### 스레드풀 종료

스레드풀의 스레드는 데몬 스레드가 아니기 때문에 메인 스레드가 종료돼도 계속 실행 상태로 남아있다.

따라서 애플리케이션을 종료하려면 스레드풀을 종료시켜 스레드들이 종료상태가 되도록 처리해야 한다.



ExecutorService의 종료와 관련된 메소드

| 리턴 타입      | 메소드명(매개 변수)                                  | 설명                                                         |
| -------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| void           | shutdown()                                           | 현재 처리 중인 작업뿐만 아니라 작업 큐에 대기하고 있는 모든 작업을 처리한 뒤에 스레드 풀을 종료 시킨다. |
| List<Runnable> | shutdownNow()                                        | 현재 작업 처리 중인 스레드를 interrupt해서 작업 중지를 시도하고 스레드풀을 종료시킨다. 리턴값은 작업 큐에 있는 미처리된 작업(Runnable)의 목록이다. |
| boolean        | awaitTermination(<br>long timeout,<br>TimeUnit unit) | shutdown() 메소드 호출 이후, 모든 작업 처리를 timeout 시간 내에 완료하면 true를 리턴하고, 완료하지 못하면 작업 처리 중인 스레드를 interrupt하고 false를 리턴한다. |

``` java
executorService.shutdonw(); // 남아있는 작업을 마무리하고 스레드풀을 종료할 때 사용
executorService.shutdownNow(); // 남아있는 작업과는 상관없이 강제로 종료할 때 사용
```



### 작업 생성과 처리 요청

#### 작업 생성

하나의 작업은 Runnable, Callable 구현 클래스로 표현이 된다.



Runnable 구현 클래스 : 리턴값이 없다.

``` java
Runnable task = new Runnable(){
    @Override
    public void run(){
        // 스레드가 처리할 작업 내용
    }
}
```

Callable 구현 클래스 : 리턴값이 있다.

``` java
Callable<T> task = new Callable<T>(){
    @Override
    public T call() throws Exception{
        // 스레드가 처리할 작업 내용
        return T; // 리턴 값은 Callable<T> 에서 지정한 T타입이다.
    }
}
```



#### 작업 처리 요청

ExecutorService의 작업 큐에 Runnable 또는 Callable을 넣는 행위.

| 리턴 타입                           | 메소드명(매개 변수)                                          | 설명                                                         |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| void                                | execute(Runnalbe command)                                    | - Runnable을 작업 큐에 저장<br>- 작업 처리 결과를 받지 못함  |
| Future<?><br>Future<V><br>Future<V> | submit(Runnablee task)<br>submit(Runnable task, V result)<br>submit(Callable<V> task) | - Runnable 또는 Callable을 작업 큐에 저장<br>-리턴된 Future를 통해 작업 처리 결과를 얻을 수 있음 |

excute() 메소드와 submit() 메소드의 차이점?

1. excute() 는 작업 처리 결과를 받지 못하나, submit() 는 작업 처리 결과를 받을 수 있도록 Future를 리턴한다.

2. excute() 는 작업 처리 도중 예외가 발생하면 스레드가 종료되고 해당 스레드는 스레드 풀에서 제거되고 다른 작업을 위해선 새로운 스레드를 생성하나,

   submit() 는 작업 처리 도중 예외가 발생하더라도 스레드는 종료되지 않고 다음 작업을 위해 재사용 된다.

   

``` java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class ExecuteExample {
    public static void main(String[] args)throws Exception{
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        for(int i=0;i<10;i++){
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    ThreadPoolExecutor threadPoolExecutor =
                            (ThreadPoolExecutor) executorService;
                    int poolsize = threadPoolExecutor.getPoolSize();
                    String threadName = Thread.currentThread().getName();
                    System.out.println("[총 스레드 개수: " + poolsize + "] 작업 스레드 이름 : " + threadName);
                    int value = Integer.parseInt("삼");
                }
            };

            //executorService.execute(runnable);
            executorService.submit(runnable); // 주석 처리를 바꿔 execute와 submit의 결과값이 다른걸 볼 수 있다.

            Thread.sleep(10);
        }
        executorService.shutdown();
    }
}
// 스레드풀의 스레드 최대 개수 2는 변함 없나, 스레드의 이름이 모두 다르다.
[총 스레드 개수: 1] 작업 스레드 이름 : pool-1-thread-1
Exception in thread "pool-1-thread-1" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-3
Exception in thread "pool-1-thread-3" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-2
Exception in thread "pool-1-thread-2" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-4
Exception in thread "pool-1-thread-4" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-5
Exception in thread "pool-1-thread-5" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-6
Exception in thread "pool-1-thread-6" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-7
Exception in thread "pool-1-thread-7" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-8
Exception in thread "pool-1-thread-8" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-9
Exception in thread "pool-1-thread-9" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-10
Exception in thread "pool-1-thread-10" java.lang.NumberFormatException: For input string: "삼"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ch12.ExecuteExample$1.run(ExecuteExample.java:20)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
// 예외가 발생하더라도 스레드가 종료되지않고 재사용되었다.
[총 스레드 개수: 1] 작업 스레드 이름 : pool-1-thread-1
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-2
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-1
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-2
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-1
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-2
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-1
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-2
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-1
[총 스레드 개수: 2] 작업 스레드 이름 : pool-1-thread-2
```



### 블로킹 방식의 작업 완료 통보

submit() 메소드는 매개값으로 준 Runnable 또는 Callable 작업을 스레드풀의 작업큐에 저장하고 즉시 Future 객체를 리턴한다.

| 리턴 타입                             | 메소드명(매개 변수)                                          | 설명                                                         |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Future<?><br/>Future<V><br/>Future<V> | submit(Runnable task)<br/>submit(Runnable task, V result)<br/>submit(Callable<V> task) | - Runnable 또는 Callable을 작업 큐에 저장<br/>-리턴된 Future를 통해 작업 처리 결과를 얻을 수 있음 |

Future객체는 작업이 완료될 때까지 기다렸다가 최종 결과를 얻는데 사용된다. (지연 완료 객체라고도 함.)



Future의 get() 메소드

| 리턴 타입 | 메소드명(매개 변수)              | 설명                                                         |
| --------- | -------------------------------- | ------------------------------------------------------------ |
| V         | get()                            | 작업이 완료될 떄까지 블로킹 되었다가 처리 결과 V를 리턴      |
| V         | get(long timeout, TimeUnit unit) | tiemout 시간 전에 작업이 완료되면 결과 V를 리턴하지만, 작업이 완료되지 않으면 TiemoutException을 발생시킴. |



Future의 get() 메소드가 리턴하는 값이 무엇인지 

| 메소드                                | 작업 처리 완료 후 리턴 타입    | 작업 처리 도중 예외 발생  |
| ------------------------------------- | ------------------------------ | ------------------------- |
| submit(Runnable task)                 | future.get() -> null           | future.get() -> 예외 발생 |
| submit(Runnable task, Integer result) | future.get() -> int 타입 값    | future.get() -> 예외 발생 |
| submit(Callable\<String> task)        | future.get() -> String 타입 값 | future.get() -> 예외 발생 |

=> Future을 이용한 블로킹 방식의 작업 완료 통보에서 주의할 점은 작업을 처리하는 스레드가 작업을 완료하기 전까지는 get() 메소드가 블로킹 되므로 다른 코드를 실핼할 수 없다. 따라서 get()메소드를 호출하는 스레드는 새로운 스레드이거나 스레드풀의 또 다른 스레드가 되어야한다.



새로운 스레들 생성해서 호출

```java
new Thread(new Runnable(){
    @Override
    public void run(){
        try{
            future.get();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}).start();
```

스레드풀의 스레드가 호출

``` java
executorService.submit(new Runnable(){
    @Override
    public void run(){
        try{
            future.get();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
});
```



Future객체의 다른 메소드

| 리턴 타입 | 메소드명(매개 변수)                   | 설명                                 |
| --------- | ------------------------------------- | ------------------------------------ |
| boolean   | cancel(boolean mayInterruptIfRunning) | 작업 처리가 진행 중일 경우 취소 시킴 |
| boolean   | isCancelled()                         | 작업이 취소되었는지 여부             |
| boolean   | isDone()                              | 작업 처리가 완료되었는지 여부        |



#### 리턴값이 없는 작업 완료 통보

Runnable 객체를 생성하는 방법!

```java
Runnable task = new Runnable(){
    @Override
    public void run(){
        // 스레드가 처리할 작업 내용
    }
}
```



결과값이 없는 작업 처리 요청은 submit(Runnable task) 메소드를 이용하면 된다.

결과값이 없음에도 Future객체를 리턴하는것은, 스레드가 작업 처리를 정상적으로 완료했는지, 작업 도중 예외가 발생했는지 확인하기 위함.

``` java
Future future = executorService.submit(task);
```

``` java
try{
    future.get(); // 정상시 null
}catch(InterruptedException e){
    // 작업 처리 도중 interrupt
}catch (ExecutionException e){
    // 작업 처리 도중 예외
}
```



``` java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;


public class NoResultExample {
    public static void main(String[] args){
        ExecutorService executorService = Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors()
        );

        System.out.println("[작업 처리 요청]");
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                int sum =0;
                for(int i=0;i<=10;i++){sum += i;}
                System.out.println("[처리 결과] " + sum);
            }
        };
        Future future = executorService.submit(runnable);

        try{
            future.get();
            System.out.println("[작업 처리 완료]");
        }catch (Exception e){
            System.out.println("[실행 예외 발생함] " + e.getMessage());
        }
        executorService.shutdown();
    }
}
//
[작업 처리 요청]
[처리 결과] 55
[작업 처리 완료]
```



#### 리턴값이 있는 작업 완료 통보

Callable 객체를 생성하는 방법.

``` java
Callable<T> task = new Callable<T>(){ 
    @Override
    public T call() throws Exception{
        return T; // <T>와 리턴 타입이 같아야 한다.
    }
}
```



Callable 객체를 저장하고 즉시 Future <T>를 리턴한다. T는 call() 메소드가 리턴하는 값.

``` java
Future<T> future = executorService.submit(task);
```

``` java
try{
    T result = future.get();
}catch(InterruptedException e){
    // 작업 처리 도중 interrupt
}catch(ExecutionException e){
    // 작업 처리 도중 예외
}
```



``` java
import java.util.concurrent.*;

public class ResultByCallableExample {
    public static void main(String[] args){
        ExecutorService executorService = Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors()
        );

        System.out.println("[작업 처리 요청]");
        Callable<Integer> task = new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                int sum =0;
                for(int i=0;i<=10;i++){
                    sum += i;
                }
                return sum;
            }
        };
        Future<Integer> future = executorService.submit(task);

        try{
            int sum = future.get(); // sum의 값이 저장
            System.out.println("[처리 결과] " + sum);
            System.out.println("[작업 처리 완료]");
        }catch (Exception e){
            System.out.println("[실행 예외 발생함] " + e.getMessage());
        }

        executorService.shutdown();
    }
}
//
[작업 처리 요청]
[처리 결과] 55
[작업 처리 완료]
```



#### 작업 처리 결과를 외부 객체에 저장

스레드가 작업한 결과를 외부의 공유 객체에 저장해, 두 개 이상의 스레드 작업을 취합할 목적



이를 위해 ExecutorService의 submit(Runnable task, V result) 메소드를 사용, V가 Result타입.

get() 메소드를 호춣하면 스레드가 작업을 완료할 때까지 블로킹되었다가 작업을 완료하면 V타입 객체를 리턴한다.

``` java
Result result = ...;
Runnable task = new Task(result);
Future<Result> future = executorService.submit(task, result);
result = future.get()
```



Runnable 구현 객체를 생성하나, 스레드에서 결과를 저장하기 위해 생성자를 통해 Result객체를 주입 받아야함.

``` java
class Task implements Runnable{
    Result result;
    Task(Result result) { this.result = result; }
    @Override
    public void run(){
        // 작업 코드
        // 처리 결과를 result에 저장
    }
} 
```



``` java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ResultByRunnableExample {
    public  static void main(String[] args){
        ExecutorService executorService = Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors()
        );
        
        System.out.println("[작업 처리 요청]");
        class Task implements Runnable{
            Result result; // 외부 Result 객체를 필드에 저장
            Task(Result result){
                this.result = result;
            }
            @Override
            public void run(){
                int sum =0;
                for(int i=0;i<=10;i++){
                    sum += i;
                }
                result.addValue(sum); // 외부 Result 객체에 값을 누적
            }
        }
        Result result = new Result();
        Runnable task1 = new Task(result);
        Runnable task2 = new Task(result); 
        Future<Result> future1 = executorService.submit(task1, result);
        Future<Result> future2 = executorService.submit(task2, result); // 두 가지 작업을 처리 요청
        
        try{
            result = future1.get();
            result = future2.get(); // 두 가지 작업 결과를 취함
            System.out.println("[처리 결과] " + result.accumValue);
            System.out.println("[작업 처리 완료]");
        }catch (Exception e){
            e.printStackTrace();
            System.out.println("[실행 예외 발생함] " + e.getMessage());
        }
        
        executorService.shutdown();
    }
}
class Result{ // 처리 결과를 저장하는 Result 클래스
    int accumValue;
    synchronized void addValue(int value){ // 동기화
        accumValue+=value;
        }
}
//
[작업 처리 요청]
[처리 결과] 110
[작업 처리 완료]
```



#### 작업 완료 순으로 통보

꼭 작업 요청 순서대로 작업이 처리되는 것은 아니다. 처리 결과가 순차적일 필요가 없을 경우

CompletionService의 poll()과 take() 메소드를 사용할 수 있다.

| 리턴 타입  | 메소드명(매개 변수)                   | 설명                                                         |
| ---------- | ------------------------------------- | ------------------------------------------------------------ |
| Future\<V> | poll()                                | 완료된 작업의 Future을 가져옴<br>완료된 작업이 없다면 즉시 null을 리턴함 |
| Future\<V> | poll(long timeout,\<br>Timeunit unit) | 완료된 작업의 Future를 가져옴.<br>완료된 작업이 없다면 timeout까지 블로킹됨. |
| Future\<V> | take()                                | 완료된 작업의 Future를 가져옴<br>완료된 작업이 없다면 있을 때 까지 블로킹됨. |
| Future\<V> | submit(Callable\<V> task)             | 스레드풀에 Callable 작업 처리 요청                           |
| Future\<V> | submit(Runnable task, V result)       | 스레드풀에 Runnable 작업 처리 요청                           |



CompletionService의 구현 클래스는 ExecutorCompletionSerive\<V> 이다. 객체를 생성할 때 생성자 매개값으로 ExecutorService를 제공하면 된다.

``` java
ExecutorService executorService = Executor.newFixedThreadPool(
	Runtime.getRuntime().availableProcessors()	
);
CompletionService<V> completionService = new ExecutorCompletionService<V>(
	executorservice
);
```



poll() 과 take() 메소드를 이용해서 완료된 작업의 Future을 얻으려면 submt() 메소드로 작업 처리 요청을 먼저 해야한다.

``` java
completionService.submit(Callable<V> task);
completionService.submit(Runnable task, V result);
```



``` java
executorService.submit(new Runnable){
    @Override
    public void run(){
        while(true){
            try{
                Future<Integer> future = completionService.take(); // take()메소드가 완료된 작업이 있을떄까지 블로킹
                int value = future.get(); // 바로 결과를 리턴
                System.out.println("[처리 결과] " + value);
            }catch(Exception )e{
                break;
            }
        }
    }
});
```

=> 이때 리턴하는 완료된 작업은 submit()으로 처리 요청한 작업의 순서가 아니다!



``` java
import java.util.concurrent.*;

public class CompletionServiceExample extends Thread{
    public static void main(String[] args){
        ExecutorService executorService = Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors()
        );

        CompletionService<Integer> completionService =
                new ExecutorCompletionService<Integer>(executorService); // CompletionService생성

        System.out.println("[작업 처리 요청]"); // 스레드풀에게 작업 처리 요청
        for(int i=0;i<3;i++){
            completionService.submit(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    int sum =0;
                    for(int i=1;i<=10;i++){
                        sum += i;
                    }
                    return sum;
                }
            });
        }

        System.out.println("[처리 완료된 작업 확인]"); // 스레드풀의 스레드에서 실행하도록 요청
        executorService.submit(new Runnable() {
            @Override
            public void run() {
                while(true){
                    try{
                        Future<Integer> future = completionService.take(); // 완료된 작업 가져오기
                        int value = future.get();
                        System.out.println("[처리 결과] " + value);
                    }catch (Exception e){
                        break;
                    }
                }
            }
        });

        try{Thread.sleep(3000);} // 3초 후 종료
        catch (InterruptedException e){}
        executorService.shutdown();
    }
}
//
[작업 처리 요청]
[처리 완료된 작업 확인]
[처리 결과] 55
[처리 결과] 55
[처리 결과] 55
```



### 콜백 방식의 작업 완료 통보

콜백 방식이란? 애플리케이션이 스레드에게 작업 처리를 요청한 후, 스레드가 작업을 완료하면 특정 메소드를 자동 실행하는 기법

(이때 자동 실행되는 메소드가 콜백 메소드)



블로킹 방식은 작업 처리를 요청한 후 작업이 완료될 때까지 블로킹 되지만,

콜백 방식은 작업 처리를 요청한 후 결과를 기다릴 필요없이 다른 기능을 수행할 수 있다.



콜백 메소드를 가진 클래스 java.nio.channels.CompletionHandler

``` java
CompletionHandler<V, A> callback = new CompletionHandler<V, A>(){ // V는 결과값 타입, A는 첨부값 타입
    @Override
    public void completed(V result, A attachment){
        
    }
    @Override
    public void failed(Throwable exc, A attachment){
        
    }
};
```



completed() : 작업을 정상 처리 완료했을 때 호출되는 콜백 메소드

faile() : 작업 처리 도중 예외가 발생했을 때 호출되는 콜백 메소드

``` java
Runnable task = new Runnable(){
    @Override
    public void run(){
        try{
            V result = ..;
            callback.completed(result, null); 
        }catch(Exception e){
            callback.failed(e, null);
        }
    }
};
```



``` java
import java.nio.channels.CompletionHandler;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallbackExample {
    private ExecutorService executorService;

    public CallbackExample(){
        executorService = Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors()
        );
    }
    
    private CompletionHandler<Integer, Void> callback =
            new CompletionHandler<Integer, Void>() {
                @Override
                public void completed(Integer result, Void attachment) {
                    System.out.println("completed() 실행: " + result);
                }

                @Override
                public void failed(Throwable exc, Void attachment) {
                    System.out.println("faile() 실행: " + exc.toString());
                }
            };
    
    public void doWork(final String x, final String y){
        Runnable task = new Runnable() {
            @Override
            public void run() {
                try{
                    int intX = Integer.parseInt(x);
                    int intY = Integer.parseInt(y);
                    int result = intX + intY;
                    callback.completed(result,null);
                }catch (NumberFormatException e){
                    callback.failed(e,null);
                }
            }
        };
        executorService.submit(task);
    }

    public void finish(){
        executorService.shutdown();
    }

    public static void main(String[] args){
        CallbackExample example = new CallbackExample();
        example.doWork("3","3");
        example.doWork("3","삼");
        example.finish();
    }
}
//
completed() 실행: 6
faile() 실행: java.lang.NumberFormatException: For input string: "삼"
```

