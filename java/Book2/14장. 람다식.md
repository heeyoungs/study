# 14장. 람다식

---



## 14.1 람다식이란?

---



```java
람다식-> 매개 변수를 가진 코드 블록-> 익명 구현 객체
```



```java
Runnable runnable = new Runnable({
    public void run(){...}
})
```



```java
Runnable runnable = ()->{...};
```





## 14.2 람다식 기본 문법

---



```java
(타입 매개변수, ...)->{실행문; ... }
```



```java
(int a) -> {System.out.println(a);}
```



```java
(a) -> {System.out.println(a);}
```



```java
a -> System.out.println(a)
```



```java
() -> {실행문; ... }
```



```java
(x, y) -> {return x + y;};
```



```java
(x, y) -> x + y;
```





## 14.3 타겟 타입과 함수적 인터페이스

---



```java
인터페이스 변수 = 람다식;
```



### 함수적 인터페이스(@FunctionalInterface)



```java
@FunctionalInterface
public interface MyfunctionalInterface{
    public void method();
    publicvoid otherMethod();
}
```



### 매개 변수와 리턴값이 없는 람다식



``` java
@FunctionalInterface
public interface MyFunctionalInterface{
    public void method();
}
```



```java
MyFunctionalInterface fi = ()->{...}
```



```java
fi.method();
```



```java
public class MyFunctionalInterfaceExample {
    public static void main(String[] args){
        MyFunctionalInterface fi;

        fi = ()->{
            String str = "method call1";
            System.out.println(str);
        };
        fi.method();

        fi = ()->{
            System.out.println("method call2");
        };
        fi.method();

        fi = ()->System.out.println("mathod call3");
        fi.method();
    }
}
//
method call1
method call2
mathod call3
```



### 매개 변수가 있는 람다식



```java
@FunctionalInterface
public interface MyFunctionalInterface_ {
    public void method(int x);
}
```





```java
MyFunctionalInterface fi = (x) -> {...} 또는 x -> {...}
```



```java
fi.method(5);
```

```java
public class MyFunctionalInterface_Example {
    public static void main(String[] args){
        MyFunctionalInterface_ fi;

        fi = (x)->{
            int result = x * 5;
            System.out.println(result);
        };
        fi.method(2);

        fi = (x)->{
            System.out.println(x*5);
        };
        fi.method(2);

        fi=x->System.out.println(x*5);
        fi.method(2);
    }
}
//
10
10
10
```



### 리턴값이 있는 람다식



```java
@FunctionalInterface
public interface MyFunctionalInterface__ {
    public int method(int x,int y);
}
```



```java
MyFunctinalInterface fi = (x,y) -> {...; return 값;}
```



```java
MyFunctionalInterface fi = (x, y) -> {return x + y;} => MyFunctionalInterface fi = (x, y) -> x + y;
MyFunctionalInterface fi = (x, y) -> {return sum(x,y;)} => MyFunctionalInterface fi = (x,y) -> sum(x,y);
```



```java
int result = fi.method(2,5);
```

```java
public class MyFunctionalInterface__Example {
    public static void main(String[] args){
        MyFunctionalInterface__ fi;

        fi=(x,y)->{
            int result = x + y;
            return result;
        };
        System.out.println(fi.method(2,5));

        fi=(x,y)->{
            return x+y;
        };
        System.out.println(fi.method(2,5));

        fi=(x,y)->x+y;
        System.out.println(fi.method(2,5));

        fi = (x,y)->sum(x,y);
        System.out.println(fi.method(2,5));
    }

    public static int sum(int x,int y){
        return x+y;
    }
}
//
7
7
7
7
```





## 14.4 클래스 멤버와 로컬 변수 사용

---



### 클래스의 멤버 사용



```java
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
}
```

```java
public class UsingThis {
    public int outterField = 10;

    class Inner{
        int innerField = 20;

        void method(){
            MyFunctionalInterface fi = ()->{
                System.out.println("outterField: " + outterField);
                System.out.println("outterField: " + UsingThis.this.outterField + "\n");

                System.out.println("innerField: " + innerField);
                System.out.println("innerField: " + this.innerField + "\n");
            };
            fi.method();
        }
    }
}
```

```java
public class UsingThisExample {
    public static void main(String[] args){
        UsingThis usingThis = new UsingThis();
        UsingThis.Inner inner = usingThis.new Inner();
        inner.method();
    }
}
//
outterField: 10
outterField: 10

innerField: 20
innerField: 20
```







### 로컬 변수 사용



```java
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
}
```

```java
public class UsingLocalVariable {
    void method(int arg){
        int localVar = 40;

        MyFunctionalInterface fi =()->{
            System.out.println("arg: " + arg);
            System.out.println("local: " + localVar + "\n");
        };
        fi.method();
    }
}
```

```java
public class UsingLocalVariableExample {
    public static void main(String[] args){
        UsingLocalVariable ulv = new UsingLocalVariable();
        ulv.method(20);
    }
}
//
arg: 20
local: 40
```







## 14.5 표준 API의 함수적 인터페이스

---



```java
public class RunnableExample {
    public static void main(String[] args){
        Runnable runnable = ()->{
            for(int i=0;i<10;i++){
                System.out.println(i);
            }
        };

        Thread thread = new Thread(runnable);
        thread.start();
    }
}
//
0
1
2
3
4
5
6
7
8
9
```



```java
Thread thread = new Thread(() -> {
    for(int i=0;i<10;i++){
        System.out.println(i);
    }
});
```



| 종류      | 추상 메소드 특징                                             |                                    |
| --------- | ------------------------------------------------------------ | ---------------------------------- |
| Consumer  | - 매개값은 있고, 리턴값은 없음                               | (매개값) -> Consumer               |
| Supplier  | - 매개값은 없고, 리턴값은 있음                               | Supplier -> (리턴값)               |
| Function  | - 매개값도 있고, 리턴값도 있음<br>- 주로 매개값을 리턴값을 매핑(타입 변환) | (매개값) -> Function -> (리턴값)   |
| Operator  | - 매가값도 있고, 리턴값도 있음<br>- 주로 매개값을 연산하고 결과를 리턴 | (매개값) -> Operator -> (리턴값)   |
| Predicate | - 매개값은 있고, 리턴 타입은 boolean<br>- 매개값을 조사해서 true/false를 리턴 | (매개값) -> Predicate -> (boolean) |



### Consumer 함수적 인터페이스



```java
(매개값) -> XXXConsumer
```



| 인터페이스명          | 추상 메소드                    | 설명                          |
| --------------------- | ------------------------------ | ----------------------------- |
| Consumer\<T>          | void accept(T t)               | 객체 T를 받아 소비            |
| BiConsumer<T,U>       | void accept(T t, U u)          | 객체 T와 U를 받아 소비        |
| DoubleConsumer        | void accept(double value)      | double 값을 받아 소비         |
| IntConsumer           | void accept(int value)         | int 값을 받아 소비            |
| LongConsumer          | void accept(long value)        | long 값을 받아 소비           |
| ObjDoubleConsumer\<T> | void accept(T t, double value) | 객체 T와 double값을 받아 소비 |
| ObjIntConsumer\<T>    | void accept(T t, int value)    | 객체 T와 int 값을 받아 소비   |
| ObjLongConsumer\<T>   | void accept(T t, long value)   | 객체 T와 long값을 받아 소비   |



```java
Consumer<String> consumer = t -> { t를 소비하는 실행문;};
```



```java
BiConsumer<String, String> consumer = (t, u) -> {t와 u를 소비하는 실행문;}
```



```java
DoubleConsumer consumer = d -> { d를 소비하는 실행문; }
```



```java
ObjIntConsumer<String> consumer = (t, i) -> {t와 i를 소비하는 실행문;}
```



```java
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.ObjIntConsumer;

public class ConsumerExample {
    public static void main(String[] args){
        Consumer<String> consumer = t->System.out.println(t+"8");
        consumer.accept("java");

        BiConsumer<String,String>bigConsumer = (t,u)->System.out.println(t+u);
        bigConsumer.accept("java","8");

        DoubleConsumer doubleConsumer = d->System.out.println("Java" + d);
        doubleConsumer.accept(8.0);

        ObjIntConsumer<String> objIntConsumer = (t,i)->System.out.println(t+i);
        objIntConsumer.accept("Java",8);
    }
}
//
java8
java8
Java8.0
Java8
```





### Supplier 함수적 인터페이스



```java
Supplier -> (리턴값)
```



| 인터페이스명    | 추상 메소드            | 설명              |
| --------------- | ---------------------- | ----------------- |
| Supplier\<T>    | T get()                | T 객체를 리턴     |
| BooleanSupplier | boolean getAsBoolean() | boolean 값을 리턴 |
| DoubleSupplier  | double getAsDouble()   | double 값을 리턴  |
| IntSupplier     | int getAsInt()         | int 값을 리턴     |
| LongSupplier    | long getAsLong()       | long 값을 리턴    |



```java
Supplier<String> supplier = () -> { ...; return "문자열"; }
```



```java
IntSupplier supplier = () -> {...; return int값; }
```



```java
import java.util.function.IntSupplier;

public class SupplierExample {
    public static void main(String[] args){
        IntSupplier intSupplier = ()->{
            int num = (int) (Math.random() * 6) + 1;
            return num;
        };

        int num = intSupplier.getAsInt();
        System.out.println("눈의 수: " + num);

    }
}
//
눈의 수: 6
```





### Function 함수적 인터페이스



```java
(매개값) -> Function -> (리턴값)
```



| 인터페이스명             | 추상 메소드                      | 설명                       |
| ------------------------ | -------------------------------- | -------------------------- |
| Function<T, R>           | R  apply(T t)                    | 객체 T를 객체 R로 매핑     |
| BiFunction<T, U, R>      | R apply(T t, U u)                | 객체 T와 U를 객체 R로 매핑 |
| DoubleFunction\<R>       | R apply(double value)            | double을 객체 R로 매핑     |
| IntFunction\<R>          | R apply(int value)               | int를 객체 R로 매핑        |
| IntToDoubleFunction      | double applyAsDouble(int value)  | int를 double로 매핑        |
| IntToLongFunction        | long applyAsLong(int value)      | int를 long으로 매핑        |
| LongToDoubleFunction     | double applyAsDouble(long value) | long을 double로 매핑       |
| LongToIntFunction        | int applyAsInt(long value)       | long을 int로 매핑          |
| ToDoubleBiFunction<T, U> | double ApplyAsDouble<T t, U u>   | 객체 T와 U를 double로 매핑 |
| ToDoubleFunction\<T>     | double applyAsDouble(T t)        | 객체 T를 double로 매핑     |
| ToIntBiFunction<T, U>    | int applyAsInt(T t, U u)         | 객체 T와 U를 int로 매핑    |
| ToIntFunction\<T>        | int applyAsInt(T t)              | 객체 T를 int로 매핑        |
| ToLongBiFunction<T, U>   | long applyAsLong(T t, U u)       | 객체 T와 U를 long으로 매핑 |
| ToLongFunction\<T>       | long applyAsLong(T t)            | 객체 T를 long으로 매핑     |

 

```java
Function<Student, String> function = t -> {return t.getName();}
또는
Function<Student, String> function = t -> t.getName();
```



```java
ToIntFunction<Student> function = t -> {return t.getScore();}
또는
ToIntFunction<Student> function = t -> t.getScore();
```



```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.ToIntFunction;

public class FunctionExample1 {
    private static List<Student> list  = Arrays.asList(
            new Student("홍길동",90,96),
            new Student("신용권",95,93)
    );

    public static void printString(Function<Student,String>function){
        for(Student student:list){
            System.out.println(function.apply(student) + " ");
        }
        System.out.println();
    }

    public static void printInt(ToIntFunction<Student> function){
        for(Student student:list){
            System.out.println(function.applyAsInt(student) + " ");
        }
        System.out.println();
    }

    public static void main(String[] args){
        System.out.println("[학생 이름]");
        printString(t->t.getName());

        System.out.println("[영어 점수]");
        printInt(t->t.getEnglishScore());

        System.out.println("[수학 점수]");
        printInt(t->t.getMathScore());
    }
}
//
[학생 이름]
홍길동 
신용권 

[영어 점수]
90 
95 

[수학 점수]
96 
93 
```

```java
public class Student {
    private String name;
    private int englishScore;
    private int mathScore;

    public Student(String name,int englishScore, int mathScore){
        this.name = name;
        this.englishScore = englishScore;
        this.mathScore = mathScore;
    }
    public String getName(){return name;}
    public int getEnglishScore(){return englishScore;}
    public int getMathScore(){return mathScore;}
}
```



```java
import java.util.Arrays;
import java.util.List;
import java.util.function.ToIntFunction;

public class FunctionExample2 {
    private static List<Student> list = Arrays.asList(
            new Student("홍길동",90,96),
            new Student("신용권",95,93)
    );

    public static double avg(ToIntFunction<Student> function){
        int sum = 0;
        for(Student student:list){
            sum += function.applyAsInt(student);
        }
        double avg = (double) sum / list.size();
        return avg;
    }

    public static void main(String[] args){
        double englishAvg = avg(s->s.getEnglishScore());
        System.out.println("영어 평균 점수: " + englishAvg);

        double mathAvg = avg(s->s.getMathScore());
        System.out.println("수학 평균 점수: " + mathAvg);
    }
}
//
영어 평균 점수: 92.5
수학 평균 점수: 94.5
```



### Operator 함수적 인터페이스



```java
(매개값) -> Operator -> (리턴값)
```



| 인터페이스명         | 추상 메소드                          | 설명                     |
| -------------------- | ------------------------------------ | ------------------------ |
| BinaryOperator\<T>   | T apply(Tt, Tt)                      | T와 T를 연산한 후 T 리턴 |
| UnaryOperator\<T>    | T apply(Tt)                          | T를 연산한 후 T 리턴     |
| DoubleBinaryOperator | double applyAsDouble(double, double) | 두 개의 double연산       |
| DoubleUnaryOperator  | double applyAsDouble(double)         | 한 개의 double연산       |
| IntBinaryOperator    | int applyAsInt(int, int)             | 두 개의 int 연산         |
| IntUnaryOperator     | int applyAsInt(int)                  | 한 개의 int 연산         |
| LongBinaryOperator   | long applyAsLong(long, long)         | 두 개의 long 연산        |
| LongUnaryOperator    | long applyAsLong(long)               | 한 개의 long 연산        |



```java
IntBinaryOperator operator = (a,b) -> {...;return int값;}
```



```java
import java.util.function.IntBinaryOperator;

public class OperatorExample {
    private static int[] scores = {92,95,87};

    public static int maxOrMin(IntBinaryOperator operator){
        int result = scores[0];
        for(int score: scores){
            result = operator.applyAsInt(result,score);
        }
        return result;
    }

    public static void main(String[] args){
        int max = maxOrMin(
                (a,b)->{
                    if(a>=b)return a;
                    else return b;
                }
        );
        System.out.println("최대값: " + max);

        int min = maxOrMin(
                (a,b) ->{
                    if(a<=b)return a;
                    else return b;
                }
        );
        System.out.println("최소값: " + min);
    }
}
//
최대값: 95
최소값: 87
```





### Predicate 함수적 인터페이스



```java
(매개값) -> Predicate -> (boolean)
```



| 인터페이스명      | 추상 메소드                | 설명                   |
| ----------------- | -------------------------- | ---------------------- |
| Predicate\<T>     | boolean test(T t)          | 객체 T를 조사          |
| BiPredicate<T, U> | boolean test(T t, U u)     | 객체 T와 U를 비교 조사 |
| DoublePredicate   | boolean test(double value) | double 값을 조사       |
| IntPredicate      | boolean test(int value)    | int 값을 조사          |
| LongPredicate     | boolean test(long value)   | long 값을 조사         |



```java
Predicate<Student> predicate = t -> {return t.getSex().equals("남자");}
또는
Predicate<Student> predicate = t -> t.getSex().equals("남자");
```



```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateExample {
    private static List<Student_> list = Arrays.asList(
            new Student_("홍길동","남자",90),
            new Student_("김순희","여자",90),
            new Student_("김자바","남자",95),
            new Student_("박한나","여자",92)
    );

    public static double avg(Predicate<Student_> predicate){
        int count = 0,sum=0;
        for(Student_ student : list){
            if(predicate.test(student)){
                count++;
                sum += student.getScore();
            }
        }
        return (double)sum/count;
    }

    public static void main(String[] args){
        double maleAvg = avg(t->t.getSex().equals("남자"));
        System.out.println("남자 평균 점수: " + maleAvg);

        double femaleAvg = avg(t->t.getSex().equals("여자"));
        System.out.println("여자 평균 점수: " + femaleAvg);
    }
}
//
남자 평균 점수: 92.5
여자 평균 점수: 91.0
```

```java
public class Student_ {
    private String name;
    private String sex;
    private int score;

    public Student_(String name,String sex,int score ){
        this.name = name;
        this.sex = sex;
        this.score = score;
    }

    public String getSex(){return sex;}
    public int getScore(){return score;}
}
```



### andThen()과 compose() 디폴트 메소드



```java
인터페이스AB = 인터페이스A.andThen(인터페이스B);
최종결과 = 인터페이스AB.method();
```



```java
인터페이스AB = 인터페이스A.compose(인터페이스B);
최종결과 = 인터페이스AB.method();
```



| 종류     | 함수적 인터페이스    | antThen() | compose() |
| -------- | -------------------- | --------- | --------- |
| Consumer | Consumer\<T>         | O         |           |
| -        | BiConsumer<T, U>     | O         |           |
| -        | DoubleConsumer       | O         |           |
| -        | IntConsumer          | O         |           |
| -        | LongConsumer         | O         |           |
| Function | Function<T, R>       | O         | O         |
| -        | BiFunction<T, U,  R> | O         |           |
| Operator | BinaryOperator\<T>   | O         |           |
| -        | DoubleUnaryOperator  | O         | O         |
| -        | IntUnaryOperator     | O         | O         |
| -        | LongUnaryOperator    | O         | O         |



#### Consumer의 순차적 연결



```java
import java.util.function.Consumer;

public class ConsumerAndThenExample {
    public static void main(String[] args){
        Consumer<Member> consumerA = (m)->{
            System.out.println("consumerA: " + m.getName());
        };

        Consumer<Member> consumerB = (m)->{
            System.out.println("consumerB: " + m.getId());
        };

        Consumer<Member> consumerAB = consumerA.andThen(consumerB);
        consumerAB.accept(new Member("홍길동","hong",null));
    }
}
//
consumerA: 홍길동
consumerB: hong
```

```java
public class Member {
    private String name;
    private String id;
    private Address address;

    public Member(String name, String id, Address address){
        this.name = name;
        this.id = id;
        this.address = address;
    }
    public String getName(){return name;}
    public String getId() {return id;}
    public Address getAddress(){return address;}
}
```

```java
public class Address {
    private String country;
    private String city;

    public Address(String country,String city){
        this.country = country;
        this.city = city;
    }

    public String getCountry(){return country;}
    public String getCity(){return city;}
}
```



#### Function의 순차적 연결



```java
import java.util.function.Function;

public class FunctionAndThenComposeExample {
    public static void main(String[] args){
        Function<Member,Address> functionA;
        Function<Address,String> functionB;
        Function<Member,String> functionAB;
        String city;

        functionA = (m)->m.getAddress();
        functionB = (a)->a.getCity();

        functionAB = functionA.andThen(functionB);
        city = functionAB.apply(
                new Member("홍길동","hong",new Address("한국","서울"))
        );
        System.out.println("거주 도시: " + city);

        functionAB = functionB.compose(functionA);
        city = functionAB.apply(
                new Member("홍길동","hong",new Address("한국","서울"))
        );
        System.out.println("거주 도시: " + city);
    }
}
//
거주 도시: 서울
거주 도시: 서울
```



### and(), or(), negate() 디폴트 메소드와 isEqual() 정적 메소드



| 종류      | 함수적 인터페이스 | and() | or() | negate() |
| --------- | ----------------- | ----- | ---- | -------- |
| Predicate | Predicate\<T>     | O     | O    | O        |
| -         | BiPredicate<T, U> | O     | O    | O        |
| -         | DoublePredicate   | O     | O    | O        |
| -         | IntPredicate      | O     | O    | O        |
| -         | LongPredicate     | O     | O    | O        |



``` java
import java.util.function.IntPredicate;

public class PredicateAndOrNegateExample {
    public static void main(String[] args){
        IntPredicate predicateA = a->a%2 == 0;

        IntPredicate predicateB = (a)->a%3 == 0;

        IntPredicate predicateAB;
        boolean result;

        predicateAB = predicateA.and(predicateB);
        result = predicateAB.test(9);
        System.out.println("9는 2와 3의 배수입니까? " + result);

        predicateAB = predicateA.or(predicateB);
        result = predicateAB.test(9);
        System.out.println("9는 2 또는 3의 배수입니까? " + result);

        predicateAB = predicateA.negate();
        result = predicateAB.test(9);
        System.out.println("9는 홀수입니까? " + result);
    }
}
//
9는 2와 3의 배수입니까? false
9는 2 또는 3의 배수입니까? true
9는 홀수입니까? true
```



```java
Predicate<Object> predicate = Predicate.isEqual(targetObject);
boolean result = predicate.test(sourceObject);
```



| sourceObject | targetObject | 리턴값                                     |
| ------------ | ------------ | ------------------------------------------ |
| null         | null         | true                                       |
| not null     | null         | false                                      |
| null         | not null     | false                                      |
| not null     | not null     | sourceObject.equals(targetObject)의 리턴값 |



```java
import java.util.function.Predicate;

public class PredicateIsEqualExample {
    public static void main(String[] args){
        Predicate<String> predicate;

        predicate = Predicate.isEqual(null);
        System.out.println("null, null: " + predicate.test(null));

        predicate = Predicate.isEqual("Java8");
        System.out.println("null, Java8: " + predicate.test(null));

        predicate = Predicate.isEqual(null);
        System.out.println("Java8, null: " + predicate.test("Java8"));

        predicate = Predicate.isEqual("Java8");
        System.out.println("Java8, Java8: " + predicate.test("Java8"));

        predicate = Predicate.isEqual("Java8");
        System.out.println("Java7, Java8: " + predicate.test("Java7"));
    }
}
//
null, null: true
null, Java8: false
Java8, null: false
Java8, Java8: true
Java7, Java8: false
```



### minBy(), maxBy() 정적 메소드



| 리턴 타입          | 정적 메소드                             |
| ------------------ | --------------------------------------- |
| BinaryOperator\<T> | minBy(Comparator<? super T> comparator) |
| BinaryOperator\<T> | maxBy(Comparator<? super T> comparator) |



```java
@FunctionalInterface
public interface Comparaotr<T>{
    public int compare(T o1, T o2);
}
```



```java
(o1, o2) -> {...; return int값; }
```



```java
(o1, o2) -> Integer.compare(o1, o2);
```



```java
import ch15.Fruit;

import java.util.function.BinaryOperator;

public class OperatorMinByMaxExample {
    public static void main(String[] args){
        BinaryOperator<Fruit> binaryOperator;
        Fruit fruit;

        binaryOperator = BinaryOperator.minBy((f1,f2)->Integer.compare(f1.price,f2.price));
        fruit = binaryOperator.apply(new Fruit("딸기",6000),new Fruit("수박",10000));
        System.out.println(fruit.name);

        binaryOperator = BinaryOperator.maxBy((f1,f2)->Integer.compare(f1.price,f2.price));
        fruit = binaryOperator.apply(new Fruit("딸기",6000),new Fruit("수박",10000));
        System.out.println(fruit.name);
    }
}
//
딸기
수박
```





## 14.6 메소드 참조

---



```java
(left, right) -> Math.max(left, right);
```



```java
Math :: max;
```



```java
IntBinaryOperator operator = Math :: max;
```



### 정적 메소드와 인스턴스 메소드 참조



```java
클래스 :: 메소드
```



```java
참조변수 :: 메소드
```



```java
public class Calculator {
    public static int staticMethod(int x,int y){
        return x + y;
    }
    public int instanceMethod(int x, int y){
        return x + y;
    }
}
```

```java
import java.util.function.IntBinaryOperator;

public class MethodReferencesExample {
    public static void main(String[] args){
        IntBinaryOperator operator;

        operator = (x,y)->Calculator.staticMethod(x,y);
        System.out.println("결과1: " + operator.applyAsInt(1,2));

        operator = Calculator :: staticMethod;
        System.out.println("결과2: " + operator.applyAsInt(3,4));

        Calculator obj = new Calculator();
        operator = (x,y)->obj.instanceMethod(x,y);
        System.out.println("결과3: " + operator.applyAsInt(5,6));

        operator = obj :: instanceMethod;
        System.out.println("결과4: " + operator.applyAsInt(7,8));
    }
}
//
결과1: 3
결과2: 7
결과3: 11
결과4: 15
```



### 매개 변수의 메소드 참조



```java
(a, b) -> {a.instanceMethod(b);}
```



```java
클래스 :: instanceMethod
```



```java
import java.util.function.ToIntBiFunction;

public class ArgumentMethodReferencesExample {
    public static void main(String[] args){
        ToIntBiFunction<String,String> function;

        function = (a,b)->a.compareToIgnoreCase(b);
        print(function.applyAsInt("Java8","JAVA8"));

        function = String :: compareToIgnoreCase;
        print(function.applyAsInt("Java8","JAVA8"));
    }
    public static void print(int order){
        if(order<0){System.out.println("사전순으로 먼저 옵니다.");}
        else if(order == 0){System.out.println("동일한 문자열입니다.");}
        else{System.out.println("사전순으로 나중에 옵니다.");}
    }
}
//
동일한 문자열입니다.
동일한 문자열입니다.
```





### 생성자 참조



```java
(a, b) -> {return new 클래스(a, b);}
```



```java
클래스 :: new
```



```java
import java.util.function.BiFunction;
import java.util.function.Function;

public class ConstructorReferencesExample {
    public static void main(String[] args){
        Function<String,Member_>function1 = Member_ :: new;
        Member_ member1 = function1.apply("angel");

        BiFunction<String,String,Member_>function2 = Member_ :: new;
        Member_ member2 = function2.apply("신천사","angel");
    }
}
//
Member(String id) 실행
Member(String name, String id)
```

```java
public class Member_ {
    private String name;
    private String id;

    public Member_(){
        System.out.println("Member() 실행");
    }
    public Member_(String id){
        System.out.println("Member(String id) 실행");
        this.id = id;
    }
    public Member_(String name,String id){
        System.out.println("Member(String name, String id)");
        this.name = name;
        this.id = id;
    }
}
```



