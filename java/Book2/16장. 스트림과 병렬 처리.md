# 16장. 스트림과 병렬 처리

---



## 16.1 스트림 소개

---

스트림은 자바 8부터 추가된 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 반복자이다.

### 반복자 스트림

이터레이터를 사용해서 요소를 순차적으로 처리할 경우

```java
List<String> list = Arrays.asList("홍길동","신용권","김자바");
Iterator<String> iterator = list.iterator();
while(iterator.hasNext()){
    String name = iterator.next();
    System.out.println(name);
}
```



stream을 사용할 경우

```java
List<String> list = Arrays.asList("홍길동","신용권","김자바");
Stream<String> stream = list.stream();
stream.forEach( name -> System.out.println(name));
```

- stream.forEach(); 메소드를 통해 컬렉션의 요소를 하나씩 출력한다.

- 코드가 훨씬 간결해졌다.



```java
void forEach(Consumer<T> action)
```

Consumer 함수적 인터페이스 타입의 매개값을 가지므로 컬렉션의 요소를 소비할 코드를 람다식으로 기술할 수 있다. 



```java
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Stream;

public class IteratorVsStreamExample {
	public static void main(String[] args) {
		List<String> list = Arrays.asList("홍길동", "신용권", "김자바");

		Iterator<String> iterator = list.iterator();
		while(iterator.hasNext()) { // 이너레이터 사용
			String name = iterator.next();
			System.out.println(name);
		}
		
		System.out.println();

		Stream<String> stream = list.stream(); // stream 사용
		stream.forEach( name -> System.out.println(name) );
	}
}
//
홍길동
신용권
김자바

홍길동
신용권
김자바
```



### 스트림의 특징

스트림과 이터레이터의 차이점

1. 요소 처리 코드를 제공하는 점
2. 내부 반복자를 사용해 병렬 처리가 쉽다는 점
3. 중간 처리와 최종 처리 작업을 수행하는 점



#### 람다식으로 요소 처리 코드를 제공한다.

스트림이 제공하는 대부분의 요소처리는 함수적 인터페이스 매개값을 가진다.

-> 람다식또는 메소드 참조를 이용해서 요소 처리 내용을 매개값으로 전달할 수 있다.

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class LambdaExpressionsExample {
	public static void main(String[] args) {
		List<Student> list = Arrays.asList(
				new Student("홍길동", 90),
				new Student("신용권", 92)
		);
		
		Stream<Student> stream = list.stream();
		stream.forEach(s -> { // list컬렉션에서 Student를 가져옴.
			String name = s.getName(); // 이름을 가져옴
			int score = s.getScore(); // 점수를 가져옴
			System.out.println(name + "-" + score);
		});
	}
}
//
홍길동-90
신용권-92
```

```java
public class Student {
	private String name;
	private int score;
	
	public Student (String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



#### 내부 반복자를 사용하므로 병렬 처리가 쉽다.

외부 반복자란? index를 사용하는 for문, Iterator을 사용하는 while문

내부 반복자란? 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야 할 코드만 제공하는 코드 패턴



- 내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 병렬 작업을 할 수 있게 도와준다.

-> 따라서 외부 반복자보다 효율적으로 요소를 반복시킬 수 있다.

-> 병렬이란? 한 가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하는 것.

- Iterator은 컬렉션의 요소를 가져오는 것부터 처리하는 것 까지 개발자가 작성해서 번거로우나, 스트림은 람다식으로 요소 처리만 한다. 

-> 코드가 간결해진다.



```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class ParallelExample {	
	public static void main(String[] args) {
		List<String> list = Arrays.asList("홍길동", "신용권", "김자바", "람다식", "박병렬");

		Stream<String> stream = list.stream(); // 순차 처리
		stream.forEach(ParallelExample :: print); // 메소드 참조
		
		System.out.println();

		Stream<String> parallelStream = list.parallelStream(); // 병렬 처리
		parallelStream.forEach(ParallelExample :: print); // 스레드 풀이 사용된다.
	}
	
	public static void print(String str) {
		System.out.println(str+ " : " + Thread.currentThread().getName()); // 스레드 이름 출력
	}	
}
//
홍길동 : main
신용권 : main
김자바 : main
람다식 : main
박병렬 : main

김자바 : main
람다식 : ForkJoinPool.commonPool-worker-2
홍길동 : ForkJoinPool.commonPool-worker-2
신용권 : ForkJoinPool.commonPool-worker-1
박병렬 : main
```



#### 스트림은 중간 처리와 최종 처리를 할 수 있다.

중간 처리 : 매핑, 필터링, 정렬

최종 처리 : 반복, 카운팅, 평균, 총합등의 집계 처리

```java
import java.util.Arrays;
import java.util.List;

public class MapAndReduceExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 10),
				new Student("신용권", 20),
				new Student("유미선", 30)
		);		
			
		double avg = studentList.stream()
			.mapToInt(Student :: getScore) // 학생의 점수를 가져옴
			.average() // 평균
			.getAsDouble(); // double타입
		
		System.out.println("평균 점수: " + avg);
	}
}
//
평균 점수: 20.0
```



## 16.2 스트림의 종류

---

java.util.stream 패키지에는 stream의 API들이 있다.

여기서 BaseStream인터페이스를 부모로 해서 자식 인터페이스들이 상속 관계을 이루고 있다. (Stream, IntStream, LongStream, DoubleStream)

- Stream : 객체 요소를 처리하는 스트림

- IntStream, LongStream, DoubleStream : int, long, double 요소를 처리하는 스트림.



아래표에 있는 소스로부터 스트림 구현 객체를 얻을 수 있다.

| 리턴 타입                                             | 메소드(매개 변수)                                            | 소스      |
| ----------------------------------------------------- | ------------------------------------------------------------ | --------- |
| Stream\<T>                                            | java.util.Collection.stream()<br>java.util.Collection.parrelStream() | 컬렉션    |
| Stream\<T><br>IntStream<br>LongStream<br>DoubleStream | Arrays.stream(T[]),           Stream.of(T[])<br>Arrays.stream(int[]),         IntStream.of(int[])<br>Arrays.stream(long[]),      LongStream.of(long[])<br>Arrays.stream(double[]), DoubleStream.of(double[]) | 배열      |
| IntStream                                             | IntStream.range(int, int)<br>IntStream.rangeClosed(int, int) | int 범위  |
| LongStream                                            | LongStream.range(long, long)<br>LongStream.rangeClosed(long, long) | long 범위 |
| Stream\<Path>                                         | Files.find(Path, int, BiPredicate, FileVisitOption)<br>Files.list(Path) | 디렉토리  |
| Stream\<String>                                       | Files.lines(Path. Charset)<br>BufferdReader.lines()          | 파일      |
| DoubleStream<br>IntStream<br>LongStream               | Random.doubles(...)<br>Random.ints()<br>Random.longs()       | 랜덤 수   |



### 컬렉션으로부터 스트림 얻기

List<Student\>

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class FromCollectionExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
			new Student("홍길동", 10),
			new Student("신용권", 20),
			new Student("유미선", 30)
		);
		
		Stream<Student> stream = studentList.stream();
		stream.forEach(s -> System.out.println(s.getName()));
	}
}
```

```java
public class Student {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



### 배열로부터 스트림 얻기

String[], int[]

```java
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class FromArrayExample {
	public static void main(String[] args) {
		String[] strArray = { "홍길동", "신용권", "김미나"};
		Stream<String> strStream = Arrays.stream(strArray);
		strStream.forEach(a -> System.out.print(a + ","));
		System.out.println();
		
		int[] intArray = { 1, 2, 3, 4, 5 };
		IntStream intStream = Arrays.stream(intArray);
		intStream.forEach(a -> System.out.print(a + ","));
		System.out.println();
	}
}
//
홍길동,신용권,김미나,
1,2,3,4,5,
```



### 숫자 범위로부터 스트림 얻기

IntStream의 rangeClosed() : 첫 번째 매개값부터 두 번째 매개값까지 순차적으로 제공

``` java
import java.util.stream.IntStream;

public class FromIntRangeExample {
	public static int sum;
	
	public static void main(String[] args) {
		IntStream stream = IntStream.rangeClosed(1,  100);
		stream.forEach(a -> sum += a);
		System.out.println("총합: " + sum);
	}
}
//
총합: 5050
```

- rangeClosed : 첫번째 매개값 <=  x <= 두번째 매개값
- range : 첫번째 매개값 <= x < 두번째 매개값



### 파일로부터 스트림 얻기

lines()와 BufferedReader의 lines() 메소드를 이용해서 문자 파일의 내용을 스트림을 통해 행 단위로 읽고 콘솔에 출력한다.

```java
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class FromFileContentExample {
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("C:\Users\user\Desktop\study\text.txt");
		Stream<String> stream;
		
		stream = Files.lines(path, Charset.defaultCharset());
		stream.forEach( System.out :: println ); // 메소드 참조
		stream.close();
		System.out.println();
		
		File file = path.toFile(); // 18장 파일 입출력
		FileReader fileReader = new FileReader(file);
		BufferedReader br = new BufferedReader(fileReader);
		stream = br.lines();
		stream.forEach( System.out :: println );
		stream.close();
	}
}
//
hello

hello
```



### 디렉토리로부터 스트림 얻기

Files의 정적 메소드 list()를 이용해서 디렉토리의 내영을 스트림을 통해 읽고 콘솔에 출력한다.

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class FromDirectoryExample {
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("C:\Users\user\Desktop");
		Stream<Path> stream = Files.list(path);
		stream.forEach( p -> System.out.println(p.getFileName()) );
	}
}
//
desktop.ini
javaProject
study
학교 수업 자료
```



## 16.3 스트림 파이프라인

---

리덕션? 대량의 데이터를 가공해서 축소하는 것

-> 합계, 평균값, 카운팅, 최대값, 최소값



데이터를 리덕션하기 위해선 중간 처리인 필터링, 매핑, 정렬, 그룹핑들이 필요하다.!

### 중간 처리와 최종 처리

스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 합계, 평균, 카운팅, 최대값, 최소값 등의 최종 처리를 파이프라인으로 해결한다.

-> 여기서 파이프라인은 여러 개의 스트림이 연결되어있는 구조이다.

-> 최종 처리를 제외하고는 모두 중간 처리 스트림이다.

-> 중간 스트림은 생성되면 바로 중간 처리되는게 아니라 최종 처리가 시작될 때까지 지연되고, 최종 처리가 시작되면 컬렉션 요소가 하나씩 중간 스트림에서 처리되고 최종 처리까지 오게된다.



```java
Stream<Member> maleFemaleStream = list.stream(); // 리스트 스트림의
Stream<Member> maleStream = maleFemaleStream.filter(m -> m.getSex() == Member.MALE); // 남자
IntStream ageStream = maleStream.mapToInt(Member::getAge); // 나이
OptionalDouble optionalDouble = ageStream.average(); // 평균
double ageAvg = optionalDouble.getASDouble(); // double타입
```

-> 위 코드를 하나로 로컬 변수 생략하고 하나로 묶으면!

```java
double ageAvg = list.stream()
    .filter(m->m.getSex() == Member.MALE)
    .mapToInt(Member :: getAge)
    .average()
    .getAsDouble();
```



```java
import java.util.Arrays;
import java.util.List;

public class StreamPipelinesExample {
	public static void main(String[] args) {
		List<Member> list = Arrays.asList(
				new Member("홍길동", Member.MALE, 30),
				new Member("김나리", Member.FEMALE, 20),
				new Member("신용권", Member.MALE, 45),
				new Member("박수미", Member.FEMALE, 27)
		);
		
		double ageAvg = list.stream()
			.filter(m -> m.getSex()==Member.MALE)
			.mapToInt(Member :: getAge)
			.average()
			.getAsDouble();
		
		System.out.println("남자 평균 나이: " + ageAvg);
	}
}
//
남자 평균 나이: 37.5
```

```java
public class Member {
	public static int MALE = 0;
	public static int FEMALE = 1;
	
	private String name;
	private int sex;
	private int age;
	
	public Member(String name, int sex, int age) {
		this.name = name;
		this.sex = sex;
		this.age = age;
	}

	public int getSex() { return sex; }
	public int getAge() { return age; }
}
```



### 중간 처리 메소드와 최종 처리 메소드

중간 처리와, 최종 처리의 메소드 종류

| 종류      |        | 리턴 타입                                         | 메소드(매개 변수)    | 소속된 인터페이스                   |
| --------- | ------ | ------------------------------------------------- | -------------------- | ----------------------------------- |
| 중간처리  | 필터링 | Stream<br>IntStream<br>LongStream<br>DoubleStream | distinct()           | 공통                                |
|           | -      |                                                   | filter(...)          | 공통                                |
|           | 매핑   |                                                   | flatMap(...)         | 공통                                |
|           | -      |                                                   | flatMapToDouble(...) | Stream                              |
|           | -      |                                                   | flatMaptToInt(...)   | Stream                              |
|           | -      |                                                   | flatMapToLong(...)   | Stream                              |
|           | -      |                                                   | map(...)             | 공통                                |
|           | -      |                                                   | mapToDouble(...)     | Stream, IntStream, LongStream       |
|           | -      |                                                   | mapToInt(...)        | Stream, LongStream, DoubleStream    |
|           | -      |                                                   | mapToLong(...)       | Stream, IntStream, DoubleStream     |
|           | -      |                                                   | mapToObj(...)        | IntStream, LongStream, DoubleStream |
|           | -      |                                                   | asDoubleStream()     | IntStream, LongStream               |
|           | -      |                                                   | asLongStream()       | IntStream                           |
|           | -      |                                                   | boxed()              | IntStream, LongStream, DoubleStream |
|           | 정렬   |                                                   | sorted(...)          | 공통                                |
|           | 루핑   |                                                   | peek(...)            | 공통                                |
| 최종 처리 | 매칭   | boolean                                           | allMatch(...)        | 공통                                |
|           | -      | boolean                                           | anyMatch(...)        | 공통                                |
|           | -      | boolean                                           | nonoMatch(...)       | 공통                                |
|           | 집계   | long                                              | count()              | 공통                                |
|           | -      | OptionalXXX                                       | findFirst()          | 공통                                |
|           | -      | OptionalXXX                                       | max(...)             | 공통                                |
|           | -      | OptionalXXX                                       | min(...)             | 공통                                |
|           | -      | OptionalDouble                                    | average()            | IntStream, LongStream, DoubleStream |
|           | -      | OptionalXXX                                       | reduce(...)          | 공통                                |
|           | -      | int, long, double                                 | sum()                | IntStream, LongStream, DoubleStream |
|           | 루핑   | void                                              | forEach(...)         | 공통                                |
|           | 수집   | R                                                 | collect(...)         | 공통                                |

-> 중간 처리의 리턴 값은 스트림이고, 최종 처리의 리턴 값은 기본 타입또는 OptionalXXX이다.



## 16.4 필터링(distinct(), filter()) 중간 처리

---

필터링 : 요소를 걸러내는 역할

| 리턴 타입                                         | 메소드(매개 변수)       | 설명        |
| ------------------------------------------------- | ----------------------- | ----------- |
| Stream<br>IntStream<br>LongStream<br>DoubleStream | distinct()              | 중복 제거   |
| -                                                 | filter(Predicate)       | 조건 필터링 |
| -                                                 | filter(IntPredicate)    | -           |
| -                                                 | filter(LongPredicate)   | -           |
| -                                                 | filter(DoublePredicate) | -           |

- distinct : 중복을 제거
- filter : Predicate가 true를 리턴하는 요소만 필터링



```java
import java.util.Arrays;
import java.util.List;

public class FilteringExample {
	public static void main(String[] args) {
		List<String> names = Arrays.asList("홍길동", "신용권", "김자바", "신용권", "신민철");
		
		names.stream()
			.distinct() // 중복 필터링
			.forEach(n -> System.out.println(n));
		System.out.println();
		
		names.stream()
			.filter(n -> n.startsWith("신")) // 첫 인덱스가 "신"인 사람 필터링
			.forEach(n -> System.out.println(n));
		System.out.println();
		
		names.stream()
			.distinct()
			.filter(n -> n.startsWith("신"))
			.forEach(n -> System.out.println(n));		
	}
}
//
홍길동
신용권
김자바
신민철

신용권
신용권
신민철

신용권
신민철
```



## 16.5 매핑(flatMapXXX(), mapXXX(), asXXXStream(), boxed()) 중간 처리

---

매핑 : 스트림의 요소를 다른 요소로 대체하는 역할

### flatMapXXX() 메소드

-> 요소를 대체하는 복수 개의 요소들로 구성된 새로운 스트림을 리턴한다.

flatMapXXX() 메소드

| 리턴 타입    | 메소드(매개 변수)                          | 요소 -> 대체 요소      |
| ------------ | ------------------------------------------ | ---------------------- |
| Stream\<R>   | flatMap(Function<T, Stream< R>>)           | T -> Stream\<R>        |
| DoubleStream | flatMap(DoubleFunction\<DoubleStream>)     | double -> DoubleStream |
| IntStream    | flatMap(IntFunction\<IntStream>)           | int -> IntStream       |
| LongStream   | flatMap(LongFunction\<LongStream>)         | long -> LongStream     |
| DoubleStream | flatMapToDouble(Function<T, DoubleStream>) | T -> DoubleStream      |
| IntStream    | flatMapToInt(Function<T, IntStream>)       | T -> IntStream         |
| LongStream   | flatMapToLong(Function<T, LongStream>)     | T -> LongStream        |



```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

public class FlatMapExample {
	public static void main(String[] args) {
		List<String> inputList1 = Arrays.asList("java8 lambda", "stream mapping");
		inputList1.stream()
			.flatMap(data -> Arrays.stream(data.split(" "))) // " "를 기준으로 문자열을 끊는다.
			.forEach(word -> System.out.println(word)); //  출력
		
		System.out.println();
		
		List<String> inputList2 = Arrays.asList("10, 20, 30", "40, 50, 60");
		inputList2.stream()
			.flatMapToInt(data -> {
				String[] strArr = data.split(","); // ,를 기준으로 문자열을 끊는다.
				int[] intArr = new int[strArr.length]; // int[] 를 생성한다.
				for(int i=0; i<strArr.length; i++) { 
					intArr[i] = Integer.parseInt(strArr[i].trim()); // 공백 제거해서, int형으로 형변환해서 저장한다.
				}
				return Arrays.stream(intArr); // int[]를 리턴한다. 
			})
			.forEach(number -> System.out.println(number));
	}
}
//
java8
lambda
stream
mapping

10
20
30
40
50
60
```



### mapXXX() 메소드

-> 요소를 대체하는 요소로 구성된 새로운 스트림

| 리턴 타입    | 메소드(매개 변수)                 | 요소 -> 대체 요소 |
| ------------ | --------------------------------- | ----------------- |
| Stream\<R>   | map(Function<T, R>)               | T -> R            |
| DoubleStream | mapToDouble(ToDoubleFunction\<T>) | T -> double       |
| IntStream    | mapToInt(ToIntFunction\<T>)       | T -> int          |
| LongStream   | mapToLong(ToLongFunction\<T>)     | T -> long         |
| DoubleStream | map(DoubleUnaryOperator)          | double -> double  |
| IntStream    | mapToInt(DoubleToIntFunction)     | double -> int     |
| LongStream   | mapToLong(DoubleToLongFunction)   | double -> long    |
| Stream\<U>   | mapToObj(DoubleFunction\<U>)      | double -> U       |
| IntStream    | map(IntUnaryOperator)             | int -> int        |
| DoubleStream | mapToDouble(IntToDoubleFunction)  | int -> double     |
| LongStream   | mapToLong(IntToLongFunction)      | int -> long       |
| Stream\<U>   | mapToObj(IntFunction\<U>)         | int -> U          |
| LongStream   | map(LongUnaryOperator)            | long -> long      |
| DoubleStream | mapToDouble(LongToDoubleFunction) | long -> double    |
| IntStream    | mapToInt(LongToIntFunction)       | long -> int       |
| Stream\<U>   | mapToObj(LongFunction\<U>)        | long -> U         |



```java
import java.util.Arrays;
import java.util.List;

public class MapExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 10),
				new Student("신용권", 20),
				new Student("유미선", 30)
		);
			
		studentList.stream()
			.mapToInt(Student :: getScore) // T -> int
			.forEach(score -> System.out.println(score));
	}
}
//
10
20
30
```

```java
public class Student {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



### asDoubleStream(), asLongStream(), boxed() 메소드

| 리턴 타입                                            | 메소드(매개 변수) | 설명                                               |
| ---------------------------------------------------- | ----------------- | -------------------------------------------------- |
| DoubleStream                                         | asDoubleStream()  | int -> double<br>long -> double                    |
| LongStream                                           | asLongStream()    | int -> long                                        |
| Stream\<Integer><br>Stream\<Long><br>Stream\<Double> | boxed()           | int -> Integer<br>long -> Long<br>double -> Double |

- asDoubleStream : IntStream의 int요소 또는 LongStream의 long요소를 double요소로 타입 변환해서 DoubleStream을 생성한다.
- asLongStream : IntStreamd의 int요소를 long요소로 타입 변환해서 LongStream을 생성한다.
- boxed : int, long, double요소를 Int, Long, Double 요소로 박싱한다.



```java
import java.util.Arrays;
import java.util.stream.IntStream;

public class AsDoubleStreamAndBoxedExample {
	public static void main(String[] args) {
		int[] intArray = { 1, 2, 3, 4, 5};
		
		IntStream intStream = Arrays.stream(intArray);
		intStream
			.asDoubleStream() // double형으로 타입 변환
			.forEach(d -> System.out.println(d));
			
		System.out.println();
		
		intStream = Arrays.stream(intArray);
		intStream
			.boxed() // 박싱
			.forEach(obj -> System.out.println(obj.intValue()));
	}
}
//
1.0
2.0
3.0
4.0
5.0

1
2
3
4
5
```



## 16.6 정렬(sorted()) 중간 처리

---

요소를 최종 처리되기 전에 중간 단계에서 요소를 정렬해서 최종 처리 순서를 변경할 수 있다.

| 리턴 타입    | 메소드(매개 변수)      | 설명                                    |
| ------------ | ---------------------- | --------------------------------------- |
| Stream\<T>   | sorted()               | 객체를 Comparable 구현 방법에 따라 정렬 |
| Stream\<T>   | sorted(Comparator\<T>) | 객체를 주어진 Comparator에 따라 정렬    |
| DoubleStream | sorted()               | double 요소를 오름차순으로 정렬         |
| IntStream    | sorted()               | int 요소를 오름차순으로 정렬            |
| LongStream   | sorted()               | long 요소를 오름차순으로 정렬           |

-> 객체 요소일 경우에는 Comparable을 구현해야 한다. (ClassCastException예외)



```java
public class Student implements Comparable<Student> {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }

	@Override
	public int compareTo(Student o) {
		return Integer.compare(score, o.score);
	}
}
```



Comparable을 구현한 상태에서 기본 비교 방법으로 정렬하고 싶을 때는 아래 3개중에 하나를 사용하면된다.

```java
sorted();
sorted( (a,b) -> a.compareTo(b) );
sorted( Comparator.naturalOrder() );
```



반대로 정렬하는 방법

```java
sorted( (a,b) -> b.compareTo(a) );
sorted( Comparator.reverseOrder() );
```



람다식을 매개값으로 작성할 수도 있다.

```java
sorted( (a,b) -> {...} )
```



```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.IntStream;

public class SortingExample {
	public static void main(String[] args) {
		IntStream intStream = Arrays.stream(new int[] {5, 3, 2, 1, 4});
		intStream
			.sorted() // int[] 배열 정렬
			.forEach(n -> System.out.print(n + ","));
		System.out.println();

		List<Student> studentList = Arrays.asList(
			new Student("홍길동", 30),
			new Student("신용권", 10),
			new Student("유미선", 20)
		);
		
		studentList.stream()
			.sorted( ) // 점수를 기준으로 오름차순
			.forEach(s -> System.out.print(s.getScore() + ","));
		System.out.println();
		
		studentList.stream()
		.sorted( Comparator.reverseOrder() ) // 내림차순
		.forEach(s -> System.out.print(s.getScore() + ","));	
	}
}
//
1,2,3,4,5,
10,20,30,
30,20,10,
```



## 16.7 루핑(peek()-중간 처리, forEach()-최종 처리) 

---

루핑 : 요소 전체를 반복하는 것

peek : 중간 처리 단계에서 전체 요소를 루핑하면서 추가적인 작업을 하기위해 사용 -> 최종 처리 메소드가 호출되어야 동작한다.

forEach : 파이프라인 마지막에 루핑하면서 요소를 하나씩 처리한다. -> 최종 처리 메소드이므로 다른 최종 처리 메소드를 호출하면 안된다.

```java
intStream
    .filter(a -> a%2 == 0)
    .peek( a -> System.out.println(a) )
```

-> 동작하지 않는다.



```java
intStream
    .filter( a -> a%2==0)
    .peek( a -> System.out.println(a) )
    .sum()
```

-> 동작한다.



```java
import java.util.Arrays;

public class LoopingExample {
	public static void main(String[] args) {
		int[] intArr = { 1, 2, 3, 4, 5 };
		
		System.out.println("[peek()를 마지막에 호출한 경우]");
		Arrays.stream(intArr)
			.filter(a -> a%2==0)
			.peek(n -> System.out.println(n)); // 출력 안됨
		
		System.out.println("[최종 처리 메소드를 마지막에 호출한 경우]");
		int total = Arrays.stream(intArr)
			.filter(a -> a%2==0)
			.peek(n -> System.out.println(n))
			.sum();
		System.out.println("총합: " + total);
		
		System.out.println("[forEach()를 마지막에 호출한 경우]");
		Arrays.stream(intArr)
			.filter(a -> a%2==0)
			.forEach(n -> System.out.println(n)); 
	}
}
//
[peek()를 마지막에 호출한 경우]
[최종 처리 메소드를 마지막에 호출한 경우]
2
4
총합: 6
[forEach()를 마지막에 호출한 경우]
2
4
```



## 16.8 매칭(allMatch(), anyMatch(), noneMatch()) - 최종 처리

---

allMatch : 모든 요소들이 매개값으로 주어진 Predicate의 조건을 만족하는지 조사

anyMatch : 최소한 한 개의 요소가 매개값으로 주어진 Predicate의 조건을 만족하는지 조사

noneMatch : 모든 요소들이 매개값으로 주어진 Predicate 의 조건을 만족하지 않는지 조사

| 리턴 타입 | 메소드(매개 변수)                                            | 제공 인터페이스 |
| --------- | ------------------------------------------------------------ | --------------- |
| boolean   | allMatch(Predicate\<T> predicate)<br>anyMatch(Predicate\<T> predicate)<br>noneMatch(Predicate\<T> predicate) | Stream          |
| boolean   | allMatch(IntPredicate predicate)<br>anyMatch(IntPredicate predicate)<br>nonMatch(IntPredicate predicate) | IntStream       |
| boolean   | allMatch(LongPredicate predicate)<br>anyMatch(LongPredicate predicate)<br>noneMatch(LongPredicate predicate) | LongStream      |
| boolean   | allMatch(DoublePredicate predicate)<br/>anyMatch(DoublePredicate predicate)<br/>noneMatch(DoublePredicate predicate) | DoubleStream    |



```java
import java.util.Arrays;

public class MatchExample {
	public static void main(String[] args) {
		int[] intArr = { 2, 4 ,6 };
		
		boolean result = Arrays.stream(intArr)
			.allMatch(a -> a%2==0); // all true
		System.out.println("모두 2의 배수인가? " + result);
		
		result = Arrays.stream(intArr)
			.anyMatch(a -> a%3==0); // 6 true
		System.out.println("하나라도 3의 배수가 있는가? " + result);
		
		result = Arrays.stream(intArr)
			.noneMatch(a -> a%3==0); // 6 false
		System.out.println("3의 배수가 없는가?  " + result);
	}
}
//
모두 2의 배수인가? true
하나라도 3의 배수가 있는가? true
3의 배수가 없는가?  false
```



## 16.9 기본 집계 (sum(), count(), average), max(), min()) - 최종 처리

---

집계 : 요소들을 처리해서 카운팅, 합계, 평균값, 최대값, 최소값등과 같이 하나의 값으로 산출하는 것. (리덕션)

### 스트림이 제공하는 기본 집계

스트림의 집계 메소드

| 리턴 타입                   | 메소드(매개 변수)            | 설명         |
| --------------------------- | ---------------------------- | ------------ |
| long                        | count()                      | 요소 개수    |
| OptionalXXX                 | findFirst()                  | 첫 번째 요소 |
| Optional\<T><br>OptionalXXX | max(Comparator\<T>)<br>min() | 최대 요소    |
| Optional\<T><br>OptionalXXX | max(Comparator\<T>)<br>min() | 최소 요소    |
| OptionalDouble              | average()                    | 요소 평균    |
| int, long, double           | sum()                        | 요소 총합    |



```java
import java.util.Arrays;

public class AggregateExample {
	public static void main(String[] args) {
		long count = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.count(); // 개수
		System.out.println("2의 배수 개수: " + count);
		
		long sum = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.sum(); // 합
		System.out.println("2의 배수의 합: " + sum);
		
		double avg = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.average() // 평균
			.getAsDouble(); // 값 저장이 double
		System.out.println("2의 배수의 평균: " + avg);
		
		int max = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.max() // 최대
			.getAsInt(); // 값 저장이 int
		System.out.println("최대값: " + max);
		
		int min = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.min() // 최소
			.getAsInt();
		System.out.println("최소값: " + min);
		
		int first = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%3==0)
			.findFirst() // 첫 번째 값
			.getAsInt(); 
		System.out.println("첫번째 3의 배수: " + first);
	}
}
//
2의 배수 개수: 2
2의 배수의 합: 6
2의 배수의 평균: 3.0
최대값: 4
최소값: 2
첫번째 3의 배수: 3
```



### Optional 클래스

Optional클래스는 집계 값이 존재하지 않을 경우 디폴트 값을 설정할 수 있고, 집계 값을 처리하는 Consumer도 등록할 수 있다.

| 리턴 타입                  | 메소드(매개 변수)                                            | 설명                                        |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| boolean                    | isPresent()                                                  | 값이 저장되어 있는지 여부                   |
| T<br>double<br>int<br>long | orElse(T)<br>orElse(double)<br>orElse(int)<br>orElse(long)   | 값이 저장되어 있지 않을 경우 디폴트 값 지정 |
| void                       | ifPresent(Consumer)<br>ifPresent(DoubleConsumer)<br>ifPresent(IntConsumer)<br>ifPresent(LongConsumer) | 값이 저장되어 있을 경우 Consumer에서 처리   |



컬렉션에 요소가 없을 경우에는??

```java
List<Integer> list = new ArrayList<>();
double avg = list.stream()
    .mapToInt(Integer :: intvalue)
    .average()
    .getAsDouble();
System.out.println("평균: " + avg);
```

-> 평균값이 없다 (NoSuchElementException)



이런 예외를 피하기 위한 3가지 방법

1. Optional객체를 얻어 isPresent 메소드로 평균값 여부를 확인하는 것 -> isPresent가 true일때만 메소드로 평균값을 얻음

``` java
OptionalDouble optional = list.stream()
    .mapToInt(Intger :: intValue)
    .average();
if(optional.isPresent()){
    System.out.println("평균: " + optional.getAsDouble());
}else{
    System.out.println("평균: 0.0");
}
```

2. orElse 메소드로 디폴트 값을 정해놓는다. 평균값이 없을 때 디폴트값이 호출된다.

```java
double avg = list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .orElse(0.0);
System.out.println("평균: " + avg);
```

3. ifPresent 메소드로 평균값이 있을 경우에만 값을 이용하는 람다식을 실행한다.

```java
list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .ifPresent(a -> System.out.println("평균: " + a));
```



```java
import java.util.ArrayList;
import java.util.List;
import java.util.OptionalDouble;

public class OptionalExample {
	public static void main(String[] args) {
		List<Integer> list = new ArrayList<>();
		
		/*(java.util.NoSuchElementException)
		double avg = list.stream()
			.mapToInt(Integer :: intValue)
			.average()	
			.getAsDouble(); 
		*/

		OptionalDouble optional = list.stream()
			.mapToInt(Integer :: intValue)
			.average();	
		if(optional.isPresent()) {
			System.out.println("방법1_평균: " + optional.getAsDouble());
		} else {
			System.out.println("방법1_평균: 0.0");
		}

		double avg = list.stream()
			.mapToInt(Integer :: intValue)
			.average()
			.orElse(0.0);
		System.out.println("방법2_평균: " + avg);

		list.stream()
			.mapToInt(Integer :: intValue)
			.average()
			.ifPresent(a -> System.out.println("방법3_평균: " + a));
	}
}
//
방법1_평균: 0.0
방법2_평균: 0.0
```



## 16.10 커스텀 집계(reduce()) - 최종 처리

---

reduce : 프로그램화해서 다양한 집계 결과물을 만들 수 있도록함.

| 인터페이스   | 리턴 타입      | 메소드(매개 변수)                                  |
| ------------ | -------------- | -------------------------------------------------- |
| Stream       | Optional\<T>   | reduce(BinaryOperator\<T> accumulator)             |
| -            | T              | reduce(T identity, BinaryOperator\<T> accumulator) |
| IntStream    | OptionalInt    | reduce(IntBinaryOperator op)                       |
| -            | int            | reduce(int identity, IntBinaryOperator op)         |
| LongStream   | OptionalLong   | reduce(LongBinaryOperator op)                      |
| -            | long           | reduce(long identity, LongBinaryOperator op)       |
| DoubleStream | OptionalDouble | reduce(DoubleBinaryOperator op)                    |
| -            | double         | reduce(double identity, DoubleBinaryOperator op)   |

-> 각 타입에는 reduce 메소드가 오버로딩 되어있다.



```java
// 스트림에 요소가 없을 경우
int sum = studentList.stream() // NoSuchElementException
    .map(Student :: getScore)
    .reduce(a, b) -> a+b
    .get();
---
int sum = studentList.stream() // 디폴트 값인 0을 리턴
    .map(Student :: getScore)
    .reduce(0, (a, b) -> a+b)
```



```java
import java.util.Arrays;
import java.util.List;

public class ReductionExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 92),
				new Student("신용권", 95),
				new Student("김자바", 88)
		);
		
		int sum1 = studentList.stream()
				.mapToInt(Student :: getScore)
				.sum();
		
		int sum2 = studentList.stream()
				.map(Student :: getScore)
				.reduce((a, b) -> a+b)
				.get();
		
		int sum3 = studentList.stream()
				.map(Student :: getScore)
				.reduce(0, (a, b) -> a+b);
		
		System.out.println("sum1: " + sum1);
		System.out.println("sum2: " + sum2);
		System.out.println("sum3: " + sum3);
	}
}
//
sum1: 275
sum2: 275
sum3: 275
```

``` java
public class Student {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



## 16.11 수집(collect()) - 최종 처리

---

collect : 요소들을 필터링 또는 매핑한 후 요소들을 수집하는 메소드

-> 필요한 요소만 컬렉션에 담을 수 있다.

-> 요소들을 그룹핑한 후 집계할 수 있다.

### 필터링한 요소 수집

stream의 collect(Collector <T, A, R> collector) 메소드는 필터링 또는 매핑된 요소들을 새로운 컬렉션에 수집하고, 이 컬렉션을 리턴한다.

| 리턴 타입 | 메소드(매개 변수)                     | 인터페이스 |
| --------- | ------------------------------------- | ---------- |
| R         | collect(Collector<T, A, R> collector) | Stream     |

- T는 요소
- A는 누적기
- R은 요소가 저장될 컬렉션

=> T요소를 A 누적기가 R에 저장한다.



Collectors의 정적 메소드

| 리턴 타입                                | Collectors의 정적 메소드                                     | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Collector<T, ?, List\<T>>                | toList()                                                     | T를 List에 저장                                              |
| Collector<T, ?, Set\<T>>                 | toSet()                                                      | T를 Set에 저장                                               |
| Collector<T, ?, Collection\<T>>          | toCollection(<br>     Supplier<Collection\<T><br>)           | T를 Supplier가 제공한Collection에 저장                       |
| Collector<T, ?, Map<K, U>>               | toMap(<br>     Function<T, K> keyMapper,<br>     Function<T, U> valueMapper) | T와 K와 U로 매핑해서 K를 키로, U를 값으로 Map에 저장         |
| Collector<T, ?, <br>ConcurrentMap<K, U>> | toConcurrentMap(<br>     Function<T, K> keyMapper,<br>     Function<T, U> valueMapper) | T를 K와 U로 매핑해서 K를 키로, U를 값으로 ConcurrentMap에 저장 |

=> 누적기A가 ?로 되어있는 이유는 Collector가 R에 T요소를 저장하는 방법을 알고 있어 A가 필요없기 때문이다.

=> Map, ConcurrentMap은 스레드 안전의 차이이다.



- 남학생만 필터링해서 별도의 List를 생성하는 방법

```java
1. Stream<Student> totalStream = totalList.stream(); // 리스트에서 스트림을 얻는다.
2. Stream<Student> maleStream = totalStream.filter(s->s.getSex() == Student.Sex.MALE); // 남학생만 필터링해서 스트림을 얻는다.
3. Collection<Student, ?, List<Student>> collector = Collectors.toList(); // List에 Student를 수집하는 Collector를 얻는다.
4. List<Student> maleList = maleStream.collect(collector); // 스트림에서 collect메소드로 Student를 수정해서 새로운 List를 얻는다.
```

-> 변수를 생략하면

```java
List<Student> maleList = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(Collectors.toList());
```



- 여학생만 필터링해서 HashSet를 생성하는 방법

```java
1. Stream<Student> totalStream = totalList.stream();
2. Stream<Student> femaleStream = totalStream.filter(s->s.getSex()==Student.Sex.FEMALE);
3. Supplier<HashSet<Student>> supplier = HashSet :: new; // 새로운 HashSet을 공급하는 Supplier를 얻는다.
4. Collector<Student, ?, HashSet<Student>> collector = Collectors.toCollection(supplier);
5. Set<Student> femaleSet = femaleStream.collect(collect);
```

-> 변수를 생략하면

```java
Set<student> femaleSet = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.FEMALE)
    .collect(Collectors.toCollection(HashSet :: new));
```

```java
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ToListExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 6, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 6, Student.Sex.FEMALE)
		);

		List<Student> maleList = totalList.stream()
				.filter(s->s.getSex()==Student.Sex.MALE)
				.collect(Collectors.toList());
		maleList.stream()
			.forEach(s -> System.out.println(s.getName()));
		
		System.out.println();

		Set<Student> femaleSet = totalList.stream()
				.filter(s -> s.getSex() == Student.Sex.FEMALE)
				.collect( Collectors.toCollection(()->new HashSet<Student>()) );
		femaleSet.stream()
			.forEach(s -> System.out.println(s.getName()));
	}
}
//
홍길동
신용권

김수애
박수미
```

```java
public class Student {
	public enum Sex { MALE, FEMALE }
	public enum City { Seoul, Pusan }
	
	private String name;
	private int score;
	private Sex sex;
	private City city;
	
	public Student(String name, int score, Sex sex) {
		this.name = name;
		this.score = score;
		this.sex = sex;
	}	
	
	public Student(String name, int score, Sex sex, City city) {
		this.name = name;
		this.score = score;
		this.sex = sex;
		this.city = city;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
	public Sex getSex() { return sex; }
	public City getCity() { return city; }
}
```



### 사용자 정의 컨테이너에 수집하기

스트림은 요소들을 필터링, 또는 매핑해서 사용자 정의 컨테이너 객체에 수집할 수 있도록 다음과 같이 collect() 메소드를 추가적으로 제공한다.

| 인터페이스   | 리턴 타입 | 메소드(매개 변수)                                            |
| ------------ | --------- | ------------------------------------------------------------ |
| Stream       | R         | collect(Supplier\<R>, BiConsumer<R, ? super T>, BiConsumer<R, R>) |
| IntStrema    | R         | collect(Supplier\<R>, ObjIntConsumer\<R>, BiConsumer<R, R>)  |
| LongStream   | R         | collect(Supplier\<R>, ObjLongConsumer\<R>, BiConsumer<R, R>) |
| DoubleStream | R         | collect(Supplier\<R>, ObjDoubleConsumer\<R>, BiConsumer<R, R>) |

- 첫 번째 Supplier는 요소들이 수집될 컨테이너 객체를 생성하는 역할을 한다.
  - 싱글 스레드의 경우 한 번의 Supplier 실행되고 하나의 컨테이너 객체 생성
  - 멀티 스레드의 경우 여러번 Supplier 실행되고 여러 개의 컨테이너 객체 생성
  - 최종적으론 하나의 컨테이너 객체로 결합
- 두 번째 XXXConsumer는 컨테이너 객체R에 T를 수집하는 역할을 한다. 스트림에서 요소를 컨테이너에 수집할 때마다 Consumer이 실행된다.
- 세 번째 BiConsumer는 컨테이너 객체R를 결합하는 역할을 한다. 순차 처리 스트림에서는 호출되지 않고, 병렬 처리 스트림에서만 호출되어 스레드별로 생성된 컨테이너 객레를 결합해 최종 컨테이너 객체를 완성한다.



```java
import java.util.ArrayList;
import java.util.List;

public class MaleStudent  {
	private List<Student> list; // 요소를 저장할 컬렉션
	
	public MaleStudent() {
		list = new ArrayList<Student>();
		System.out.println("[" + Thread.currentThread().getName() + "] MaleStudent()"); // 생성자를 호출하는 스레드이름
	}
	
	public void accumulate(Student student) { // 요소를 수집하는 메소드
		list.add(student); 
		System.out.println("[" + Thread.currentThread().getName() + "] accumulate()");
	}
	
	public void combine(MaleStudent other) { // 두 MaleStudent를 결합하는 메소드
		list.addAll(other.getList());
		System.out.println("[" + Thread.currentThread().getName() + "] combine()");
	}
	
	public List<Student> getList() { // 요소가 저장된 컬렉션을 리턴
		return list;
	}
}
```



```java
1. Stream<Student> totlaStream = totlaList.stream(); // 전체 학생 list에서 스트림을 얻는다.
2. Stream<Student> maleStream = totalStream.filters(s->s.getSex()==Student.Sex.MALE); // 남학생만 필터링해서 스트림을 얻는다.
3. Supplier<MaleStudent> supplier = ()->new MaleStudent(); // MaleStudent를 공흡하는 Supplier를 얻는다.
4. BiConsumer<MaleStudent, Student> accumulator = (ms, s)->ms.accumulate(s); // MaleStudent와 Student를 매개값으로 받아서 MaleStudent의 accumulate() 메소드로 Student를 수집하는 BiConsumer를 얻는다.
5. BiConsumer<MaleStudent, MaleStudent> combiner = (ms1, ms2)->ms1.combine(ms2); // 두 개의 MaleStudent를 매개값으로 받아 combine() 메소드로 결합하는 BiConsumer를 얻는다.
6. MaleStudent maleStudent = maleStream.collect(supplier, accumulator, combiner); // supplier가 제공하는 MaleStudent에 accumulator가 Student를 수집해 최종 처리된 MaleStudent를 얻는다.
```

-> 변수를 생략하면

```java
MaleStudent maleStudent = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(
		()->new MaleStudent(),
		(r, t)->r.accumulate(t),
		(r1, r2)->r1.combine(r2)
);
```

-> 메소드 참조로 변경하면

```java
MaleStudent maleStudent = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
```



```java
import java.util.Arrays;
import java.util.List;

public class MaleStudentExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 6, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 6, Student.Sex.FEMALE)
		);
		
		MaleStudent maleStudent = totalList.stream()
				.filter(s -> s.getSex() == Student.Sex.MALE)
				//.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine); 
				.collect(()->new MaleStudent(), (r, t)->r.accumulate(t), (r1, r2)->r1.combine(r2));
		
		maleStudent.getList().stream()
			.forEach(s -> System.out.println(s.getName()));
	}
}
//
[main] MaleStudent()
[main] accumulate()
[main] accumulate()
홍길동
신용권
```



### 요소를 그룹핑해서 수집

요소들을 그룹핑해서 Map객체를 생성하는 기능

-> collect를 호출할 때 Collectors의 groupingBy() 또는 groupingByConcurrent가 리턴하는 Collector를 매개값으로 대입하면 된다.

| 리턴 타입                                    | Collectors의 정적 메소드                                     | 설명                                                         |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Collector<T,?,Map<K,List\<T>>>               | groupingBy(Function<T,K> classifier)                         | T를 K로 매핑하고 K키에 저장된 List에 T를 저장한 Map생성      |
| Collector<T,?,<br>ConcurrentMap<K,List\<T>>> | groupingByConcurrent(<br>     Function<T,K> classifier)      | -                                                            |
| Collector<T,?,Map<K,D>>                      | groupingBy(<br>     Function<T,K> classifier,<br>     Collector<T, A, D> collector) | T를 K로 매핑하고 K키에 저장된 D객체에 T를 누적한 Map 생성    |
| Collector<T,?,<br>ConcurrentMap<K,D>>        | groupingByConcurrent(<br>     Function<T,K> classifier,<br>     Collector<T, A, D> collector) | -                                                            |
| Collector<T,?,Map<K,D>>                      | groupingBy(<br>     Fuction<T,K> classifier,<br>     Supplier<Map<K,D>> mapFactory,<br>     Collector<T, A, D> collector) | T를 K로 매핑하고 Supplier가 제공하는 Map에서 K키에 저장된 D객체에 T를 누적 |
| Collector<T,?,<br>ConcurrentMap<K,D>>        | groupingByConcurrent(<br>     Function<T,K> classifier,<br>     Supplier<ConcurrentMap<K,D>><br>     mapFactory,<br>     Collector<T, A, D> collector) | -                                                            |



성별로 그룹핑하고, 같은 그룹에 속하는 학생 List를 생성한 후, 성별을 키로, 학생 List를 값으로 갖는 Map

```java
1. Stream<Student> totalStream = totalList.stream(); // 전체학생 list에서 스트림을 얻는다.
2. Function<Student, Student.Sex> classifier = Student :: getSex; // Student를 Student.Sex로 매핑하는 Function을 얻는다.
3. Collector<Student, ?, Map<Student.Sex, List<Student>>> collector = Collectors.groupingBy(classifier); // Student.Sex가 키가 됙, 그룹핑된 List가 값인 Map을 생성하는 Collector를 얻는다.
4. Map<Student.Sex, List<Student>> mapBySex = totalStream.collect(collector); // 스트림의 collect메소드로 Student를 Student.Sex별로 그룹핑해서 Map을 얻는다.
```

-> 변수를 생략하면

```java
Map<Student.Sex, List<Student>> mapBySex = totalList.stream()
    .collect(Collectors.groupingBy(Student :: getSex));
```



거주 도시 별로 그룹핑하고, 같은 그룹에 속하는 학생들의 이름을 list로 생성, 거주도시를 키, 이름을 list로 갖는 Map

```java
1. Stream<Student> totalStream = totalList.stream(); // 전체 list에서 스트림을 얻는다.
2. Function<Student, Student.City> classifier = Student::getCity; // Student를 Student.City로 매핑하는 Function을 얻는다.
3. Function<Student, String> mapper = Student::getName; // Student의 이름으로 매핑하는 Function을 얻는다.
4. Collector<String, ?, List<String>> collector1 = Collectors.toList(); // 이름을 list에 수집하는 Collector를 얻는다.
5. Collector<Student, ?, List<String>> collector2 = Collectors.mapping(mapper, collector); // Collectors의 mapping 메소드로 Student를 이름으로 매핑하고 이름을 list에 수집하는 Collector를 얻는다.
6. Collector<Student, ?, Map<Student.City, List<String>>> collector3 = Collectors.groupingBy(classifier, collector2); // Student.City가 키이고, 그룹핑된 이름 list가 값인 Map을 생성하는 Collector을 얻는다.
7. Map<Student.City, List<String>> mapByCity = totalStream.collect(collector3); // 스트림의 collect메소드로 Student를 Student.City별로 그룹핑해서 Map을 얻는다.
```

-> 변수를 생략하면

```java
Map<Student.City, List<String>> mapByCity = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getCity,
        	Collectors.mapping(Student::getName, Collectors.toList())
        )
)
```

-> TreeMap으로 생성하면

```java
Map<Student.City, List<String>> mapByCity = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getCity,
        	TreeMap::new,
        	Collectors.mapping(Student::getNAme, Collectors.toList())
        )
)
```

```java
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class GroupingByExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE, Student.City.Seoul),
				new Student("김수애", 6, Student.Sex.FEMALE, Student.City.Pusan),
				new Student("신용권", 10, Student.Sex.MALE, Student.City.Pusan),
				new Student("박수미", 6, Student.Sex.FEMALE, Student.City.Seoul)
		);
		
		Map<Student.Sex, List<Student>> mapBySex = totalList.stream()
				.collect(Collectors.groupingBy(Student :: getSex));
		System.out.print("[남학생] ");
		mapBySex.get(Student.Sex.MALE).stream().forEach(s->System.out.print(s.getName() + " "));
		System.out.print("\n[여학생] ");
		mapBySex.get(Student.Sex.FEMALE).stream().forEach(s->System.out.print(s.getName() + " "));
		
		System.out.println();
		
		Map<Student.City, List<String>> mapByCity = totalList.stream()
				.collect(
						Collectors.groupingBy(
								Student::getCity, 
								Collectors.mapping(Student::getName, Collectors.toList())
						)
				); 
		System.out.print("\n[서울] ");
		mapByCity.get(Student.City.Seoul).stream().forEach(s->System.out.print(s + " "));
		System.out.print("\n[부산] ");
		mapByCity.get(Student.City.Pusan).stream().forEach(s->System.out.print(s + " "));	
	}
}
//
[남학생] 홍길동 신용권 
[여학생] 김수애 박수미 

[서울] 홍길동 박수미 
[부산] 김수애 신용권
```



### 그룹핑 후 매핑 및 집계

Collectors.groupingBy() 메소드는 그룹핑 후, 매핑이나 집계를 할 수 있도록 두 번째 매개값으로 Collector를 가질 수 있다.

| 리턴 타입                        | 메소드(매개 변수)                                            | 설명                                                    |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| Collector<T, ?, R>               | mapping(<br>     Function<T, U> mapper,<br>     Collector<U, A, R> collector) | T를 U로 매핑한 후 , U를 R에 수집                        |
| Collector<T, ?, Double>          | averagingDouble(<br>     ToDoubleFunction\<T> mapper)        | T를 Double로 매핑한 후. Double의 평균값을 산출          |
| Collector<T, ?, Long>            | counting()                                                   | T의 카운팅 수를 산출                                    |
| Collector<CharSequence,?.String> | joining(CharSequence delimiter)                              | CharSequence를 구분자(delimiter)로 연결한 String을 산출 |
| Collector<T,?,Optional\<T>>      | maxBy(<br/>     Comparator\<T> comparator)                   | Comparator를 이용해서 최대 T를 산출                     |
| Collector<T,?,Optional\<T>>      | minBy(<br/>     Comparaotr\<T> comparator)                   | Comparator를 이용해서 최소 T를 산출                     |
| Collector<T,?,Integer>           | summingInt(ToIntFunction)<br>summingLong(ToLongFunction)<br>summingDouble(ToDoubleFunction) | Int, Long, Double타입의 합계 산출                       |



학생들을 성별로 그룹핑한 다음 같은 그룹에 속하는 학생들의 평균 점수를 구하고, 성별을 키로, 평균 점수를 값으로 갖는 Map을 생서한다.

```java
1. Stream<Student> totalStream = totalList.stream(); // 전체 학생 list에서 Stream을 얻는다.
2. Function<Student, Student.Sex> classifier = Student :: getSex; // Student를 Student.Sex로 매핑하는 Function을 얻는다.
3. ToDoubleFunction<Student> mapper = Student :: getScore; // Student를 점수로 매핑하는 ToDoubleFunction을 얻는다.
4. Collector<Student, ?, Double> collector1 = Collectors.averagingDouble(mapper); // 학생 점수의 평균을 산출하는 Collector을 얻는다.
5. Collector<Student, ?, Map<Student.Sex, Double>> collector2 = Collectors.groupingBy(classifier, collector1); // Student.Sex가 키이고, 평균 점수 Double이 값인 Map을 생성하는 Collector을 얻는다.
6. Map<Student.Sex, Double> mapBySex = totalStream.collect(collector2); // Stream의 collect() 메소드로 Student를 Student.SEx별로 그룹핑해서 Map을 얻는다.
```

-> 변수를 생략하면

```java
Map<Student.Sex, Double> mapBySex = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getSex,
        	Collectors.averagingDouble(Student::getScore)
        )
	);
```

-> 같은 그룹에 속하는 학생 이름을 쉼표로 구분해서 문자열로 만든다.

```java
Map<Student.Sex, String> mapByName = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getSex,
        	Collectors.mapping
        	Student::getName,
        	Collectors.joining(",")
        )
	);
```

```java
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class GroupingAndReductionExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 12, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 12, Student.Sex.FEMALE)
		);
		
		Map<Student.Sex, Double> mapBySex = totalList.stream()
				.collect(
					Collectors.groupingBy(
						Student :: getSex, 
						Collectors.averagingDouble(Student :: getScore)
					)
				);
		
		System.out.println("남학생 평균 점수: " + mapBySex.get(Student.Sex.MALE));
		System.out.println("여학생 평균 점수: " + mapBySex.get(Student.Sex.FEMALE));

		Map<Student.Sex, String> mapByName = totalList.stream()
				.collect(
					Collectors.groupingBy(
						Student :: getSex, 
						Collectors.mapping(
							Student :: getName,
							Collectors.joining(",")
						)
					)
				);
		System.out.println("남학생 전체 이름:" + mapByName.get(Student.Sex.MALE));
		System.out.println("여학생 전체 이름: " + mapByName.get(Student.Sex.FEMALE));
	}
}
//
남학생 평균 점수: 10.0
여학생 평균 점수: 12.0
남학생 전체 이름:홍길동,신용권
여학생 전체 이름: 김수애,박수미
```



## 16.12 병렬 처리

---

벙럴 처리 : 멀티 코어 CPU 환경에서 하나의 작업을 분할해서 각각의 코어가 병렬적으로 처리하는 것.

### 동시성(Concurrency)과 병렬성(Parallelism)

동시성 : 멀티 작업을 위해 멀티 스레드가 번갈아가며 실행하는 성질

병렬성 : 멀티 작업을 위해 멀티 코어를 이용해서 동시에 실행하는 성질

![다운로드 (1)](C:\Users\user\Downloads\다운로드 (1).png)

#### 데이터 병렬성

- 전체 데이터를 쪼개어 서브 데이터들로 만들고 이 서브 데이터들을 병렬 처리해서 작업을 빨리 끝내는 것.
- 예로 쿼드 코어의 경우 4개의 서브 요소들로 나누고, 4개의 스레드가 각각ㄱ의 서브 요소들을 병렬처리한다.



#### 작업 병렬성

- 서로 다른 작업을 병렬 처리하는 것.
- 예로 웹 서버가 있다. 각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리한다.



### 포코조인(ForkJoin) 프레임워크

병렬 스트림을 이용하면 런타임 시에 포크조인 프레임워크가 동작한다.

1. 포크 단계에서는 전체 데이터를 서브 데이터로 분리한다.
2. 서브 데이터를 멀티 코어에서 병렬로 처리한다.
3. 조인 단계에서는 서브 결과를 결합해서 최종 결과를 만들어 낸다.

![fork_join](C:\Users\user\Downloads\fork_join.png)

(-> 실제론 위 처럼 나누진 않는다.)

-> 각각의 코어에서 서브 요소를 처리하는 것은 개별 스레드가 하므로 스레드 관리가 필요하다.

따라서 ExecutorService의 구현 객체인 ForkJoinPool을 사용해서 작업 스레드를 관리한다.



### 병렬 스트림 생성

병렬 스트림은 다음 두가지 메소드로 얻을 수 있다.

| 인터페이스                                                   | 리턴 타입                                         | 메소드(매개 변수) |
| ------------------------------------------------------------ | ------------------------------------------------- | ----------------- |
| java.util.Collection                                         | Stream                                            | parallelStream()  |
| java.util.Stream.Stream<br>java.util.Stream.IntStream<br>java.util.Stream.LongStream<br>java.util.Stream.DoubleStream | Stream<br>IntStream<br>LongStream<br>DoubleStream | parallel()        |

parallelStream : 컬렉션으로부터 병렬 스트림을 바로 리턴한다.

parrel : 순차 처리 스트림을 병렬 처리 스트림으로 변환해서 리턴한다.

=> 어떤 방법으로 병렬 스트림을 얻더라도 이후 요소 처리 과정은 병렬 처리된다.

- 내부적으로 전체 요소를 서브 요소들로 나누고, 이 요소들을 개별 스레드가 처리한다.

- 서브 처리 결과가 나오면 결합해서 마지막으로 최종 처리 결과를 리턴한다!!



```java
MaleStudent maleStudent = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine)
```

-> 병렬 처리 스트림으로 변경

```java
MaleStudent maleStudent = totalList.parallelStream() 
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
```

- 쿼드 코어 CPU에서 실행된다면 전체 요소는 4개의 서브 요소로 나눠지고, 4개의 스레드가 병렬처리한다. 각 스레드는 서브 요소를 수집해야 하므로 4개의 MaleStudent 객체를 생성하기 위해 collect()의 첫 번째 메소드 참조인 MaleStudent :: new를 4번 실행시킨다.
- 각 스레드는 MaleStudent 객체에 남학생 요소를 수집하기 위해 두 번째 메소드 참조인 MaleStudent :: accumulate를 매번 실행시킨다.
- 수집이 완료된 4개의 MaleStudent는 3번의 결합으로 최종 MaleStudent가 만들어질 수 있으므로 세 번째 메소드 참조인 MaleStudent::combine이 3번 실행된다.



```java
import java.util.Arrays;
import java.util.List;

public class MaleStudentExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 10, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 10, Student.Sex.FEMALE)
		);
		
		MaleStudent maleStudent = totalList.parallelStream()
				.filter(s -> s.getSex() == Student.Sex.MALE)
				.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine); 
		
		maleStudent.getList().stream()
			.forEach(s -> System.out.println(s.getName()));
	}
}
//
[main] MaleStudent()
[ForkJoinPool.commonPool-worker-1] MaleStudent()
[ForkJoinPool.commonPool-worker-2] MaleStudent()
[ForkJoinPool.commonPool-worker-3] MaleStudent()
[main] accumulate()
[ForkJoinPool.commonPool-worker-3] accumulate()
[main] combine()
[ForkJoinPool.commonPool-worker-3] combine()
[ForkJoinPool.commonPool-worker-3] combine()
홍길동
신용권
```

-> 총 4개의 스레드가 동작한다.

- 4개의 서브 작업으로 분리되었다.
- 남학생이 2명이라 accumulate는 2번 실행되었다.
- 3번의 결합으로 최종 MaleStudent가 만들어지므로 combine이 3번 호출되었다.



### 병렬 처리 성능

병렬 처리와 순차 처리의 성능 비교

#### 요소의 수와 요소당 처리 시간

- 요소의 수가 적고 요소당 처리 시간이 짧으면 순차처리가 오히려 병렬 처리보다 빠를 수 있다.
- 병렬 처리는 스레드풀 생성, 스레드 생성이라는 추가적인 비용이 발생하기 때문이다.



#### 스트림 소스의 종류

- ArrayList, 배열은 인덱스로 요소를 관리하기 때문에 요소를 쉽게 분리할 수 있으나,
- HashSet, TreeSet은 요소 분리가 쉽지 않고, LinkedList는 링크를 따라가야해 요소 분리가 쉽지 않아 병렬 처리가 늦다.



#### 코어의 수

- 싱글 코어의 경우 순차 처리가 빠르다 -> 병렬 스트림을 사용하면 스레드 수만 증가하지 동시성 작업이기 때문에 좋지않다.
- 코어가 많으면 많을 수록 병렬 작업 처리 속도는 빨라진다.



work메소드의 실행 시간을 조정해 순차 처리와 병렬 처리 속도 비교

```java
import java.util.Arrays;
import java.util.List;

public class SequencialVsParallelExample {
	public static void work(int value) {
		try { Thread.sleep(100); } catch (InterruptedException e) {}
	}
	
	public static long testSequencial(List<Integer> list) {
		long start = System.nanoTime();
		list.stream().forEach((a) -> work(a));
		long end = System.nanoTime();
	    long runTime = end - start;
	    return runTime;
	}
	
	public static long testParallel(List<Integer> list) {
		long start = System.nanoTime();
		list.stream().parallel().forEach((a)-> work(a));
		long end = System.nanoTime();
	    long runTime = end - start;
	    return runTime;
	}
	
	public static void main(String... args) {
		List<Integer> list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
		
		long Sequencial = testSequencial(list);
		
		long timeParallel = testParallel(list);
		
		if(Sequencial < timeParallel) {
			System.out.println("성능 테스트 결과: 순차 처리가 더 빠름");
		} else {
			System.out.println("성능 테스트 결과: 병렬 처리가 더 빠름");
		}
	}
}
//
성능 테스트 결과: 병렬 처리가 더 빠름
```

-> sleep을 10으로 하면 순차 처리가 더 빠르다



ArrayList와 LinkedList의 병렬 처리 성능 테스트

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ArrayListVsLinkedListExample {
	public static void work(int value) {
	}

	public static long testParallel(List<Integer> list) {
		long start = System.nanoTime();
		list.stream().parallel().forEach((a)-> work(a));
		long end = System.nanoTime();
	    long runTime = end - start;
	    return runTime;
	}
	
	public static void main(String... args) {
		List<Integer> arrayList = new ArrayList<Integer>();
		List<Integer> linkedList = new LinkedList<Integer>();
		for(int i=0; i<1000000; i++) {
			arrayList.add(i);
			linkedList.add(i);
		}

		long arrayListListParallel = testParallel(arrayList);
		long linkedListParallel = testParallel(linkedList);

		arrayListListParallel = testParallel(arrayList);
		linkedListParallel = testParallel(linkedList);
		
		if(arrayListListParallel < linkedListParallel) {
			System.out.println("성능 테스트 결과: ArrayList 처리가 더빠름");
		} else {
			System.out.println("성능 테스트 결과: LinkedList 처리가 더빠름");
		}
	}
}
//
성능 테스트 결과: ArrayList 처리가 더빠름
```

-> 요소의 개수가 적으면 LinkedList가 더 빠르다.