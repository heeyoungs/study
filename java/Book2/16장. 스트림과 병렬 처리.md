# 16장. 스트림과 병렬 처리

---



## 16.1 스트림 소개

---



### 반복자 스트림



```java
List<String> list = Arrays.asList("홍길동","신용권","김자바");
Iterator<String> iterator = list.iterator();
while(iterator.hasNext()){
    String name = iterator.next();
    System.out.println(name);
}
```



```java
List<String> list = Arrays.asList("홍길동","신용권","김자바");
Stream<String> stream = list.stream();
stream.forEach( name -> System.out.println(name));
```



```java
void forEach(Consumer<T> action)
```



```java
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Stream;

public class IteratorVsStreamExample {
	public static void main(String[] args) {
		List<String> list = Arrays.asList("홍길동", "신용권", "김자바");

		Iterator<String> iterator = list.iterator();
		while(iterator.hasNext()) {
			String name = iterator.next();
			System.out.println(name);
		}
		
		System.out.println();

		Stream<String> stream = list.stream();
		stream.forEach( name -> System.out.println(name) );
	}
}
//
홍길동
신용권
김자바

홍길동
신용권
김자바
```



### 스트림의 특징



#### 람다식으로 요소 처리 코드를 제공한다.



```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class LambdaExpressionsExample {
	public static void main(String[] args) {
		List<Student> list = Arrays.asList(
				new Student("홍길동", 90),
				new Student("신용권", 92)
		);
		
		Stream<Student> stream = list.stream();
		stream.forEach(s -> {
			String name = s.getName();
			int score = s.getScore();
			System.out.println(name + "-" + score);
		});
	}
}
//
홍길동-90
신용권-92
```

```java
public class Student {
	private String name;
	private int score;
	
	public Student (String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



#### 내부 반복자를 사용하므로 병렬 처리가 쉽다.



```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class ParallelExample {	
	public static void main(String[] args) {
		List<String> list = Arrays.asList("홍길동", "신용권", "김자바", "람다식", "박병렬");

		Stream<String> stream = list.stream();
		stream.forEach(ParallelExample :: print);
		
		System.out.println();

		Stream<String> parallelStream = list.parallelStream();
		parallelStream.forEach(ParallelExample :: print);
	}
	
	public static void print(String str) {
		System.out.println(str+ " : " + Thread.currentThread().getName());
	}	
}
//
홍길동 : main
신용권 : main
김자바 : main
람다식 : main
박병렬 : main

김자바 : main
람다식 : ForkJoinPool.commonPool-worker-2
홍길동 : ForkJoinPool.commonPool-worker-2
신용권 : ForkJoinPool.commonPool-worker-1
박병렬 : main
```



#### 스트림은 중간 처리와 최종 처리를 할 수 있다.



```java
import java.util.Arrays;
import java.util.List;

public class MapAndReduceExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 10),
				new Student("신용권", 20),
				new Student("유미선", 30)
		);		
			
		double avg = studentList.stream()
			.mapToInt(Student :: getScore)
			.average()
			.getAsDouble();
		
		System.out.println("평균 점수: " + avg);
	}
}
//
평균 점수: 20.0
```



## 16.2 스트림의 종류

---



| 리턴 타입                                             | 메소드(매개 변수)                                            | 소스      |
| ----------------------------------------------------- | ------------------------------------------------------------ | --------- |
| Stream\<T>                                            | java.util.Collection.stream()<br>java.util.Collection.parrelStream() | 컬렉션    |
| Stream\<T><br>IntStream<br>LongStream<br>DoubleStream | Arrays.stream(T[]),           Stream.of(T[])<br>Arrays.stream(int[]),        IntStream.of(int[])<br>Arrays.stream(long[]),      LongStream.of(long[])<br>Arrays.stream(double[]), DoubleStream.of(double[]) | 배열      |
| IntStream                                             | IntStream.range(int, int)<br>IntStream.rangeClosed(int, int) | int 범위  |
| LongStream                                            | LongStream.range(long, long)<br>LongStream.rangeClosed(long, long) | long 범위 |
| Stream\<Path>                                         | Files.find(Path, int, BiPredicate, FileVisitOption)<br>Files.list(Path) | 디렉토리  |
| Stream\<String>                                       | Files.lines(Path. Charset)<br>BufferdReader.lines()          | 파일      |
| DoubleStream<br>IntStream<br>LongStream               | Random.doubles(...)<br>Random.ints()<br>Random.longs()       | 랜덤 수   |



### 컬렉션으로부터 스트림 얻기



```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class FromCollectionExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
			new Student("홍길동", 10),
			new Student("신용권", 20),
			new Student("유미선", 30)
		);
		
		Stream<Student> stream = studentList.stream();
		stream.forEach(s -> System.out.println(s.getName()));
	}
}
```

```java
public class Student {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



### 배열로부터 스트림 얻기



```java
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class FromArrayExample {
	public static void main(String[] args) {
		String[] strArray = { "홍길동", "신용권", "김미나"};
		Stream<String> strStream = Arrays.stream(strArray);
		strStream.forEach(a -> System.out.print(a + ","));
		System.out.println();
		
		int[] intArray = { 1, 2, 3, 4, 5 };
		IntStream intStream = Arrays.stream(intArray);
		intStream.forEach(a -> System.out.print(a + ","));
		System.out.println();
	}
}
//
홍길동,신용권,김미나,
1,2,3,4,5,
```



### 숫자 범위로부터 스트림 얻기



``` java
import java.util.stream.IntStream;

public class FromIntRangeExample {
	public static int sum;
	
	public static void main(String[] args) {
		IntStream stream = IntStream.rangeClosed(1,  100);
		stream.forEach(a -> sum += a);
		System.out.println("총합: " + sum);
	}
}
//
총합: 5050
```



### 파일로부터 스트림 얻기



```java
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class FromFileContentExample {
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("");
		Stream<String> stream;
		
		stream = Files.lines(path, Charset.defaultCharset());
		stream.forEach( System.out :: println );
		stream.close();
		System.out.println();
		
		File file = path.toFile();
		FileReader fileReader = new FileReader(file);
		BufferedReader br = new BufferedReader(fileReader);
		stream = br.lines();
		stream.forEach( System.out :: println );
		stream.close();
	}
}
//
```



### 디렉토리로부터 스트림 얻기



```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class FromDirectoryExample {
	public static void main(String[] args) throws IOException {
		Path path = Paths.get("");
		Stream<Path> stream = Files.list(path);
		stream.forEach( p -> System.out.println(p.getFileName()) );
	}
}
//
```



## 16.3 스트림 파이프라인

---



### 중간 처리와 최종 처리



```java
Stream<Member> maleFemaleStream = list.stream();
Stream<Member> maleStream = maleFemaleStream.filter(m -> m.getSex() == Member.MALE);
IntStream ageStream = maleStream.mapToInt(Member::getAge);
OptionalDouble optionalDouble = ageStream.average();
double ageAvg = optionalDouble.getASDouble();
```



```java
double ageAvg = list.stream()
    .filter(m->m.getSex() == Member.MALE)
    .mapToInt(Member :: getAge)
    .average()
    .getAsDouble();
```



```java
import java.util.Arrays;
import java.util.List;

public class StreamPipelinesExample {
	public static void main(String[] args) {
		List<Member> list = Arrays.asList(
				new Member("홍길동", Member.MALE, 30),
				new Member("김나리", Member.FEMALE, 20),
				new Member("신용권", Member.MALE, 45),
				new Member("박수미", Member.FEMALE, 27)
		);
		
		double ageAvg =   list.stream()
			.filter(m -> m.getSex()==Member.MALE)
			.mapToInt(Member :: getAge)
			.average()
			.getAsDouble();
		
		System.out.println("남자 평균 나이: " + ageAvg);
	}
}
//
남자 평균 나이: 37.5
```

```java
public class Member {
	public static int MALE = 0;
	public static int FEMALE = 1;
	
	private String name;
	private int sex;
	private int age;
	
	public Member(String name, int sex, int age) {
		this.name = name;
		this.sex = sex;
		this.age = age;
	}

	public int getSex() { return sex; }
	public int getAge() { return age; }
}
```



### 중간 처리 메소드와 최종 처리 메소드



| 종류      |        | 리턴 타입                                         | 메소드(매개 변수)    | 소속된 인터페이스                   |
| --------- | ------ | ------------------------------------------------- | -------------------- | ----------------------------------- |
| 중간처리  | 필터링 | Stream<br>IntStream<br>LongStream<br>DoubleStream | distinct()           | 공통                                |
|           | -      |                                                   | filter(...)          | 공통                                |
|           | 매핑   |                                                   | flatMap(...)         | 공통                                |
|           | -      |                                                   | flatMapToDouble(...) | Stream                              |
|           | -      |                                                   | flatMaptToInt(...)   | Stream                              |
|           | -      |                                                   | flatMapToLong(...)   | Stream                              |
|           | -      |                                                   | map(...)             | 공통                                |
|           | -      |                                                   | mapToDouble(...)     | Stream, IntStream, LongStream       |
|           | -      |                                                   | mapToInt(...)        | Stream, LongStream, DoubleStream    |
|           | -      |                                                   | mapToLong(...)       | Stream, IntStream, DoubleStream     |
|           | -      |                                                   | mapToObj(...)        | IntStream, LongStream, DoubleStream |
|           | -      |                                                   | asDoubleStream()     | IntStream, LongStream               |
|           | -      |                                                   | asLongStream()       | IntStream                           |
|           | -      |                                                   | boxed()              | IntStream, LongStream, DoubleStream |
|           | 정렬   |                                                   | sorted(...)          | 공통                                |
|           | 루핑   |                                                   | peek(...)            | 공통                                |
| 최종 처리 | 매칭   | boolean                                           | allMatch(...)        | 공통                                |
|           | -      | boolean                                           | anyMatch(...)        | 공통                                |
|           | -      | boolean                                           | nonoMatch(...)       | 공통                                |
|           | 집계   | long                                              | count()              | 공통                                |
|           | -      | OptionalXXX                                       | findFirst()          | 공통                                |
|           | -      | OptionalXXX                                       | max(...)             | 공통                                |
|           | -      | OptionalXXX                                       | min(...)             | 공통                                |
|           | -      | OptionalDouble                                    | average()            | IntStream, LongStream, DoubleStream |
|           | -      | OptionalXXX                                       | reduce(...)          | 공통                                |
|           | -      | int, long, double                                 | sum()                | IntStream, LongStream, DoubleStream |
|           | 루핑   | void                                              | forEach(...)         | 공통                                |
|           | 수집   | R                                                 | collect(...)         | 공통                                |



## 16.4 필터링(distinct(), filter())

---



| 리턴 타입                                         | 메소드(매개 변수)       | 설명        |
| ------------------------------------------------- | ----------------------- | ----------- |
| Stream<br>IntStream<br>LongStream<br>DoubleStream | distinct()              | 중복 제거   |
| -                                                 | filter(Predicate)       | 조건 필터링 |
| -                                                 | filter(IntPredicate)    | -           |
| -                                                 | filter(LongPredicate)   | -           |
| -                                                 | filter(DoublePredicate) | -           |



```java
import java.util.Arrays;
import java.util.List;

public class FilteringExample {
	public static void main(String[] args) {
		List<String> names = Arrays.asList("홍길동", "신용권", "김자바", "신용권", "신민철");
		
		names.stream()
			.distinct()
			.forEach(n -> System.out.println(n));
		System.out.println();
		
		names.stream()
			.filter(n -> n.startsWith("신"))
			.forEach(n -> System.out.println(n));
		System.out.println();
		
		names.stream()
			.distinct()
			.filter(n -> n.startsWith("신"))
			.forEach(n -> System.out.println(n));		
	}
}
//
홍길동
신용권
김자바
신민철

신용권
신용권
신민철

신용권
신민철
```



## 16.5 매핑(flatMapXXX(), mapXXX(), asXXXStream(), boxed())

---



### flatMapXXX() 메소드



| 리턴 타입    | 메소드(매개 변수)                          | 요소 -> 대체 요소      |
| ------------ | ------------------------------------------ | ---------------------- |
| Stream\<R>   | flatMap(Function<T, Stream< R>>)           | T -> Stream\<R>        |
| DoubleStream | flatMap(DoubleFunction\<DoubleStream>)     | double -> DoubleStream |
| IntStream    | flatMap(IntFunction\<IntStream>)           | int -> IntStream       |
| LongStream   | flatMap(LongFunction\<LongStream>)         | long -> LongStream     |
| DoubleStream | flatMapToDouble(Function<T, DoubleStream>) | T -> DoubleStream      |
| IntStream    | flatMapToInt(Function<T, IntStream>)       | T -> IntStream         |
| LongStream   | flatMapToLong(Function<T, LongStream>)     | T -> LongStream        |



```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

public class FlatMapExample {
	public static void main(String[] args) {
		List<String> inputList1 = Arrays.asList("java8 lambda", "stream mapping");
		inputList1.stream()
			.flatMap(data -> Arrays.stream(data.split(" ")))
			.forEach(word -> System.out.println(word));
		
		System.out.println();
		
		List<String> inputList2 = Arrays.asList("10, 20, 30", "40, 50, 60");
		inputList2.stream()
			.flatMapToInt(data -> {
				String[] strArr = data.split(",");
				int[] intArr = new int[strArr.length];
				for(int i=0; i<strArr.length; i++) {
					intArr[i] = Integer.parseInt(strArr[i].trim());
				}
				return Arrays.stream(intArr);
			})
			.forEach(number -> System.out.println(number));
	}
}
//
java8
lambda
stream
mapping

10
20
30
40
50
60
```



### mapXXX() 메소드



| 리턴 타입    | 메소드(매개 변수)                 | 요소 -> 대체 요소 |
| ------------ | --------------------------------- | ----------------- |
| Stream\<R>   | map(Function<T, R>)               | T -> R            |
| DoubleStream | mapToDouble(ToDoubleFunction\<T>) | T -> double       |
| IntStream    | mapToInt(ToIntFunction\<T>)       | T -> int          |
| LongStream   | mapToLong(ToLongFunction\<T>)     | T -> long         |
| DoubleStream | map(DoubleUnaryOperator)          | double -> double  |
| IntStream    | mapToInt(DoubleToIntFunction)     | double -> int     |
| LongStream   | mapToLong(DoubleToLongFunction)   | double -> long    |
| Stream\<U>   | mapToObj(DoubleFunction\<U>)      | double -> U       |
| IntStream    | map(IntUnaryOperator)             | int -> int        |
| DoubleStream | mapToDouble(IntToDoubleFunction)  | int -> double     |
| LongStream   | mapToLong(IntToLongFunction)      | int -> long       |
| Stream\<U>   | mapToObj(IntFunction\<U>)         | int -> U          |
| LongStream   | map(LongUnaryOperator)            | long -> long      |
| DoubleStream | mapToDouble(LongToDoubleFunction) | long -> double    |
| IntStream    | mapToInt(LongToIntFunction)       | long -> int       |
| Stream\<U>   | mapToObj(LongFunction\<U>)        | long -> U         |



```java
import java.util.Arrays;
import java.util.List;

public class MapExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 10),
				new Student("신용권", 20),
				new Student("유미선", 30)
		);
			
		studentList.stream()
			.mapToInt(Student :: getScore)
			.forEach(score -> System.out.println(score));
	}
}
//
10
20
30
```

```java
public class Student {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



### asDoubleStream(), asLongStream(), boxed() 메소드



| 리턴 타입                                            | 메소드(매개 변수) | 설명                                               |
| ---------------------------------------------------- | ----------------- | -------------------------------------------------- |
| DoubleStream                                         | asDoubleStream()  | int -> double<br>long -> double                    |
| LongStream                                           | asLongStream()    | int -> long                                        |
| Stream\<Integer><br>Stream\<Long><br>Stream\<Double> | boxed()           | int -> Integer<br>long -> Long<br>double -> Double |



```java
import java.util.Arrays;
import java.util.stream.IntStream;

public class AsDoubleStreamAndBoxedExample {
	public static void main(String[] args) {
		int[] intArray = { 1, 2, 3, 4, 5};
		
		IntStream intStream = Arrays.stream(intArray);
		intStream
			.asDoubleStream()
			.forEach(d -> System.out.println(d));
			
		System.out.println();
		
		intStream = Arrays.stream(intArray);
		intStream
			.boxed()
			.forEach(obj -> System.out.println(obj.intValue()));
	}
}
//
1.0
2.0
3.0
4.0
5.0

1
2
3
4
5
```



## 16.6 정렬(sorted())

---



| 리턴 타입    | 메소드(매개 변수)      | 설명                                    |
| ------------ | ---------------------- | --------------------------------------- |
| Stream\<T>   | sorted()               | 객체를 Comparable 구현 방법에 따라 정렬 |
| Stream\<T>   | sorted(Comparator\<T>) | 객체를 주어진 Comparator에 따라 정렬    |
| DoubleStream | sorted()               | double 요소를 오름차순으로 정렬         |
| IntStream    | sorted()               | int 요소를 오름차순으로 정렬            |
| LongStream   | sorted()               | long 요소를 오름차순으로 정렬           |



```java
public class Student implements Comparable<Student> {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }

	@Override
	public int compareTo(Student o) {
		return Integer.compare(score, o.score);
	}
}
```



```java
sorted();
sorted( (a,b) -> a.compareTo(b) );
sorted( Comparator.naturalOrder() );
```



```java
sorted( (a,b) -> b.compareTo(a) );
sorted( Comparator.reverseOrder() );
```



```java
sorted( (a,b) -> {...} )
```



```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.IntStream;

public class SortingExample {
	public static void main(String[] args) {
		IntStream intStream = Arrays.stream(new int[] {5, 3, 2, 1, 4});
		intStream
			.sorted()
			.forEach(n -> System.out.print(n + ","));
		System.out.println();

		List<Student> studentList = Arrays.asList(
			new Student("홍길동", 30),
			new Student("신용권", 10),
			new Student("유미선", 20)
		);
		
		studentList.stream()
			.sorted( )
			.forEach(s -> System.out.print(s.getScore() + ","));
		System.out.println();
		
		studentList.stream()
		.sorted( Comparator.reverseOrder() )
		.forEach(s -> System.out.print(s.getScore() + ","));	
	}
}
//
1,2,3,4,5,
10,20,30,
30,20,10,
```



## 16.7 루핑(peek(), forEach())

---



```java
intStream
    .filter(a -> a%2 == 0)
    .peek( a -> System.out.println(a) )
```



```java
intStream
    .filter( a -> a%2==0)
    .peek( a -> System.out.println(a) )
    .sum()
```



```java
import java.util.Arrays;

public class LoopingExample {
	public static void main(String[] args) {
		int[] intArr = { 1, 2, 3, 4, 5 };
		
		System.out.println("[peek()를 마지막에 호출한 경우]");
		Arrays.stream(intArr)
			.filter(a -> a%2==0)
			.peek(n -> System.out.println(n));
		
		System.out.println("[최종 처리 메소드를 마지막에 호출한 경우]");
		int total = Arrays.stream(intArr)
			.filter(a -> a%2==0)
			.peek(n -> System.out.println(n))
			.sum();
		System.out.println("총합: " + total);
		
		System.out.println("[forEach()를 마지막에 호출한 경우]");
		Arrays.stream(intArr)
			.filter(a -> a%2==0)
			.forEach(n -> System.out.println(n)); 
	}
}
//
[최종 처리 메소드를 마지막에 호출한 경우]
2
4
총합: 6
[forEach()를 마지막에 호출한 경우]
2
4
```



## 16.8 매칭(allMatch(), anyMatch(), noneMatch())

---



| 리턴 타입 | 메소드(매개 변수)                                            | 제공 인터페이스 |
| --------- | ------------------------------------------------------------ | --------------- |
| boolean   | allMatch(Predicate\<T> predicate)<br>anyMatch(Predicate\<T> predicate)<br>noneMatch(Predicate\<T> predicate) | Stream          |
| boolean   | allMatch(IntPredicate predicate)<br>anyMatch(IntPredicate predicate)<br>nonMatch(IntPredicate predicate) | IntStream       |
| boolean   | allMatch(LongPredicate predicate)<br>anyMatch(LongPredicate predicate)<br>noneMatch(LongPredicate predicate) | LongStream      |
| boolean   | allMatch(DoublePredicate predicate)<br/>anyMatch(DoublePredicate predicate)<br/>noneMatch(DoublePredicate predicate) | DoubleStream    |



```java
import java.util.Arrays;

public class MatchExample {
	public static void main(String[] args) {
		int[] intArr = { 2, 4 ,6 };
		
		boolean result = Arrays.stream(intArr)
			.allMatch(a -> a%2==0);
		System.out.println("모두 2의 배수인가? " + result);
		
		result = Arrays.stream(intArr)
			.anyMatch(a -> a%3==0);
		System.out.println("하나라도 3의 배수가 있는가? " + result);
		
		result = Arrays.stream(intArr)
			.noneMatch(a -> a%3==0);
		System.out.println("3의 배수가 없는가?  " + result);
	}
}
//
모두 2의 배수인가? true
하나라도 3의 배수가 있는가? true
3의 배수가 없는가?  false
```



## 16.9 기본 집계 (sum(), count(), average), max(), min())

---



### 스트림이 제공하는 기본 집계



| 리턴 타입                   | 메소드(매개 변수)            | 설명         |
| --------------------------- | ---------------------------- | ------------ |
| long                        | count()                      | 요소 개수    |
| OptionalXXX                 | findFirst()                  | 첫 번째 요소 |
| Optional\<T><br>OptionalXXX | max(Comparator\<T>)<br>min() | 최대 요소    |
| Optional\<T><br>OptionalXXX | max(Comparator\<T>)<br>min() | 최소 요소    |
| OptionalDouble              | average()                    | 요소 평균    |
| int, long, double           | sum()                        | 요소 총합    |



```java
import java.util.Arrays;

public class AggregateExample {
	public static void main(String[] args) {
		long count = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.count();
		System.out.println("2의 배수 개수: " + count);
		
		long sum = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.sum();
		System.out.println("2의 배수의 합: " + sum);
		
		double avg = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.average()
			.getAsDouble();
		System.out.println("2의 배수의 평균: " + avg);
		
		int max = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.max()
			.getAsInt();
		System.out.println("최대값: " + max);
		
		int min = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%2==0)
			.min()
			.getAsInt();
		System.out.println("최소값: " + min);
		
		int first = Arrays.stream(new int[] {1, 2, 3, 4, 5})
			.filter(n -> n%3==0)
			.findFirst()
			.getAsInt();
		System.out.println("첫번째 3의 배수: " + first);
	}
}
//
2의 배수 개수: 2
2의 배수의 합: 6
2의 배수의 평균: 3.0
최대값: 4
최소값: 2
첫번째 3의 배수: 3
```



### Optional 클래스



| 리턴 타입                  | 메소드(매개 변수)                                            | 설명                                        |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| boolean                    | isPresent()                                                  | 값이 저장되어 있는지 여부                   |
| T<br>double<br>int<br>long | orElse(T)<br>orElse(double)<br>orElse(int)<br>orElse(long)   | 값이 저장되어 있지 않을 경우 디폴트 값 지정 |
| void                       | ifPresent(Consumer)<br>ifPresent(DoubleConsumer)<br>ifPresent(IntConsumer)<br>ifPresent(LongConsumer) | 값이 저장되어 있을 경우 Consumer에서 처리   |



```java
List<Integer> list = new ArrayList<>();
double avg = list.stream()
    .mapToInt(Integer :: intvalue)
    .average()
    .getAsDouble();
System.out.println("평균: " + avg);
```



``` java
OptionalDouble optional = list.stream()
    .mapToInt(Intger :: intValue)
    .average();
if(optional.isPresent()){
    System.out.println("평균: " + optional.getAsDouble());
}else{
    System.out.println("평균: 0.0");
}
```



```java
double avg = list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .orElse(0.0);
System.out.println("평균: " + avg);
```



```java
list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .ifPresent(a -> System.out.println("평균: " + a));
```



```java
import java.util.ArrayList;
import java.util.List;
import java.util.OptionalDouble;

public class OptionalExample {
	public static void main(String[] args) {
		List<Integer> list = new ArrayList<>();
		
		/*(java.util.NoSuchElementException)
		double avg = list.stream()
			.mapToInt(Integer :: intValue)
			.average()	
			.getAsDouble(); 
		*/

		OptionalDouble optional = list.stream()
			.mapToInt(Integer :: intValue)
			.average();	
		if(optional.isPresent()) {
			System.out.println("방법1_평균: " + optional.getAsDouble());
		} else {
			System.out.println("방법1_평균: 0.0");
		}

		double avg = list.stream()
			.mapToInt(Integer :: intValue)
			.average()
			.orElse(0.0);
		System.out.println("방법2_평균: " + avg);

		list.stream()
			.mapToInt(Integer :: intValue)
			.average()
			.ifPresent(a -> System.out.println("방법3_평균: " + a));
	}
}
//
방법1_평균: 0.0
방법2_평균: 0.0
```



## 16.10 커스텀 집계(reduce())

---



| 인터페이스   | 리턴 타입      | 메소드(매개 변수)                                  |
| ------------ | -------------- | -------------------------------------------------- |
| Stream       | Optional\<T>   | reduce(BinaryOperator\<T> accumulator)             |
| -            | T              | reduce(T identity, BinaryOperator\<T> accumulator) |
| IntStream    | OptionalInt    | reduce(IntBinaryOperator op)                       |
| -            | int            | reduce(int identity, IntBinaryOperator op)         |
| LongStream   | OptionalLong   | reduce(LongBinaryOperator op)                      |
| -            | long           | reduce(long identity, LongBinaryOperator op)       |
| DoubleStream | OptionalDouble | reduce(DoubleBinaryOperator op)                    |
| -            | double         | reduce(double identity, DoubleBinaryOperator op)   |



```java
int sum = studentList.stream()
    .map(Student :: getScore)
    .reduce(a, b) -> a+b
    .get();
---
int sum = studentList.stream()
    .map(Student :: getScore)
    .reduce(0, (a, b) -> a+b)
```



```java
import java.util.Arrays;
import java.util.List;

public class ReductionExample {
	public static void main(String[] args) {
		List<Student> studentList = Arrays.asList(
				new Student("홍길동", 92),
				new Student("신용권", 95),
				new Student("김자바", 88)
		);
		
		int sum1 = studentList.stream()
				.mapToInt(Student :: getScore)
				.sum();
		
		int sum2 = studentList.stream()
				.map(Student :: getScore)
				.reduce((a, b) -> a+b)
				.get();
		
		int sum3 = studentList.stream()
						.map(Student :: getScore)
						.reduce(0, (a, b) -> a+b);
		
		System.out.println("sum1: " + sum1);
		System.out.println("sum2: " + sum2);
		System.out.println("sum3: " + sum3);
	}
}
//
sum1: 275
sum2: 275
sum3: 275
```

``` java
public class Student {
	private String name;
	private int score;
	
	public Student(String name, int score) {
		this.name = name;
		this.score = score;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
}
```



## 16.11 수집(collect())

---



### 필터링한 요소 수집



| 리턴 타입 | 메소드(매개 변수)                     | 인터페이스 |
| --------- | ------------------------------------- | ---------- |
| R         | collect(Collector<T, A, R> collector) | Stream     |



| 리턴 타입                              | Collectors의 정적 메소드                                     | 설명                                                         |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Collector<T, ?, List\<T>>              | toList()                                                     | T를 List에 저장                                              |
| Collector<T, ?, Set\<T>>               | toSet()                                                      | T를 Set에 저장                                               |
| Collector<T, ?, Collection\<T>>        | toCollection(<br>     Supplier<Collection\<T><br>)           | T를 Supplier가 제공한Collection에 저장                       |
| Collector<T, ?, Map<K, U>>             | toMap(<br>     Function<T, K> keyMapper,<br>     Function<T, U> valueMapper) | T와 K와 U로 매핑해서 K를 키로, U를 값으로 Map에 저장         |
| Collector<T, ? <br>ConcurrentMap<K, U> | toConcurrentMap(<br>     Function<T, K> keyMapper,<br>     Function<T, U> valueMapper) | T를 K와 U로 매핑해서 K를 키로, U를 값으로 ConcurrentMap에 저장 |



```java
1. Stream<Student> totalStream = totalList.stream();
2. Stream<Student> maleStream = totalStream.filter(s->s.getSex() == Student.Sex.MALE);
3. Collection<Student, ?, List<Student>> collector = Collectors.toList();
4. List<Student> maleList = maleStream.collect(collector);
```



```java
List<Student> maleList = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(Collectors.toList());
```



```java
1. Stream<Student> totalStream = totalList.stream();
2. Stream<Student> femaleStream = totalStream.filter(s->s.getSex()==Student.Sex.FEMALE);
3. Supplier<HashSet<Student>> supplier = HashSet :: new;
4. Collector<Student, ?, HashSet<Student>> collector = Collectors.toCollection(supplier);
5. Set<Student> femaleSet = femaleStream.collect(collect);
```



```java
Set<student> femaleSet = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.FEMALE)
    .collect(Collectors.toCollection(HashSet :: new));
```

```java
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class ToListExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 6, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 6, Student.Sex.FEMALE)
		);

		List<Student> maleList = totalList.stream()
				.filter(s->s.getSex()==Student.Sex.MALE)
				.collect(Collectors.toList());
		maleList.stream()
			.forEach(s -> System.out.println(s.getName()));
		
		System.out.println();

		Set<Student> femaleSet = totalList.stream()
				.filter(s -> s.getSex() == Student.Sex.FEMALE)
				.collect( Collectors.toCollection(()->new HashSet<Student>()) );
		femaleSet.stream()
			.forEach(s -> System.out.println(s.getName()));
	}
}
//
홍길동
신용권

김수애
박수미
```

```java
public class Student {
	public enum Sex { MALE, FEMALE }
	public enum City { Seoul, Pusan }
	
	private String name;
	private int score;
	private Sex sex;
	private City city;
	
	public Student(String name, int score, Sex sex) {
		this.name = name;
		this.score = score;
		this.sex = sex;
	}	
	
	public Student(String name, int score, Sex sex, City city) {
		this.name = name;
		this.score = score;
		this.sex = sex;
		this.city = city;
	}

	public String getName() { return name; }
	public int getScore() { return score; }
	public Sex getSex() { return sex; }
	public City getCity() { return city; }
}
```



### 사용자 정의 컨테이너에 수집하기



| 인터페이스   | 리턴 타입 | 메소드(매개 변수)                                            |
| ------------ | --------- | ------------------------------------------------------------ |
| Stream       | R         | collect(Supplier\<R>, BiConsumer<R, ? super T>, BiConsumer<R, R>) |
| IntStrema    | R         | collect(Supplier\<R>, ObjIntConsumer\<R>, BiConsumer<R, R>)  |
| LongStream   | R         | collect(Supplier\<R>, ObjLongConsumer\<R>, BiConsumer<R, R>) |
| DoubleStream | R         | collect(Supplier\<R>, ObjDoubleConsumer\<R>, BiConsumer<R, R>) |



```java
import java.util.ArrayList;
import java.util.List;

public class MaleStudent  {
	private List<Student> list;
	
	public MaleStudent() {
		list = new ArrayList<Student>();
		System.out.println("[" + Thread.currentThread().getName() + "] MaleStudent()");
	}
	
	public void accumulate(Student student) {
		list.add(student);
		System.out.println("[" + Thread.currentThread().getName() + "] accumulate()");
	}
	
	public void combine(MaleStudent other) {
		list.addAll(other.getList());
		System.out.println("[" + Thread.currentThread().getName() + "] combine()");
	}
	
	public List<Student> getList() {
		return list;
	}
}
```



```java
1. Stream<Student> totlaStream = totlaList.stream();
2. Stream<Student> maleStream = totalStream.filters(s->s.getSex()==Student.Sex.MALE);
3. Supplier<MaleStudent> supplier = ()->new MaleStudent();
4. BiConsumer<MaleStudent, Student> accumulator = (ms, s)->ms.accumulate(s);
5. BiConsumer<MaleStudent, MaleStudent> combiner = (ms1, ms2)->ms1.combine(ms2);
6. MaleStudent maleStudent = maleStream.collect(supplier, accumulator, combiner);
```



```java
MaleStudent maleStudent = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(
		()->new MaleStudent(),
		(r, t)->r.accumulate(t),
		(r1, r2)->r1.combine(r2)
);
```



```java
MaleStudent maleStudent = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
```



```java
import java.util.Arrays;
import java.util.List;

public class MaleStudentExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 6, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 6, Student.Sex.FEMALE)
		);
		
		MaleStudent maleStudent = totalList.stream()
				.filter(s -> s.getSex() == Student.Sex.MALE)
				//.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine); 
				.collect(()->new MaleStudent(), (r, t)->r.accumulate(t), (r1, r2)->r1.combine(r2));
		
		maleStudent.getList().stream()
			.forEach(s -> System.out.println(s.getName()));
	}
}
//
[main] MaleStudent()
[main] accumulate()
[main] accumulate()
홍길동
신용권
```



### 요소를 그룹핑해서 수집



| 리턴 타입                                    | Collectors의 정적 메소드                                     | 설명                                                         |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Collector<T,?,Map<K,List\<T>>>               | groupingBy(Function<T,K> classifier)                         | T를 K로 매핑하고 K키에 저장된 List에 T를 저장한 Map생성      |
| Collector<T,?,<br>ConcurrentMap<K,List\<T>>> | groupingByConcurrent(<br>     Function<T,K> classifier)      | -                                                            |
| Collector<T,?,Map<K,D>>                      | groupingBy(<br>     Function<T,K> classifier,<br>     Collector<T, A, D> collector) | T를 K로 매핑하고 K키에 저장된 D객체에 T를 누적한 Map 생성    |
| Collector<T,?,<br>ConcurrentMap<K,D>>        | groupingByConcurrent(<br>     Function<T,K> classifier,<br>     Collector<T, A, D> collector) | -                                                            |
| Collector<T,?,Map<K,D>>                      | groupingBy(<br>     Fuction<T,K> classifier,<br>     Supplier<Map<K,D>> mapFactory,<br>     Collector<T, A, D> collector) | T를 K로 매핑하고 Supplier가 제공하는 Map에서 K키에 저장된 D객체에 T를 누적 |
| Collector<T,?,<br>ConcurrentMap<K,D>>        | groupingByConcurrent(<br>     Function<T,K> classifier,<br>     Supplier<ConcurrentMap<K,D>><br>     mapFactory,<br>     Collector<T, A, D> collector) | -                                                            |



```java
1. Stream<Student> totalStream = totalList.stream();
2. Function<Student, Student.Sex> classifier = Student :: getSex;
3. Collector<Student, ?, Map<Student.Sex, List<Student>>> collector = Collectors.groupingBy(classifier);
4. Map<Student.Sex, List<Student>> mapBySex = totalStream.collect(collector);
```



```java
Map<Student.Sex, List<Student>> mapBySex = totalList.stream()
    .collect(Collectors.groupingBy(Student :: getSex));
```



```java
1. Stream<Student> totalStream = totalList.stream();
2. Function<Student, Student.City> classifier = Student::getCity;
3. Function<Student, String> mapper = Student::getName;
4. Collector<String, ?, List<String>> collector1 = Collectors.toList();
5. Collector<Student, ?, List<String>> collector2 = Collectors.mapping(mapper, collector);
6. Collector<Student, ?, Map<Student.City, List<String>>> collector3 = Collectors.groupingBy(classifier, collector2);
7. Map<Student.City, List<String>> mapByCity = totalStream.collect(collector3);
```



```java
Map<Student.City, List<String>> mapByCity = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getCity,
        	Collectors.mapping(Student::getName, Collectors.toList())
        )
)
```



```java
Map<Student.City, List<String>> mapByCity = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getCity,
        	TreeMap::new,
        	Collectors.mapping(Student::getNAme, Collectors.toList())
        )
)
```



```java
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class GroupingByExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE, Student.City.Seoul),
				new Student("김수애", 6, Student.Sex.FEMALE, Student.City.Pusan),
				new Student("신용권", 10, Student.Sex.MALE, Student.City.Pusan),
				new Student("박수미", 6, Student.Sex.FEMALE, Student.City.Seoul)
		);
		
		Map<Student.Sex, List<Student>> mapBySex = totalList.stream()
				.collect(Collectors.groupingBy(Student :: getSex));
		System.out.print("[남학생] ");
		mapBySex.get(Student.Sex.MALE).stream().forEach(s->System.out.print(s.getName() + " "));
		System.out.print("\n[여학생] ");
		mapBySex.get(Student.Sex.FEMALE).stream().forEach(s->System.out.print(s.getName() + " "));
		
		System.out.println();
		
		Map<Student.City, List<String>> mapByCity = totalList.stream()
				.collect(
						Collectors.groupingBy(
								Student::getCity, 
								Collectors.mapping(Student::getName, Collectors.toList())
						)
				); 
		System.out.print("\n[서울] ");
		mapByCity.get(Student.City.Seoul).stream().forEach(s->System.out.print(s + " "));
		System.out.print("\n[부산] ");
		mapByCity.get(Student.City.Pusan).stream().forEach(s->System.out.print(s + " "));	
	}
}
//
[남학생] 홍길동 신용권 
[여학생] 김수애 박수미 

[서울] 홍길동 박수미 
[부산] 김수애 신용권
```



### 그룹핑 후 매핑 및 집계



| 리턴 타입                        | 메소드(매개 변수)                                            | 설명                                                    |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| Collector<T, ?, R>               | mapping(<br>     Function<T, U> mapper,<br>     Collector<U, A, R> collector) | T를 U로 매핑한 후 , U를 R에 수집                        |
| Collector<T, ?, Double>          | averagingDouble(<br>     ToDoubleFunction\<T> mapper)        | T를 Double로 매핑한 후. Double의 평균값을 산출          |
| Collector<T, ?, Long>            | counting()                                                   | T의 카운팅 수를 산출                                    |
| Collector<CharSequence,?.String> | joining(CharSequence delimiter)                              | CharSequence를 구분자(delimiter)로 연결한 String을 산출 |
| Collector<T,?,Optional\<T>>      | maxBy(<br/>     Comparator\<T> comparator)                   | Comparator를 이용해서 최대 T를 산출                     |
| Collector<T,?,Optional\<T>>      | minBt(<br/>     Comparaotr\<T> comparator)                   | Comparator를 이용해서 최소 T를 산출                     |
| Collector<T,?,Integer>           | summingInt(ToIntFunction)<br>summingLong(ToLongFunction)<br>summingDouble(ToDoubleFunction) | Int, Long, Double타입의 합계 산출                       |



```java
1. Stream<Student> totalStream = totalList.stream();
2. Function<Student, Student.Sex> classifier = Student :: getSex;
3. ToDoubleFunction<Student> mapper = Student :: getScore;
4. Collector<Student, ?, Double> collector1 = Collectors.averagingDouble(mapper);
5. Collector<Student, ?, Map<Student.Sex, Double>> collector2 = Collectors.groupingBy(classifier, collector1);
6. Map<Student.Sex, Double> mapBySex = totalStream.collect(collector2);
```



```java
Map<Student.Sex, Double> mapBySex = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getSex,
        	Collectors.averagingDouble(Student::getScore)
        )
	);
```



```java
Map<Student.Sex, String> mapByName = totalList.stream()
    .collect(
		Collectors.groupingBy(
        	Student::getSex,
        	Collectors.mapping
        	Student::getName,
        	Collectors.joining(",")
        )
	);
```



```java
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class GroupingAndReductionExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 12, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 12, Student.Sex.FEMALE)
		);

		Stream<Student> totalStream = totalList.stream();
		Function<Student, Student.Sex> classifier = Student :: getSex;
		ToDoubleFunction<Student> mapper = Student :: getScore;
		Collector<Student, ?, Double> collector1 = Collectors.averagingDouble(mapper);
		Collector<Student, ?, Map<Student.Sex, Double>> collector2 = Collectors.groupingBy(classifier, collector1);
		Map<Student.Sex, Double> mapBySex = totalStream.collect(collector2);
		
		/*Map<Student.Sex, Double> mapBySex = totalList.stream()
				.collect(
					Collectors.groupingBy(
						Student :: getSex, 
						Collectors.averagingDouble(Student :: getScore)
					)
				);*/
		
		System.out.println("남학생 평균 점수: " + mapBySex.get(Student.Sex.MALE));
		System.out.println("여학생 평균 점수: " + mapBySex.get(Student.Sex.FEMALE));

		Map<Student.Sex, String> mapByName = totalList.stream()
				.collect(
					Collectors.groupingBy(
						Student :: getSex, 
						Collectors.mapping(
							Student :: getName,
							Collectors.joining(",")
						)
					)
				);
		System.out.println("남학생 전체 이름:" + mapByName.get(Student.Sex.MALE));
		System.out.println("여학생 전체 이름: " + mapByName.get(Student.Sex.FEMALE));
	}
}
//
남학생 평균 점수: 10.0
여학생 평균 점수: 12.0
남학생 전체 이름:홍길동,신용권
여학생 전체 이름: 김수애,박수미
```



## 16.12 병렬 처리

---



### 동시성(Concurrency)과 병렬성(Parallelism)



### 포코조인(ForkJoin) 프레임워크



### 병렬 스트림 생성



| 인터페이스                                                   | 리턴 타입                                         | 메소드(매개 변수) |
| ------------------------------------------------------------ | ------------------------------------------------- | ----------------- |
| java.util.Collection                                         | Stream                                            | parallelStream()  |
| java.util.Stream.Stream<br>java.util.Stream.IntStream<br>java.util.Stream.LongStream<br>java.util.Stream.DoubleStream | Stream<br>IntStream<br>LongStream<br>DoubleStream | parallel()        |



```java
MaleStudent maleStudent = totalList.stream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine)
```



```java
MaleStudent maleStudent = totalList.parallelStream()
    .filter(s->s.getSex()==Student.Sex.MALE)
    .collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
```



```java
import java.util.Arrays;
import java.util.List;

public class MaleStudentExample {
	public static void main(String[] args) {
		List<Student> totalList = Arrays.asList(
				new Student("홍길동", 10, Student.Sex.MALE),
				new Student("김수애", 10, Student.Sex.FEMALE),
				new Student("신용권", 10, Student.Sex.MALE),
				new Student("박수미", 10, Student.Sex.FEMALE)
		);
		
		MaleStudent maleStudent = totalList.parallelStream()
				.filter(s -> s.getSex() == Student.Sex.MALE)
				.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine); 
		
		maleStudent.getList().stream()
			.forEach(s -> System.out.println(s.getName()));
	}
}
//
[main] MaleStudent()
[ForkJoinPool.commonPool-worker-1] MaleStudent()
[ForkJoinPool.commonPool-worker-2] MaleStudent()
[ForkJoinPool.commonPool-worker-3] MaleStudent()
[main] accumulate()
[ForkJoinPool.commonPool-worker-3] accumulate()
[main] combine()
[ForkJoinPool.commonPool-worker-3] combine()
[ForkJoinPool.commonPool-worker-3] combine()
홍길동
신용권
```





### 병렬 처리 성능



```java
import java.util.Arrays;
import java.util.List;

public class SequencialVsParallelExample {
	public static void work(int value) {
		try { Thread.sleep(100); } catch (InterruptedException e) {}
	}
	
	public static long testSequencial(List<Integer> list) {
		long start = System.nanoTime();
		list.stream().forEach((a) -> work(a));
		long end = System.nanoTime();
	    long runTime = end - start;
	    return runTime;
	}
	
	public static long testParallel(List<Integer> list) {
		long start = System.nanoTime();
		list.stream().parallel().forEach((a)-> work(a));
		long end = System.nanoTime();
	    long runTime = end - start;
	    return runTime;
	}
	
	public static void main(String... args) {
		List<Integer> list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
		
		long Sequencial = testSequencial(list);
		
		long timeParallel = testParallel(list);
		
		if(Sequencial < timeParallel) {
			System.out.println("성능 테스트 결과: 순차 처리가 더 빠름");
		} else {
			System.out.println("성능 테스트 결과: 병렬 처리가 더 빠름");
		}
	}
}
//
성능 테스트 결과: 병렬 처리가 더 빠름
```



```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ArrayListVsLinkedListExample {
	public static void work(int value) {
	}

	public static long testParallel(List<Integer> list) {
		long start = System.nanoTime();
		list.stream().parallel().forEach((a)-> work(a));
		long end = System.nanoTime();
	    long runTime = end - start;
	    return runTime;
	}
	
	public static void main(String... args) {
		List<Integer> arrayList = new ArrayList<Integer>();
		List<Integer> linkedList = new LinkedList<Integer>();
		for(int i=0; i<1000000; i++) {
			arrayList.add(i);
			linkedList.add(i);
		}

		long arrayListListParallel = testParallel(arrayList);
		long linkedListParallel = testParallel(linkedList);

		arrayListListParallel = testParallel(arrayList);
		linkedListParallel = testParallel(linkedList);
		
		if(arrayListListParallel < linkedListParallel) {
			System.out.println("성능 테스트 결과: ArrayList 처리가 더빠름");
		} else {
			System.out.println("성능 테스트 결과: LinkedList 처리가 더빠름");
		}
	}
}
//
성능 테스트 결과: ArrayList 처리가 더빠름
```

