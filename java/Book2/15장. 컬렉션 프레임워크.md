# 15장. 컬렉션 프레임워크

---



## 15.1 컬렉션 프레임워크 소개

---

- 자바 컬렉션이란? 객체를 수집해서 저장하는 역할
- 프레임워크란? 사용 방법을 미리 정해 놓은 라이브러리

=>

- 컬렉션 프레임워크란? 자료구조를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록

java.util 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함 시켜 놓은 것.



![다운로드 (6)](C:\Users\user\Downloads\다운로드 (6).png)

ArrayList, Vector, LinkedList 는 List인터페이스를 구현한 객체

HashSet, TreeSet은 Set인터페이스를 구현한 객체

=> List와 Set은 공통점이 많아 공통된 메소드들을 Collection 인터페이스로 정의해 두고 있다.



HashMap, Hashtable, TreeMap, Properties는 Map인터페이스를 구현한 객체이다.

=> Map은 키와 값을 하나의 쌍으로 묶어서 관리하는 구조이기 때문에 List와 Set과는 사용 방법이 다르다.



| 인터페이스 분류 | -    | 특징                                              | 구현 클래스                             |
| --------------- | ---- | ------------------------------------------------- | --------------------------------------- |
| Collection      | List | - 순서를 유지하고 저장<br>- 중복 저장 가능        | ArrayList, Vector, LinkedList           |
| -               | Set  | - 순서를 유지하지 않고 저장<br>- 중복 저장 안 됨  | HashSet, TreeSet                        |
| Map             | -    | - 키와 값의 쌍으로 저장<br>- 키는 중복 저장 안 됨 | HashMap, Hashtable, TreeMap, Properties |



## 15.2 List 컬렉션

---

List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스 메소드

| 기능      | 메소드                         | 설명                                             |
| --------- | ------------------------------ | ------------------------------------------------ |
| 객체 추가 | boolean add(E e)               | 주어진 객체를 맨 끝에 추가                       |
| -         | void add(int index, E element) | 주어진 인덱스에 객체를 추가                      |
| -         | E set(int index, E element)r   | 주어진 인덱스에 저장된 객체를 주어진 객체로 바꿈 |
| 객체 검색 | boolean contains(Object o)     | 주어진 객체가 저장되어 있는지 여부               |
| -         | E get(int index)               | 주어진 인덱스에 저장된 객체를 리턴               |
| -         | boolean isEmpty()              | 컬렉션이 비어있는지 조사                         |
| -         | int size()                     | 저장되어 있는 전체 객체 수를 리턴                |
| 객체 삭제 | void clear()                   | 저장된 모든 객체를 삭제                          |
| -         | E remove(int index)            | 주어진 인덱스에 저장된 객체를 삭제               |
| -         | boolean remove(Object o)       | 주어진 객체를 삭제                               |

=> E는 List의 인터페이스가 제네릭 타입이기 때문에 사용



리스트 사용 예시)

``` java
List<String> list = ...;
list.add("홍길동"); // 맨 끝에 객체 추가
list.add(1,"신용권"); // 지정된 인덱스에 객체 삽입
String str = list.get(1); // 인덱스로 객체 찾기
list.remove(0); // 인덱스로 객체 삭제
list.remove("신용권"); // 값으로 객체 삭제
```

=> 저장된 객체를 하나씩 반복해서 얻고 싶다면

``` java
List<String> list = ...;
// 일반 for문
for(int i=0;i<list.size();i++){
    String str = list.get(i);
}
// 향상된 for문
for(String str : list){
    
}
```



### ArrayList

ArrayList와 일반 배열의 다른 점!

- 일반 배열은 생성시 크기가 고정되고 사용 중에 크기 변경이 안되나,

  ArrayList는 저장 용량을 초과하면 자동으로 저장 용량이 늘어난다.



ArrayList의 생성

``` java
List<String> list = new ArrayList<String>();

List<String> list = new ArrayList<String>(30);
```

- String타입을 저장하는 ArrayList

- 기본 생성자로 호출하면 내부에 10개의 객체를 저장하는 초기 용량이 설정된다.

- 생성자에 매개값으로 용량을 줄 수 있다.

- 자바 4에선 제네릭이 없어서 모든 종류의 객체를 Object타입으로 변환하고, 찾을 때 원래 타입으로 변환하는 불필요한 과정을 거쳤으나, 자바 5부턴 없다.! 



ArrayList의 특징

1. 객체를 추가하면 인덱스 0부터 차례대로 저장된다.
2. 특정 인덱스에 위치한 객체를 제거하면 그 뒤 인덱스들이 모두 앞으로 1칸씩 당겨진다.(물리적 연속)
3. 객체의 삭제와 삽입이 빈번하게 일어날 때는 LinkedList를 사용하자!



ArrayList의 사용 예시

``` java
import java.util.Arrays;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("JAVA"); // 자료 추가
        list.add("JDBC");
        list.add("Servlet/JSP");
        list.add(2,"Database");
        list.add("iBATIS");

        int size = list.size(); // 저장된 총 객체수 얻기
        System.out.println("총 객체수: " + size);
        System.out.println();

        String skill = list.get(2); // 2번 인덱스의 객체 얻기
        System.out.println("2: " + skill);
        System.out.println();

        for(int i=0;i<list.size();i++){ // 저장된 객체 모두 출력
            String str = list.get(i);
            System.out.println(i + ":" + str);
        }
        System.out.println();

        list.remove(2); // 2번 인덱스 객체 삭제
        list.remove(2); // 2번 인덱스 객체 삭제
        list.remove("iBATIS"); // iBATIS 객체 삭제

        for(int i=0;i<list.size();i++){ // 저장된 객체 모두 출력
            String str = list.get(i);
            System.out.println(i + ":" + str);
        }
    }
}
//
총 객체수: 5

2: Database

0:JAVA
1:JDBC
2:Database
3:Servlet/JSP
4:iBATIS

0:JAVA
1:JDBC
```



Arrays.asList(T .. a) 메소드

``` java
List<T> list = Arrays.asList(T .. a);
```

=> 고정된 객체들로 구성된 List를 생성하고 싶을 때 사용

T 타입에 맞게 매개값을 순차적으로 입력하거나 T[] 배열을 매개값으로 주면된다.!



Arrays.asList(T.. a) 사용 예시

``` java
import java.util.Arrays;
import java.util.List;

public class ArraysAsListExample {
    public static void main(String[] args){
        List<String> list1 = Arrays.asList("홍길동","신용권","김자바");
        for(String names: list1){
            System.out.println(names);
        }

        List<Integer> list2 = Arrays.asList(1,2,3);
        for(int value : list2){
            System.out.println(value);
        }
    }
}
//
홍길동
신용권
김자바
1
2
3
```



### Vector

Vector의 생성

``` java
List<E> list = new Vector<E>();
```

- Vector는 ArrayList와 동일한 기능을 가지고 있다.



다른 점 !! 

- Vector은 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 

  하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.

=> 이 멀티 스레드에서 안전하게 객체를 추가, 삭제 하는 것을 "스레드가 안전"하다라고 한다.



Vector사용 예시

```java
import java.util.List;
import java.util.Vector;

public class VectorExample {
    public static void main(String[] args){
        List<Board> list = new Vector<Board>();

        list.add(new Board("제목1","내용1","글쓴이1")); // 객체 추가
        list.add(new Board("제목2","내용2","글쓴이2"));
        list.add(new Board("제목3","내용3","글쓴이3"));
        list.add(new Board("제목4","내용4","글쓴이4"));
        list.add(new Board("제목5","내용5","글쓴이5"));

        list.remove(2); // 2번 인덱스 객체 삭제
        list.remove(3); // 3번 인덱스 객체 삭제

        for(int i=0;i<list.size();i++){ // 저장된 객체 모두 출력
            Board board = list.get(i);
            System.out.println(board.subject + "\t" + board.content + "\t" + board.writer);
        }
    }
}
//
제목1	내용1	글쓴이1
제목2	내용2	글쓴이2
제목4	내용4	글쓴이4
```



### LinkedList

LinkedList의 내부 구조는 인접 참조를 링크해서 체인처럼 관리하기 때문에

ArrayList의 내부 구조와는 완전히 다르다.!

![다운로드 (7)](C:\Users\user\Downloads\다운로드 (7).png)

=> Linked리스트에서 객체의 삭제와 삽입이 일어날 때에는, 객체의 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다

따라서 객체의 삭제와 삽입이 빈번하게 일어날 때에는 LinkedList가 ArrayList보다 효율적이다.



LinkedList의 생성

``` java
List<E> list = new LinkedList<E>();
```



ArrayList와 LinkedList의 객체 삽입 시간 측정 예시 (0번째 인덱스에 객체를 10000번 추가하는데 걸리는 시간)

``` java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class LinkedListExample {
    public static void main(String[] args){
        List<String> list1 = new ArrayList<String>();
        List<String> list2 = new LinkedList<String>();

        long startTime;
        long endTime;

        startTime = System.nanoTime();
        for(int i=0;i<10000;i++){
            list1.add(0,String.valueOf(i));
        }
        endTime = System.nanoTime();
        System.out.println("ArrayList 걸린시간: " + (endTime-startTime) + " ns");

        startTime = System.nanoTime();
        for(int i=0;i<10000;i++){
            list2.add(0,String.valueOf(i));
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList 걸린시간: " + (endTime-startTime) + " ns");
    }
}
//
ArrayList 걸린시간: 12100500 ns
LinkedList 걸린시간: 1725000 ns
```

=> LinkedList가 훨씬 효율적인 것을 볼 수 있다.



ArrayList와 LinkedList 비교 표

| 구분       | 순차적으로 추가/삭제 | 중간에 추가/삭제 | 검색   |
| ---------- | -------------------- | ---------------- | ------ |
| ArrayList  | 빠르다               | 느리다           | 빠르다 |
| LinkedList | 느리다               | 빠르다           | 느리다 |



## 15.3 Set 컬렉션

---

Set 컬렉션의 특징

- 저장 순서가 유지되지 않는다. 
- 객체가 중복해서 저장되지 않는다.(집합)
- 저장할 때의 순서와 출력될 때의 순서가 다를 수도 있다.(구슬 주머니)



Set 컬렉션에서 공통적으로 사용가능한 Set인터페이스들의 메소드

| 기능      | 메소드                     | 설명                                                         |
| --------- | -------------------------- | ------------------------------------------------------------ |
| 객체 추가 | boolean add(E e)           | 주어진 객체를 저장, 객체가 성공적으로 저장되면 true를 리턴하고 중복 객체면 false를 리턴 |
| 객체 검색 | boolean contains(Object o) | 주어진 객체가 저장되어 있는지 여부                           |
| -         | boolean isEmpty()          | 컬렉션이 비어 있는지 조사                                    |
| -         | iterator\<E> iterator()    | 저장된 객체를 한 번씩 가져오는 반복자 리턴                   |
| -         | int size()                 | 저장되어 있는 전체 객체 수 리턴                              |
| 객체 삭제 | void clear()               | 저장된 모든 객체를 삭제                                      |
| -         | boolean remove(Object o)   | 주어진 객체를 삭제                                           |



Set 사용 예시

```java
Set<String> set = ...;
set.add("홍길동"); // 객체 추가
set.add("신용권");
set.remove("홍길동"); // 객체 삭제
```

Set 컬렉션은 인덱스로 객체를 가져오는 메소드가 없는 대신, 객체를 대상으로 한 번씩 반복해서 가져오는 반복자가 있다.



iterator() 메소드!

```java
Set<String> set = ...;
Iterator<String> iterator = set.iterator();
```

| 리턴 타입 | 메소드명  | 설명                                                         |
| --------- | --------- | ------------------------------------------------------------ |
| boolean   | hasNext() | 가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴한다 |
| E         | next()    | 컬렉션에서 하나의 객체를 가져온다                            |
| void      | remove()  | Set 컬렉션에서 객체를 제거한다                               |

=> hasNext() 가 true를 리턴할 때 next()를 사용해야 한다.



위 메소드들 을 사용해서 저장된 객체에 접근, next()로 가져온 객체를 제거하는 예시

```java
Set<String> set = ...;
Iterator<String> iterator = set.iterator();
// while문 사용
While(iterator.hasNext(){
    String str = iterator.next();
}
// 향상된 for문 사용
for(String str : set){
    
}
// 객체를 제거하는 예시
while(iterator.hasNext()){
    String str = iterator.next();
    if(str.equals("홍길동")){
        iterator.remove();
    }
}
```



### HasSet

HashSet의 생성

``` java
Set<E> set = new HashSet<E>(); // E는 저장할 객체의 타입
```



HashSet 특징

- 객체들을 순서 없이 저장하고 동일한 객체는 저장하지 않는다.

  => 동일한 객체는 hashCode()를 얻어내서 그 값을 비교하고 동일하면 equals() 메소드로 객체를 비교한다

  true 가 나오면 동일한 객체로 판단하고 중복 저장하지 않는다.



HashSet 사용 예시

``` java
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args){
        Set<String> set = new HashSet<String>();

        set.add("JAVA"); // 객체 추가
        set.add("JDBC");
        set.add("Servlet/JSP");
        set.add("JAVA"); // 동일한 객체!!
        set.add("iBATIS");

        int size = set.size();
        System.out.println("총 객체수: " + size);

        Iterator<String> iterator = set.iterator();
        while(iterator.hasNext()){ // 저장된 전체 객체 출력
            String element = iterator.next();
            System.out.println("\t" + element);
        }

        set.remove("JDBC"); // JDBC 객체 제거
        set.remove("iBATIS"); // iBATIS 객체 제거

        System.out.println("총 객체수: " + set.size());

        iterator = set.iterator();
        while(iterator.hasNext()){ // 저장된 전체 객체 출력
            String element = iterator.next();
            System.out.println("\t" + element);
        }

        set.clear(); // 초기화
        if(set.isEmpty()) {System.out.println("비어 있음");}
    }
}
//
총 객체수: 4
	JAVA
	JDBC
	Servlet/JSP
	iBATIS
총 객체수: 2
	JAVA
	Servlet/JSP
비어 있음
```



hashCode()와 equals() 메소드를 오버라이딩해서 인스턴스가 달라도 이름과 나이가 동일하면 동일한 객체로 저장하는 예시

``` java
public class Member {
    public String name;
    public int age;

    public Member(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public boolean equals(Object obj){
        if(obj instanceof Member){
            Member member =(Member) obj;
            return member.name.equals(name) && (member.age == age);
        }
        else{
            return false;
        }
    }
    @Override
    public int hashCode(){
        return name.hashCode() + age;
    }
}
```

``` java
public class HashSetExample2 {
    public static void main(String[] args){
        Set<Member> set = new HashSet<Member>();

        set.add(new Member("홍길동",30));
        set.add(new Member("홍길동",30));

        System.out.println("총 객체수 : "+ set.size());
    }
}
//
총 객체수 : 1
```



## 15.4 Map 컬렉션

---

Map 컬렉션의 특징

- 키와 값으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다.

- 키는 중복 저장될 수 없지만, 값은 중복 저장이 가능하다.
- 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 새로운 값으로 대치된다.



| 기능      | 메소드                              | 설명                                                         |
| --------- | ----------------------------------- | ------------------------------------------------------------ |
| 객체 추가 | V put(K key,V value)                | 주어진 키로 값을 저장, 새로운 키일 경우 null을 리턴하고 <br>동일한 키가 있을 경우 값을 대체하고 이전 값을 리턴 |
| 객체 검색 | boolean containsKey(Object key)     | 주어진 키가 있는지 여부                                      |
| -         | boolean containsValue(Object value) | 주어진 값이 있는지 여부                                      |
| -         | Set<Map.Entry<K,V>>entrySet()       | 키와 값의 쌍으로 구성된 모든 Map.Entry 객체를 Set에 담아서 리턴 |
| -         | V get(Object key)                   | 주어진 키가 있는 값을 리턴                                   |
| -         | boolean isEmpty()                   | 컬렉션이 비어 있는지 여부                                    |
| -         | Set\<K> keySet()                    | 모든 키를 Set객체에 담아서 리턴                              |
| -         | int size()                          | 저장된 키의 총 수를 리턴                                     |
| -         | Collection\<V> values()             | 저장된 모든 값을 Collection에 담아서 리턴                    |
| 객체 삭제 | void clear()                        | 모든 Map.Entry(키와 값)을 삭제                               |
| -         | V remove(Object key)                | 주어진 키와 일치하는 Map.Entry를 삭제하고 값을 리턴          |

=> K와 V는 타입 파라미터, Map의 인터페이스가 제네릭 타입이기 때문이다.



Map 메소드 사용 예시

```java
Map<String, Integer> map = ...;
map.put("홍길동",30); // 객체 추가
int score = map.get("홍길동"); // 객체 찾기
map.remove("홍길동"); // 객체 삭제
```



저장된 전체 객체를 대상으로 하나씩 얻고 싶을 때는

1. keySet() 메소드로 모든 키를 Set컬렉션으로 얻고, 반복자를  통해 키를 하나씩 얻고 get() 메소드를 통해 값을 얻는 방법

```java
Map<K, V> map = ...;
Set<K> keySet = map.keySet();
Iterator<K> keyIterator = keySet.iterator();
while(keyIterator.hasNext()){
    K key = keyIterator.next();
    V value = map.get(key);
}
```



2. EntrySet() 메소드로 모든 Map.Entry를 Set컬렉션으로 얻은 다음, 반복자를 통해 Map.Entry를 하나씩 얻고 getKey()와 getValue() 메소드를 이용해 키와 값을 얻는 방법

``` java
Set<Map.Entry<K, V>> entrySet = map.entrySet();
Iterator<Map, Entry<K, V>> entryIterator = entrySet.iterator();
while(entryIterator.hasNext()){
    Map.Entry<K, V> entry = entryIterator.next();
    K key = entry.getKey();
    V value = entry.getValue();
}
```



### HashMap

HashMap의 키로 사용할 객체는 hashCode()와 equals() 메소드를 재정의해서 동등 객체가 될 조건을 정해야 한다.

hashCode()의 리턴값이 같고 equals() 메소드가 true를 리턴하면 동일한 키가 된다.



HashMap의 생성

``` java
Map<K,V> map = new HashMap<K,V>();
Map<String, Integer> map = new HashMap<String, Integer>();
```

- 키와 값의 타입은 기본 타입은 사용할 수 없고, 클래스 및 인터페이스 타입만 가능하다.

- String타입의 키와 Integer타입의 값을 가진 HashMap의 생성



HashMap사용 예시

``` java
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class HashMapExample {
    public static void main(String[] args){
        Map<String,Integer> map = new HashMap<String,Integer>();

        map.put("신용권",85);
        map.put("홍길동",90);
        map.put("동장군",80);
        map.put("홍길동",95); // 키가 동일 -> 값이 바뀜
        System.out.println("총 Entry 수: " + map.size()); // 저장된 총 entry수 얻기

        System.out.println("\t홍길동 : " + map.get("홍길동")); // 키로 값을 검색
        System.out.println();

        Set<String> keySet = map.keySet(); // 전체 출력
        Iterator<String> keyIterator = keySet.iterator();
        while(keyIterator.hasNext()){
            String key = keyIterator.next();
            Integer value = map.get(key);
            System.out.println("\t" + key + " : " + value);
        }
        System.out.println();

        map.remove("홍길동"); // 키로 entry제거
        System.out.println("총 Entry 수: " + map.size());

        Set<Map.Entry<String,Integer>> entrySet = map.entrySet(); // MapEntry Set 얻기
        Iterator<Map.Entry<String,Integer>> entryIterator = entrySet.iterator();

        while(entryIterator.hasNext()){ // 전체 출력
            Map.Entry<String,Integer> entry = entryIterator.next();
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println("\t"+ key+" : " + value);
        }
        System.out.println();

        map.clear(); // 초기화
        System.out.println("총 Entry 수: " + map.size());
    }
}
//
총 Entry 수: 3
	홍길동 : 95

	홍길동 : 95
	신용권 : 85
	동장군 : 80

총 Entry 수: 2
	신용권 : 85
	동장군 : 80

총 Entry 수: 0
```



키의 타입을 사용자 정의 객체인 Student로 지정하고 HashMap 사용

```java
public class Student {
    public int sno;
    public String name;

    public Student(int sno,String name){
        this.sno = sno;
        this.name = name;
    }

    public boolean equals(Object obj){ // 학번과 이름이 같다면 true를 리턴
        if(obj instanceof Student){
            Student student = (Student) obj;
            return (sno == student.sno) && (name.equals(student.name));
        }else{
            return false;
        }
    }

    public int hashCode(){ // 학번 이름이 같다면 동일한 값을 리턴
        return sno + name.hashCode();
    }
}
```

``` java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample2 {
    public static void main(String[] args) {
        Map<Student, Integer> map = new HashMap<Student, Integer>();

        map.put(new Student(1,"홍길동"),95);
        map.put(new Student(1,"홍길동"),95); // 키와 값이 동일

        System.out.println("총 Entry 수: " + map.size());
    }
}
//
총 Entry 수: 1
```



### Hashtable

Hashtable은 HashMap과 동일하나 

Hashtable은 동기화된 메소드로 구성되어 있다. ( ArrayList와 Vector의 차이)



Hashtable의 생성

``` java
Map<K, V> map = new Hashtable<K, V>();
Map<String, Integer> map = new Hashtable<String, Integer>();
```



Hashtable 사용 예시

``` java
import java.util.Hashtable;
import java.util.Map;
import java.util.Scanner;

public class HashTableExample {
    public static void main(String[] args){
        Map<String,String> map = new Hashtable<String, String>();

        map.put("spring","12"); // 아이디와 비밀번호를 저장시킨다.
        map.put("summer","123");
        map.put("fall","1234");
        map.put("winter","12345");

        Scanner scanner = new Scanner(System.in);

        while(true){
            System.out.println("아이디와 비밀번호를 입력해주세요");
            System.out.print("아이디: ");
            String id = scanner.nextLine();

            System.out.print("비밀번호: ");
            String password = scanner.nextLine();
            System.out.println();

            if(map.containsKey(id)){ // 아이디인 키가 존재하는지 확인한다.
                if(map.get(id).equals(password)){ // 패스워드가 존재하는지 확인한다.
                    System.out.println("로그인 되었습니다.");
                    break;
                }
                else {
                    System.out.println("비밀번호 일치하기 않습니다.");
                }
            }else{
                System.out.println("입력하신 아이디가 존재하지 않습니다.");
            }
        }
    }
}

// 
아이디와 비밀번호를 입력해주세요
아이디: spring
비밀번호: 12

로그인 되었습니다.
```



### Properties // 추가

Properties 특징

- Hashtable의 하위 클래스이기 때문에 Hashtable의 모든 특성을 가지고 있다.

- 키와 값의 타입을 String 으로 제한했다.



```java
driver=oracle.jdbc.OracleDriver
url=jdbc:oracle:thin:@localhost:1521:orcl
username=scott
password=tiger
```

=>

``` java
import java.io.FileReader;
import java.net.URLDecoder;
import java.util.Properties;

public class PropertiesExample { 
    public static void main(String[] args)throws Exception{
        Properties properties = new Properties();
        String path = PropertiesExample.class.getResource("database.properties").getPath();
        path = URLDecoder.decode(path,"utf-8");
        properties.load(new FileReader(path));

        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        String username = properties.getProperty("username");
        String password = properties.getProperty("password");

        System.out.println("driver : " + driver);
        System.out.println("url : " + url);
        System.out.println("username : " + username);
        System.out.println("password : " + password);
    }
}
//
driver : oracle.jdbc.OracleDriver
url : jdbc:oracle:thin:@localhost:1521:orcl
username : scott
password : tiger
```



## 15.5 검색 기능을 강화시킨 컬렉션

---

컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공한다.

TreeSet-> Set컬렉션

TreeMap-> Map컬렉션 

### 이진 트리 구조

![다운로드 (10)](C:\Users\user\Downloads\다운로드 (10).png)

이진 트리란? 

- 여러 개의 노드가 트리 형태로 연결된 구조
- 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조
  - 위 노드를 부모, 아래 노드를 자식이라 하면 부모 노드는 최대 두 개의 자식 노드와 연결
  - 부모 노드의 값보다 작은 노드는 왼쪽
  - 부모 노드의 값보다 큰 노드는 오른쪽
- 첫 번째로 저장되는 값은 루트 노드
- 두 번째부터는 값의 크기를 비교하면서 트리를 따라 내려간다.
  - 결과적으로 가장 작은 값은 가장 왼쪽에 가장 큰 값은 가장 오른쪽에 위치한다.

=> 위 구조로 인해 이진 트리가 범위 검색을 쉽게 할 수 있다.



### TreeSet

- 이진 트리를 기반으로한 Set 컬렉션

- 하나의 노드는 노드값인 value와 왼쪽과 오른쪽 자식 노드를 참조하기 위한 두개의 변수로 구성
- 부모 값과 비교해서 낮은 것은 왼쪽, 높은 것은 오른 쪽에 저장



TreeSet의 생성

``` java
TreeSet<E> treeSet = new TreeSet<E>(); // E는 제네릭
TreeSet<String> treeSet = new TreeSet<String>(); // String 타입
```

Set인터페이스 타입 변수에 대입하지 않고 TreeSet 클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위함.



TreeSet의 객체를 찾는 메소드

| 리턴 타입 | 메소드       | 설명                                                         |
| --------- | ------------ | ------------------------------------------------------------ |
| E         | first()      | 제일 낮은 객체를 리턴                                        |
| E         | last()       | 제일 높은 객체를 리턴                                        |
| E         | lower(E e)   | 주어진 객체보다 바로 아래 객체를 리턴                        |
| E         | higher(E e)  | 주어진 객체보다 바로 위 객체를 리턴                          |
| E         | floor(E e)   | 주어진 객체와 동등한 객체가 있으면 리턴, 만약<br>없다면 주어진 객체의 바로 아래의 객체를 리턴 |
| E         | ceiling(E e) | 주어진 객체와 동등한 객체가 있으면 리턴, 만약<br>없다면 주어진 객체의 바로 위의 객체를 리턴 |
| E         | pollFirst()  | 제일 낮은 객체를 꺼내오고 컬렉션에서 제거함                  |
| E         | pollLast()   | 제일 높은 객체를 꺼내오고 컬렉션에서 제거함                  |



TreeSet 메소드 사용 예시

``` java
import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args){
        TreeSet<Integer> scores = new TreeSet<Integer>();
        scores.add(new Integer(87));
        scores.add(new Integer(98));
        scores.add(new Integer(75));
        scores.add(new Integer(95));
        scores.add(new Integer(80));

        Integer score = null;

        score = scores.first();
        System.out.println("가장 낮은 점수: " + score);

        score = scores.last();
        System.out.println("가장 높은 점수: " + score);

        score = scores.lower(new Integer(95));
        System.out.println("95점 아래 점수: " + score);

        score = scores.higher(new Integer(95));
        System.out.println("95점 위의 점수: " + score + "\n");

        score = scores.floor(new Integer(95));
        System.out.println("95점  이거나 바로 아래 점수: " + score);

        score = scores.ceiling(new Integer(85));
        System.out.println("85점 이거나 바로 위의 점수: " + score + "\n");

        while(!scores.isEmpty()){
            score = scores.pollFirst();
            System.out.println(score + "(남은 객체 수: " + scores.size() + ")");
        }
    }
}
//
가장 낮은 점수: 75
가장 높은 점수: 98
95점 아래 점수: 87
95점 위의 점수: 98

95점  이거나 바로 아래 점수: 95
85점 이거나 바로 위의 점수: 87

75(남은 객체 수: 4)
80(남은 객체 수: 3)
87(남은 객체 수: 2)
95(남은 객체 수: 1)
98(남은 객체 수: 0)
```



TreeSet의 정렬과 관련된 메소드

| 리턴 타입        | 메소드               | 설명                                    |
| ---------------- | -------------------- | --------------------------------------- |
| Iterator\<E>     | descendingIterator() | 내림차순으로 정렬된 Iterator를 리턴     |
| NavigableSet\<E> | descendingSet()      | 내림차순으로 정렬된 NavigableSet을 반환 |



descendingIterator() 메소드

- 내림차순으로 정렬된 Iterator객체를 리턴



descendingSet() 메소드

- 내림차순으로 정렬된 NavigableSet 객체를 리턴
- NavigableSet은 TreeSet처럼 first(), last(), lower() higher(), floor(), ceiling() 메소드를 제공
- 정렬 순서를 바꾸는 descendingSet() 메소드도 제공 => 두 번 호출하면 오름차순이 된다.

``` java
NavigableSet<E> descendingSet = treeSet.descendingSet();
NavigableSet<E> ascendingSet = descendingSet.descendingSet();
```



객체 정렬 예시

``` java
import java.util.NavigableSet;
import java.util.TreeSet;

public class TreeSetExample2 {
    public static void main(String[] args){
        TreeSet<Integer> scores = new TreeSet<Integer>();
        scores.add(new Integer(87));
        scores.add(new Integer(98));
        scores.add(new Integer(75));
        scores.add(new Integer(95));
        scores.add(new Integer(80));

        NavigableSet<Integer> descendingSet = scores.descendingSet();
        for(Integer score : descendingSet){
            System.out.print(score + " ");
        }
        System.out.println();

        NavigableSet<Integer> ascendingSet = descendingSet.descendingSet();

        for(Integer score : ascendingSet){
            System.out.print(score + " ");
        }
    }
}
//
98 95 87 80 75 
75 80 87 95 98 
```



TreeSet의 범위 검색 관련 메소드

| 리턴 타입        | 메소드                                                       | 설명                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| NavigableSet\<E> | headSet(<br>   E toElement,<br>   boolean inclusive<br>)     | 주어진 객체보다 낮은 객체들을 NavigableSet으로 리턴,<br>주어진 객체 포함 여부는 두 번째 매개값에 따라 달라짐. |
| NavigableSet\<E> | tailSet(<br>   E fromElement,<br>   boolean inclusive<br>)   | 주어진 객체보다 높은 객체들을 NaviableSet으로 리턴,<br>주어진 객체 포함 여부는 두 번째 매개값에 따라 달라짐. |
| NavigableSet\<E> | subSet(<br>   E fromElement,<br>   boolean fromInclusive,<br>   E toElement,<br>   boolean toInclusive<br>) | 시작과 끝으로 주어진 객체 사이의 객체들을 NavigableSet<br>으로 리턴, 시작과 끝 객체의 포함 여부는 두 번째, 네 번째 매<br>개값에 따라 달라짐 |



subSet() 메소드의 사용 예시

```java
NavigableSet<E> set = treeSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
    
    시작 객체, 시작 객체의 포함 여부, 끝 객체, 끝 객체의 포함 여부
```



``` java
import java.util.NavigableSet;
import java.util.TreeSet;

public class TreeSetExample3 {
    public static void main(String[] args){
        TreeSet<String> treeSet = new TreeSet<String>();
        treeSet.add("apple");
        treeSet.add("forever");
        treeSet.add("description");
        treeSet.add("ever");
        treeSet.add("zoo");
        treeSet.add("base");
        treeSet.add("guess");
        treeSet.add("cherry");

        System.out.println("[c~f 사이의 단어 검색]");
        NavigableSet<String> rangeSet = treeSet.subSet("c" , true, "f" ,true);
        for(String word: rangeSet){
            System.out.println(word);
        }
    }
}
//
cherry
description
ever
```

=>    "c"<= 검색 단어 <= "f"를 검사한다.



### TreeMap

- 이진 트리를 기반으로 한 Map 컬렉션

- Treeset과의 차이점은 키와 값이 저장된 Map.Entry를  저장한다는 점
- 키 값을 기준으로 Map.Entry객체를 저장한다.



TreeMap 객체의 생성

``` java
TreeMap<K, V> treeMap = new TreeMap<K, V>();
TreeMap<String, Integer> treeMap = new TreeMap<String, Integer>(); // 키 타입 String, 값 타입 Integer
```

=> Map 인터페이스 타입이 아니라 TreeMap 클래스 타입에 대입한 이유 또한 특정 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위함.



TreeMap의 검색 관련 메소드

| 리턴 타입      | 메소드              | 설명                                                         |
| -------------- | ------------------- | ------------------------------------------------------------ |
| Map.Entry<K,V> | firstEntry()        | 제일 낮은 Map.Entry를 리턴                                   |
| Map.Entry<K,V> | lastEntry()         | 제일 높은 Map.Entry를 리턴                                   |
| Map.Entry<K,V> | lowerEntry(K key)   | 주어진 키보다 바로 아래 Map.Entry를 리턴                     |
| Map.Entry<K,V> | higherEntry(K key)  | 주어진 키보다 바로 위 Map.Entry를 리턴                       |
| Map.Entry<K,V> | floorEntry(K key)   | 주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴, <br>없다면 주어진 키 바로 아래의 Map.Entry를 리턴 |
| Map.Entry<K,V> | ceilingEntry(K key) | 주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴, <br>없다면 주어진 키 바로 위의 Map.Entry를 리턴 |
| Map.Entry<K,V> | pollFirstEntry()    | 제일 낮은 Map.Entry를 꺼내오고 컬렉션에서 제거함             |
| Map.Entry<K,V> | pollLastEntry()     | 제일 높은 Map.Entry를 꺼내오고 컬렉셔에서 제거함             |



검색 관련 메소드 사용 예시

```  java
import java.util.Map;
import java.util.TreeMap;

public class TreeMapExample1 {
    public static void main(String[] args){
        TreeMap<Integer,String> scores = new TreeMap<Integer,String>();
        scores.put(new Integer(87),"홍길동");
        scores.put(new Integer(98),"이동수");
        scores.put(new Integer(75),"박길순");
        scores.put(new Integer(95),"신용권");
        scores.put(new Integer(80),"김자바");

        Map.Entry<Integer,String> entry = null;

        entry = scores.firstEntry();
        System.out.println("가장 낮은 점수: " + entry.getKey()+"-" + entry.getValue());

        entry = scores.lastEntry();
        System.out.println("가장 높은 점수: " + entry.getKey()+"-" + entry.getValue());

        entry = scores.lowerEntry(new Integer(95));
        System.out.println("95점 아래 점수: " + entry.getKey()+"-" + entry.getValue());

        entry = scores.higherEntry(new Integer(95));
        System.out.println("95점 위의 점수: " + entry.getKey()+"-" + entry.getValue());

        entry = scores.floorEntry(new Integer(95));
        System.out.println("95점 이거나 바로 아래 점수: " + entry.getKey()+"-" + entry.getValue());

        entry = scores.ceilingEntry(new Integer(85));
        System.out.println("85점 이거나 바로 위의 점수: " + entry.getKey()+"-" + entry.getValue());

        while(!scores.isEmpty()){
            entry=scores.pollFirstEntry();
            System.out.println(entry.getKey() + "-" + entry.getValue()+"(남은 객체 수: " +scores.size() + ")");
        }
    }
}
//
가장 낮은 점수: 75-박길순
가장 높은 점수: 98-이동수
95점 아래 점수: 87-홍길동
95점 위의 점수: 98-이동수
95점 이거나 바로 아래 점수: 95-신용권
85점 이거나 바로 위의 점수: 87-홍길동
75-박길순(남은 객체 수: 4)
80-김자바(남은 객체 수: 3)
87-홍길동(남은 객체 수: 2)
95-신용권(남은 객체 수: 1)
98-이동수(남은 객체 수: 0)
```



TreeMap의 정렬과 관련된 메소드

| 리턴 타입         | 메소드             | 설명                                                |
| ----------------- | ------------------ | --------------------------------------------------- |
| NavigableSet\<K>  | descendingKeySet() | 내림차순으로 정렬된 키의 NavigableSet을 리턴        |
| NavigableMap<K,V> | descendingMap()    | 내림차순으로 정렬된 Map.Entry의 NavigableMap을 리턴 |



descendingKeySet() 메소드

- 내림차순으로 정렬된 키의 NavigableSet 객체를 리턴 (TreeSet의 내용과 동일)



descendingMap() 메소드

- 내림차순으로 정렬된 NavigableMap 객체를 리턴
- firstEntry(), lastEntry(), lowerEntry(), higherEntry(), floorEntry(), ceilingEntry() 메소드를 제공
- 오름차순 내림차순을 번갈아가며 정렬 순서를 바꾸는 descendingMap() 메소드도 제공

``` java
NavigableMap<K,V> descendingSet = treeMap.descendingMap();
NavigableMap<K,V> ascendingSet = descendingMap.descendingMap();
```



정렬 관련 메소드 사용 예시

``` java
import java.util.*;

public class TreeMapExample2 {
    public static void main(String[] args){
        TreeMap<Integer,String> scores = new TreeMap<Integer,String>();
        scores.put(new Integer(87),"홍길동");
        scores.put(new Integer(98),"이동수");
        scores.put(new Integer(75),"박길순");
        scores.put(new Integer(95),"신용권");
        scores.put(new Integer(80),"김자바");

        NavigableMap<Integer,String> descendingMap = scores.descendingMap();
        Set<Map.Entry<Integer,String>> decendingEntrySet = descendingMap.entrySet();
        for(Map.Entry<Integer,String> entry : decendingEntrySet){
            System.out.print(entry.getKey() + "-" + entry.getValue() + " ");
        }
        System.out.println();

        NavigableMap<Integer,String> ascendingMap = descendingMap.descendingMap();
        Set<Map.Entry<Integer,String>> ascendingEntrySet = ascendingMap.entrySet();
        for(Map.Entry<Integer,String>entry : ascendingEntrySet){
            System.out.print(entry.getKey() + "-" + entry.getValue() + " ");
        }
    }
}
//
98-이동수 95-신용권 87-홍길동 80-김자바 75-박길순 
75-박길순 80-김자바 87-홍길동 95-신용권 98-이동수 
```



TreeSet의 범위 검색 관련 메소드

| 리턴 타입         | 메소드                                                       | 설명                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| NavigableMap<K,V> | headMap(<br>   K toKey,<br>   boolean inclusive<br>)         | 주어진 키보다 낮은 Map.Entry들을 NavigableMap<br>으로 리턴, 주어진 키의 Map.Entry 포함 여부는 두 번재 <br>매개값에 따라 달라짐 |
| NavigableMap<K,V> | tailMap(<br>   K fromKey,<br>   boolean inclusive<br>)       | 주어진 키보다 높은 Map.Entry들을 NavigableMap<br>으로 리턴, 주어진 키의 Map.Entry 포함 여부는 두 번쨰<br>매개값에 따라 달라짐 |
| NavigableMap<K,V> | subMap(<br>   K fromKey,<br>   boolean fromInclusive<br>   K toKey,<br>   boolean toInclusive<br>) | 시작과 끝으로 주어진 키 사이의 Map.Entry들을 <br>NavigableMap 컬렉션으로 반환, 시작과 끝 키의<br>Map.Entry 포함 여부는 두 번째, 네 번째 매개값에 따라 달라짐. |



subMap() 메소드의 사용 예시

``` java
NavigableMap<K,V> subMap = treeMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);

	시작 키, 시작 Map.Entry의 포함 여부, 끝 키, 끝 Map.Entry의 포함 여부
```



``` java
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

public class TreeMapExample3 {
    public static void main(String[] args){
        TreeMap<String,Integer> treeMap = new TreeMap<String,Integer>();
        treeMap.put("apple",new Integer(10));
        treeMap.put("forever",new Integer(60));
        treeMap.put("description" ,new Integer(40));
        treeMap.put("ever",new Integer(50));
        treeMap.put("zoo",new Integer(10));
        treeMap.put("base",new Integer(20));
        treeMap.put("guess",new Integer(70));
        treeMap.put("cherry",new Integer(30));

        System.out.println("[c~f 사이의 단어 검색]");

        NavigableMap<String,Integer> rangeMap = treeMap.subMap("c",true,"f",true);
        for(Map.Entry<String,Integer>entry : rangeMap.entrySet()){
            System.out.println(entry.getKey() + "-" + entry.getValue() + "페이지");
        }
    }
}
//
[c~f 사이의 단어 검색]
cherry-30페이지
description-40페이지
ever-50페이지
```

=> 키 값이 "c" <= 검색 단어 <= "f" 를 검사한다.



### Comparable과 Compator

- TreeSet의 객체와 TreeMap의 키는 저장과 동시에 오름차순로 정렬된다.
- TreeSet과 TreeMap은 정렬을 위해 java.lang.Comparable을 구현한 객체를 요구한다.
  - Integer, Double, String 모두 Comparable 인터페이스를 구현하고 있다.
  - 사용자 정의 클래스도 Comparable을 구현한다면 자동 정렬이 가능해진다.
- Comparable에는 compareTo() 메소드가 정의되어 있기 때문에 compareTo를 오버라이딩 해야 한다.

| 리턴 타입 | 메소드         | 설명                                                         |
| --------- | -------------- | ------------------------------------------------------------ |
| int       | compareTo(T o) | 주어진 객체와 같으면 0을 리턴<br>주어진 객체보다 적으면 음수를 리턴<br>주어진 객체보다 크면 양수를 리턴 |



comparable 사용 예시

``` java
public class Person implements Comparable<Person>{ // Comparable 인터페이스의 타입 Person
    public String name;
    public int age;

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override // compareTo 오버라이딩
    public int compareTo(Person o){
        if(age<o.age) return -1;
        else if(age == o.age) return 0;
        else return 1;
    }
}
```

``` java
import java.util.Iterator;
import java.util.TreeSet;

public class ComparableExample {
    public static void main(String[] args){
        TreeSet<Person> treeSet = new TreeSet<Person>();

        treeSet.add(new Person("홍길동",45));
        treeSet.add(new Person("김자바",25));
        treeSet.add(new Person("박지원",31)); // 나이순으로 저장 정렬됨.

        Iterator<Person> iterator = treeSet.iterator(); // 왼쪽 마지막 노드에서 오른쪽 노드까지 반복해서 가져오기
        while(iterator.hasNext()){
            Person person = iterator.next();
            System.out.println(person.name + ":" + person.age);
        }
    }
}
//
김자바:25
박지원:31
홍길동:45
```

=> TreeSet의 객체나 TreeMap의 키가 Comparable을 구현하고 있지 않을 경우에는 ClassCastException이 발생한다.



Comparable 비구현 객체를 정렬하는 방법

TreeSet 또는 TreeMap의 생성자의 매개값으로 정렬자(Comparator) 을 제공하면 된다.

```java
TreeSet<E> treeSet = new TreeSet<E>(new AscendingComparator());
// ->  오름차순 또는 내림차순 정렬자
TreeMap<K,V> treeMap = new TreeMap<K, V>(new DescendingComparator()); 
```



정렬자의 compare() 메소드의 정의

| 리턴 타입 | 메소드              | 설명                                                         |
| --------- | ------------------- | ------------------------------------------------------------ |
| int       | compare(T o1, T o2) | o1과 o2가 동등하다면 0을 리턴<br>o1이 o2보다 앞에 오게 하려면 음수를 리턴<br>o1이 o2보다 뒤에 오게하려면 양수를 리턴 |



comparator 사용 예시

``` java
import java.util.Comparator;

public class DescendingComparator implements Comparator<Fruit> {
    @Override
    public int compare(Fruit o1,Fruit o2){
        if(o1.price <o2.price) return 1; // 가격이 적을 경우 뒤에 오게함
        else if(o1.price == o2.price)return 0;
        else return -1;
    }
}
```

``` java
public class Fruit {
    public String name;
    public int price;

    public Fruit(String name,int price){
        this.name = name;
        this.price = price;
    }
}
```

``` java
import java.util.Iterator;
import java.util.TreeSet;

public class ComparatorExample {
    public static void main(String[] args) {
        /*
        TreeSet<Fruit> treeSet = new TreeSet<Fruit>(); // 정렬자를 주지 않고 TreeSet에 저장하면 ClassCastException 예외 발생
        treeSet.add(new Fruit("포도",3000));
        treeSet.add(new Fruit("수박",10000));
        treeSet.add(new Fruit("딸기",6000));
        */

        TreeSet<Fruit> treeSet = new TreeSet<Fruit>(new DescendingComparator()); // 내림차순 정렬자
        treeSet.add(new Fruit("포도", 3000));
        treeSet.add(new Fruit("수박", 10000));
        treeSet.add(new Fruit("딸기", 6000));
        Iterator<Fruit> iterator = treeSet.iterator();
        while (iterator.hasNext()){
            Fruit fruit = iterator.next();
            System.out.println(fruit.name + ":" + fruit.price);
        }
    }
}
//
수박:10000
딸기:6000
포도:3000
```





## 15.6 LIFO와 FIFO 컬렉션

---

### Stack (LIFO)

후입선출 : 나중에 넣은 객체가 먼저 빠져나가는 자료구조 ex) JVM 스택 메모리 , 스택 메모리에 저장된 변수는 나중에 저장된 것부터 제거된다.

![다운로드 (8)](C:\Users\user\Downloads\다운로드 (8).png)

| 리턴 타입 | 메소드       | 설명                                                         |
| --------- | ------------ | ------------------------------------------------------------ |
| E         | push(E item) | 주어진 객체를 스택에 넣는다                                  |
| E         | peek()       | 스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거하지 않는다. |
| E         | pop()        | 스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거한다.      |



스택의 생성

``` java
Stack<E> stack = new Stack<E>();
```



동전 케이스를 구현한 예시

``` java
public class Coin {
    private int value;

    public Coin(int value){
        this.value = value;
    }

    public int getValue(){
        return value;
    }
}
```

``` java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args){
        Stack<Coin> coinBox = new Stack<Coin>();

        coinBox.push(new Coin(100));
        coinBox.push(new Coin(50));
        coinBox.push(new Coin(500));
        coinBox.push(new Coin(10));

        while(!coinBox.isEmpty()){
            Coin coin = coinBox.pop();
            System.out.println("꺼내온 동전: " + coin.getValue() + "원");
        }
    }
}
// push한 순서의 역순으로 pop된다.
꺼내온 동전: 10원
꺼내온 동전: 500원
꺼내온 동전: 50원
꺼내온 동전: 100원
```



### Queue (FIFO)

선입선출 : 먼저 넣은 객체가 먼저 빠져나가는 자료구조 ex) 스레드풀, 먼저 들어온 작업부터 처리한다.

![다운로드 (9)](C:\Users\user\Downloads\다운로드 (9).png)

| 리턴 타입 | 메소드     | 설명                                                 |
| --------- | ---------- | ---------------------------------------------------- |
| boolean   | offer(E e) | 주어진 객체를 넣는다.                                |
| E         | peek()     | 객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다. |
| E         | poll()     | 객체 하나를 가져온다. 객체를 큐에서 제거한다.        |



Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다.

``` java
Queue<E> queue = new LinkedList<E>(); // LinkedList를 Queue 인터페이스 타입으로 변환
```



``` java
public class Message {
    public String command;
    public String to;

    public Message(String command,String to){
        this.command = command;
        this.to = to;
    }
}
```

``` java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args){
        Queue<Message> messageQueue = new LinkedList<Message>();

        messageQueue.offer(new Message("sendMail","홍길동"));
        messageQueue.offer(new Message("sendSMS","신용권"));
        messageQueue.offer(new Message("sendKakaotalk","홍두께"));

        while(!messageQueue.isEmpty()){
            Message message = messageQueue.poll();
            switch (message.command){
                case "sendMail":
                    System.out.println(message.to + "님에게 메일을 보냅니다.");
                    break;
                case "sendSMS":
                    System.out.println(message.to + "님에게 SMS를 보냅니다.");
                    break;
                case "sendKakaotalk":
                    System.out.println(message.to + "님에게 카카오톡을 보냅니다.");
                    break;
            }
        }
    }
}
//
홍길동님에게 메일을 보냅니다.
신용권님에게 SMS를 보냅니다.
홍두께님에게 카카오톡을 보냅니다.
```



## 15.7 동기화된 컬렉션

---

컬렉션 프레임워크의 대두분의 클래스들은 "싱글 스레드" 환경에서 사용할 수 있도록 설계되어있다.

=> 위에서 Vector와 Hashtable은 동기화된 메소드로 구성되어 있어 안전하지만

​	다른 클래스들은 동기화된 메소드로 구성되어있지 않아 멀티 스레드환경에서 안전하지 않다.



따라서 비동기화된 메소드를 "동기화된 메소드로 래핑"하는 Collections와 synchronizedXXX() 메소드가 있다.

| 리턴 타입 | 메소드(매개 변수)               | 설명                        |
| --------- | ------------------------------- | --------------------------- |
| List\<T>  | synchronizedList(List\<T> list) | List를 동기화된 List로 리턴 |
| Map<K,V>  | synchronizedMap(Map<K,V> m)     | Map을 동기화된 Map으로 리턴 |
| Set\<T>   | synchronizedSet(Set\<T> s)      | Set을 동기화된 Set으로 리턴 |



사용 예시

``` java
List<T> list = Collections.synchronizedList(new ArrayList<T>()); // ArrayList를 동기화
Set<E> set = Collections.synchronizedSet(new HashSet<E>()); // HashSet을 동기화
Map<K,V> map = Collections.synchronizedMap(new HashMap<K,V>()); // HashMap을 동기화
```



## 15.8 병렬 처리를 위한 컬렉션

---

동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만, 전체 요소를 빠르게 처리하지는 못한다.

=> 하나의 스레드가 요소를 처리하면 다른 스레드는 대기 상태가 되기 때문



자바는 멀티 스레드가 컬렉션의 요소를 병렬적으로 처리할 수 있도록 특별한 컬렉션을 제공한다.!!

=> java.util.concurrent 패키지의 ConcurrentHashMap과 ConcurrentLinkedQueue가 있다.



1) ConcurrentHashMap

- 스레드에 안전하면서도 멀티 스레드가 병력적으로 요소를 처리할 수 있다.(부분 잠금)
  - 부분 잠금이란? 처리하는 요소가 포함된 부분만 잠금하고 나머지 부분은 다른 스레드가 변경할 수 있도록 하는 것.
- ConcurrentHashMap 객체를 생성하는 코드

``` java
Map<K, V> map = new ConcurrentHashMap<K, V>();
```



2) ConcurrentLinkedQueue

- 락-프리 알고리즘을 구현한 컬렉션
  - 락-프리 알고리즘이란? 여러 개의 스레드가 동시에 접근할 경우, 잠금을 사용하지 않고도 최소한 하나의 스레드가 안전하게 요소를 저장하거나 얻도록 해주는 것.
- ConcurrentLinkedQueue객체를 생성하는 코드

``` java
Queue<E> queue = new ConcurrentLinkedQueue<E>();
```





