# 11장. 기본 API 클래스

---



## 11.1 자바 API 도큐먼트 

---

  API란? 

- 프로그램개발에 자주사용되는 클래스 및 인터페이스의 모음이다.  
- 라이브러리라고도 부른다.
- \jre\lib\rt.jar 이라는 압축파일에 저장되어 있다.



API도큐먼트란? 

- API를 찾아 이용할 수 있도록 문서화를 한 것이다.
- 세 개의 프레임으로 나눠져있다.
  - 좌측 상단, 패키지 전체 목록을 보여줌
  - 좌측 하단, 패키지에 속하는 클래스와 인터페이스 목록을 보여줌.
  - 중앙, 좌측 하단 프레임에서 선택한 클래스나 인터페이스에 대한 상세 설명을 보여줌.
    - 중앙 프레임의 상단은, 클래스가 포함된 패키지 정보, 상속 정보, 인터페이스 구현 정보를 표시
    - 중앙은, 클래스의 설명과 사용 방법
    - 하단은, 필드와 생성자, 메소드의 목록



## 11.2 java.lang과 java.util 패키지 

---

자바 애플리케이션을 개발할 때 가장 많이 사용하는 패키지

-> java.lang / java.util / java.time

### java.lang 패키지

java.lang 패키지란?

- 자바 프로그램의 기본적인 클래스를 담고 있는 패키지이다.

- import없이 사용할 수 있다.

| 클래스                      |                                                              | 용도                                                         |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Object                      |                                                              | - 자바 클래스의 최상위 클래스로 사용                         |
| System                      |                                                              | - 표준 입력 장치로부터 데이터를 입력받을 때 사용 <br>- 표준 입력 장치로 출력하기 위해 사용<br/> - 자바 가상 기계를 종료시킬 때 사용<br/> - 쓰레기 수집기를 실행 요철할 때 사용 |
| Class                       |                                                              | - 클래스를 메모리로 로딩할 때 사용                           |
| String                      |                                                              | - 문자열을 저장하고 여러 가지 정보를 얻을 때 사용            |
| StringBuffer, StringBuilder |                                                              | - 문자열을 저장하고 내부 문자열을 조작할 때 사용             |
| Math                        |                                                              | - 수학 점수를 이용할 때 사용                                 |
| Wrapper                     | Byte, Short, Character, Integerm Float, Double, Boolean, Long | - 기본 타빙의 데이터를 갖는 객체를 만들 때 사용<br/>- 문자열을 기본 타입으로 변환할 때 사용<br/>- 입력값 검사에 사용 |

### java.util 패키지

java.util 패키지란?

- 자바 프로그램 개발에 조미료같은 역할을 하는 클래스를 담고있다.
- 컬렉션 클래스들이 대부분을 차지하고 있다.

| 클래스          | 용도                                         |
| --------------- | -------------------------------------------- |
| Arrays          | - 배열을 조작할 때 사용                      |
| Calender        | - 운영체제의 날짜와 시간을 얻을 때 사용      |
| Date            | - 날짜와 시간 정보를 저장하는 클래스         |
| Object          | - 객체 비교, 널 여부 등을 조사할 때 사용     |
| StringTokenizer | - 특정 문자로 구분된 문자열을 뽑아낼 때 사용 |
| Random          | - 난수를 얻을 때 사용                        |



## 11.3 Object 클래스

---

자바에서는 extends 키워드로 다른 클래스를 상속하지 않으면 java.lang.Object 클래스를 상속한다.

-> 따라서 자바의 모든 클래스는 Object클래스의 자식이거나 자손 클래스이고 Object는 최상위 부모 클래스이다.

### 객체 비교 (equals())

``` java
public boolean equals(Object obj){...}
```

- 매개 타입이 Object -> 모든 객체가 매개값으로 대입될 수 있음을 뜻함.
- 비교 연산자인  ==와 동일한 결과를 리턴한다.

``` java
Object obj1 = new Object();
Object obj2 = new Object();

boolean result = obj1.equals(obj2);

boolean result = (obj1 == obj2); //결과가 동일
```

자바에서의 equals 메소드는 객체가 저장하고 있는 데이터가 동일한지를 조사한다.

- String 타입의 경우 객체의 번지를 비교하는게 아니라 객체의 문자열을 비교한다. -> String 클래스가 Object 클래스의 equals() 메소드를 오버라이딩했기 때문



``` java
public class Member{
    public String id;

    public Member(String id){
        this.id = id;
    }
    @Override
    public boolean equals(Object obj){ // equals 메소드의 오버라이딩
        if(obj instanceof Member){ // 기준 객체가 동일한 타입인지 확인해 줘야 한다.
            Member member = (Member) obj; // Member타입으로 강제 타입 변환하고 id 필드값이 동일한지 검사, 동일하면 true
            if(id.equals(member.id)){
                return true;
            }
        }
        return false; // Member타입이 아니거나 동일하지 않으면 false
    }
}
```

``` java
public class MemberExample{
    public static void main(String[] args){
        Member obj1 = new Member("blue");
        Member obj2 = new Member("blue");
        Member obj3 = new Member("red");

        if(obj1.equals(obj2)){
            System.out.println("obj1 == obj2");
        }
        else{
            System.out.println("obj1 /= obj2");
        }

        if(obj1.equals(obj3)){
            System.out.println("obj1 == obj3");
        }
        else{
            System.out.println("obj1 /= obj3");
        }
    }
}
//
obj1 == obj2
obj1 /= obj3
```



### 객체 해시코드(hashCode()) 

해시코드란? 객체를 식별할 하나의 정수 값을 뜻함.

- Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체마다 다른 값을 가짐
- hashCode() 메소드는 객체 동등 비교를 할 때 사용

![다운로드](C:\Users\user\Downloads\다운로드.png)

``` java
public class Key{
    public int number;
    
    public Key (int number){
        this.number = number;
    }
    
    @Override // number의 필드값이 같으면 true를 리턴하도록 오버라이딩
    public boolean equals(Object obj){
        if(obj instanceof Key){
            Key compareKey = (Key) obj;
            if(this.number == compareKey.number){
                return true;
            }
        }
        return false;
    }
}
```

``` java 
public class KeyExample{
    public static void main(String[] args){
        // Key 객체를 식별키로 사용해서 String 값을 저장하는 HashMap 객체를 생성
        HashMap<Key,String> hashMap = new HashMap<Key,String>();
        
        // 식별키 "new Key(1)"로 홍길동" 을 저장함
        hashMap.put(new Key(1),"홍길동");
        
        // 식별키 "new Key(1)"로 "홍길동"을 읽어옴
        String value = hashMap.get(new Key(1));
        System.out.println(value);
    }
}
//
null
```

-> 이 경우 number필드값이 같더라도 hashCode()에서 리턴하는 해시 코드가 다르기 때문에 다른 식별키로 인식되기 때문에 hashMap의 식별키로 Key객체를 사용해서 저장된 값을 찾아오지 못한다.

따라서 아래의 코드를 추가해줘야 한다.

``` java
public class Key{
    ...
    @Override
    public int hashCode(){
        return number;
    }
}
```

-> 저장할 때의 new Key(1)과 읽을 때의 new Key(1)은 서로 다른 객체이지만 HashMap은 hashCode()의 리턴값이 같고,  equals 리턴값이 true가 나오기 때문에 동등 객체가 된다.

---> 객체의 동듭 비교를 위해서는 Object의 equals() 메소드만 재정의하지 말고 hashCode()의 메소드도 재정의해야 한다.!!



``` java
public class Member{
    public String id;

    public Member(String id){
        this.id = id;
    }
    @Override
    public boolean equals(Object obj){ 
        if(obj instanceof Member){
            Member member = (Member) obj; 
            if(id.equals(member.id)){
                return true;
            }
        }
        return false;
    }
    
    @Override //id가 동일한 문자열일 경우 같은 해시코드를 리턴
    public int hashCode(){
        return id.hashCode();
    }
}
```



### 객체 문자 정보(toString()) 

객체의 문자 정보를 리턴해준다.(객체를 문자열로 표현한 값을 뜻함)

``` java
Object obj = new Object();
System.out.println(obj.toString()); // java.lang.Object@de6ced
```

-> Object의 toString() 메소드의 리턴값은 별 값어치가 없고, 하위 클래스들에서 toString() 메소드를 오버라이딩해서 간단하게 정보를 리턴하게 되어있다.



``` java
import java.util.Date;

public class ToStringExample {
    public static void main(String[] args){
        Object obj1 = new Object();
        Date obj2 = new Date();
        System.out.println(obj1.toString());
        System.out.println(obj2.toString());
    }
}
//
java.lang.Object@1b6d3586
Wed Feb 17 09:34:04 KST 2021
```



``` java
public class SmartPhone {
    private String company;
    private String os;

    public SmartPhone(String company, String os){
        this.company = company;
        this.os = os;
    }

    @Override
    public String toString() {
        return company + ", " + os;
    }
}
```

``` java
public class SmartPhoneExample {
    public static void main(String[] args){
        SmartPhone myPhone = new SmartPhone("구글", "안드로이드");
        
        String strObj = myPhone.toString();
        System.out.println(strObj);
        
        System.out.println(myPhone);
    }
}
//
구글, 안드로이드
구글, 안드로이드
```

-> 우리가 println() 메소드의 매개값으로 객체를 주면 객체의 toString() 메소드를 호출해서 리턴값을 받아 출력하게 되어있다.!



### 객체 복사(clone())

원본 객체의 필드값과 동일한 값을 가지는 새로운 객체를 생성하는 것

원본 객체를 안전하게 보호하기 위해서사욯된다.

​	->신뢰하지 않는 영역으로 원본 객체를 넘겨 작업해야 할 경우 데이터가 훼손될 수도 있기 때문이다.

#### 얕은 복제(this clone)

필드값만 복사해서 객체를 복제하는 것.

- 필드가 기본 타입일 경우 값 복사
- 필드가 참조 타입일 경우 번지가 복사된다.



Object의 clone()메소드는 자신과 동일한 필드값을 가진 얕은 복제된 객체를 리턴한다.

- 이 메소드로 객체를 복제하려면 java.lang.Cloneable 인터페이스를 구현하고 있어야 한다.
  - 클래스 설계자가 복제를 허용한다는 의미.
- Cloneable인터페이스를 구현하지 않으면 CloneNotSupportedException 예외가 발생.

```java
try{
    Object obj = clone();
}catch(CloneNotSupportedException e){} // 예외 처리 문
```



``` java
public class Member_ implements Cloneable{
    public String id;
    public String name;
    public String password;
    public int age;
    public boolean adult;

    public Member_(String id, String name, String password, int age, boolean adult){
        this.id = id;
        this.name = name;
        this.password = password;
        this.age = age;
        this.adult = adult;
    }

    public Member_ getMember(){
        Member_ cloned = null;

        try{
            cloned = (Member_) clone();
        }catch (CloneNotSupportedException e){}
        return cloned;
    }
}
```

``` java
public class Member_Example {
    public static void main(String[] args){
        // 원본 객체 생성
        Member_ original = new Member_("blue","홍길동","12345",25,true);
        
        // 복제 객체를 얻은 후에 패스워드 변경
        Member_ cloned = original.getMember();
        cloned.password = "67890";
        
        System.out.println("[복제 객체의 필드값]");
        System.out.println("id: " + cloned.id);
        System.out.println("name: " + cloned.name);
        System.out.println("password: " + cloned.password);
        System.out.println("age: " + cloned.age);
        System.out.println("adult: " + cloned.adult);
        
        System.out.println();

        System.out.println("[원본 객체의 필드값]");
        System.out.println("id: " + original.id);
        System.out.println("name: " + original.name);
        System.out.println("password: " + original.password);
        System.out.println("age: " + original.age);
        System.out.println("adult: " + original.adult);
    }
}
//
id: blue
name: 홍길동
password: 67890
age: 25
adult: true

[원본 객체의 필드값]
id: blue
name: 홍길동
password: 12345
age: 25
adult: true
```

#### 깊은 복제(deep clone)

참조하고 있는 객체도 복제하는 것.

- 깊은 복제를 위해선 Object의 clone() 메소드를 재정의해서 참조 객체를 복제하는 코드를 직접 작성해야 한다.

``` java
public class Car {
    public String model;

    public Car(String model){
        this.model = model;
    }
}
```

``` java
import java.util.Arrays;

public class Member__ implements Cloneable{
    public String name;
    public int age;
    public int[] scores;
    public Car car;

    public Member__(String name, int age, int[] scores, Car car){
        this.name = name;
        this.age = age;
        this.scores = scores;
        this.car = car;
    }

    @Override // clone메소드 재정의
    protected Object clone() throws CloneNotSupportedException{
        // 먼저 얕은 복사를 해서 name, age를 복사한다.
        Member__ cloned = (Member__) super.clone();
        // scores를 깊은 복제한다.
        cloned.scores = Arrays.copyOf(this.scores,this.scores.length);
        // car를 깊은 복제한다.
        cloned.car = new Car(this.car.model);
        // 깊은 복제된 Member객체를 리턴
        return cloned;
    }

    public Member__ getMember(){
        Member__ cloned = null;
        try{
            cloned = (Member__) clone(); // 재정의된 clone() 메소드 호출
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return cloned;
    }
}
```

``` java
public class Member__Example {
    public static void main(String args[]){
        // 원복 객체 생성
        Member__ orginal = new Member__("홍길동", 25,new int[]{90,90},new Car("소나타"));

        // 복제 객체를 얻은 후에 참조 객체의 값을 변경
        Member__ cloned = orginal.getMember(); // 깊은 복제 후 참조 객체의 데이터를 변경
        cloned.scores[0] = 100;
        cloned.car.model = "그렌져";

        System.out.println("[복제 객체의 필드값]");
        System.out.println("name: " + cloned.name);
        System.out.println("age: " + cloned.age);
        System.out.println("scores: {");
        for (int i = 0;i<cloned.scores.length;i++){
            System.out.println(cloned.scores[i]);
            System.out.println((i==(cloned.scores.length-1))?"":",");
        }
        System.out.println("}");
        System.out.println("car: " + cloned.car.model);

        System.out.println();

        System.out.println("[원본 객체의 필드값]");
        System.out.println("name: " + orginal.name);
        System.out.println("age: " + orginal.age);
        System.out.println("scores: {");
        for (int i = 0;i<orginal.scores.length;i++){
            System.out.println(orginal.scores[i]);
            System.out.println((i==(orginal.scores.length-1))?"":",");
        }
        System.out.println("}");
        System.out.println("car: " + orginal.car.model);
    }
}
//
[복제 객체의 필드값]
name: 홍길동
age: 25
scores: {100,90}
car: 그렌져

[원본 객체의 필드값]
name: 홍길동
age: 25
scores: {90,90}
car: 소나타
```



### 객체 소멸자(finalize())

참조하지 않는 객체는 쓰레기 수집기가 힙 영역에서 자동으로 소멸시킨다.

-> 이때 객체를 소멸하기 전에 객체의 소멸자를 실행시킨다(finalize())

- 이 소멸자는 Object의 finalize() 메소드를 말함.
- 객체가 소멸되기 전에 마지막으로 사용했던 자원을 닫거나, 중요한 내용을 저장하고 싶으면 재정의 할 수 있다.

``` java
public class Counter {
    private int no;

    public Counter(int no){
        this.no = no;
    }
    @Override
    protected void finalize() throws Throwable{
        System.out.println(no + "번 객체의 finalize()가 실행됨");
    }
}
```

``` java
public class FinalizeExample {
    public static void main(String[] args){
        Counter counter = null;
        for(int i = 1; i<= 50; i++){
            counter = new Counter(i);
            
            counter = null; // counter 객체를 쓰레기로 만듬
            
            System.gc(); // 쓰레기 수집기 요청
        }
    }
}
```

-> 쓰레기 수집기는 메모리의 상태를 보고 일부만 소멸시키기 때문에 finalize() 메소드가 호출되는 시점은 명확하지 않다.

## 11.4 Objects 클래스 

---

Objects 클래스가 가지고 있는 정적 메소드 표

| 리턴 타입 | 메소드(매개 변수)                                          | 설명                                                         |
| --------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| int       | compare(T a, T b, Comparator<T> c)                         | 두 객체 a와 b를 Comparator를 사용해서 비교                   |
| boolean   | deepEqauls(Object a, Object b)                             | 두 객체의 깊은 비교- 배열의 항목까지도                       |
| boolean   | equals(Object a, Object b)                                 | 두 객체의 얕은 비교- 번지만                                  |
| int       | hash(Object... values)                                     | 매개값이 저장된 배열의 해시코드 생성                         |
| int       | hashCode(Object o)                                         | 객체의 해시코드 생성                                         |
| boolean   | isNull(Object obj)                                         | 객체가 null인지 조사                                         |
| boolean   | nonNull(Object obj)                                        | 객체가 null이 아닌지 조사                                    |
| T         | requireNonNull(T obj)                                      | 객체가 null인 경우 예외 발생                                 |
| T         | requireNonNull(T obj,<br/>String message)                  | 객체가 null인 경우 예외 발생(주어진 예외 메시지 표함)        |
| T         | requireNonNull(T obj,<br/>Supplier<String>messageSupplier) | 객체가 null인 경우 예외 발생(람다식이 만든 예외 메시지 포함) |
| String    | toString(Object o)                                         | 객체의 toString() 리턴값 리턴                                |
| String    | toString(Object o,String nullDefault)                      | 객체의 toSTring() 리턴값 리턴, 첫 번째 매개값이 null일 경우 두 번째 매개값 리턴 |

### 객체 비교(compare(T a, T b, Comparator<T\>c))

Objects.compare(T a, T b, Comparator<T>c) 메소드는 두가지 비교자로 비교해서 int값을 리턴한다.

``` java
public interface Comparaotr<T>{ // 제네릭 타입은 13장에서 학습- T는 비교할 객체 타입
    int compare(T a, T b);
}
```



``` java
public class StudentComparator implements Comparator<Student>{ // Comparator인터페이스를 상속해
    @Override // compare 오버라이딩
    public int compare(Student a, Student b){
        if(a.sno<b.sno) return -1;
        else if(a.sno == b.sno) return 0;
        else return  -1;
    }
}
```

``` java
import java.util.Objects;

public class CompareExample {
    public static void main(String[] args){
        Student s1 = new Student(1);
        Student s2 = new Student(1);
        Student s3 = new Student(2);
        
        int result = Objects.compare(s1,s2,new StudentComparator()); // v
        System.out.println(result);
        result = Objects.compare(s1,s3,new StudentComparator()); // v
    }
    
    static class Student{
        int sno;
        Student(int sno){
            this.sno = sno;
        }
    }
    
    static class StudentComparator implements Comparator<Student>{
        @Override
        public int compare(Student o1,Student o2){
            /*if(o1.sno<o2.sno) return -1;
            else if(o1.sno == o2.sno)return 0;
            else return 1;
             */
            return Integer.compare(o1.sno,o2.sno);
        }
    }
}
```



### 동등 비교(equals()와 deepEquals())

Objects.equals(Object a, Object b)는 두 객체의 동등을 비교한다.

- a와b가 둘다 null일 경우 true를 리턴
- a와b가 null이 아닌경우 a.equals() 의 결과를 리턴.

| a        | b        | Objects.equals(a,b)  |
| -------- | -------- | -------------------- |
| not null | not null | a.equals(b)의 리턴값 |
| null     | not null | false                |
| not null | null     | false                |
| null     | null     | true                 |

Objects.deepEquals(Object a, Object b)또한 두 객체의 동등을 비교

- a와b가 서로 다른 배열일 경우 , 항목 값이 모두 같다면 true를 리턴

- Arrays.deepEquals(Object[] a, Object[] b) 와 동일

| a                   | b                   | Objects.deepEquals(a, b)        |
| ------------------- | ------------------- | ------------------------------- |
| not null(not array) | not null(not array) | a.equals(b)의 리턴값            |
| not null(array)     | not null(array)     | Arrays.deepEquals(a,b)의 리턴값 |
| not null            | null                | false                           |
| null                | not null            | false                           |
| null                | null                | true                            |



``` java
import java.util.Arrays;
import java.util.Objects;

public class EqualsAndDeepEqualsExample {
    public static void main(String args[]){
        Integer o1 = 1000;
        Integer o2 = 1000;
        System.out.println(Objects.equals(o1,o2));
        System.out.println(Objects.equals(o1,null));
        System.out.println(Objects.equals(null,o2));
        System.out.println(Objects.equals(null,null));
        System.out.println(Objects.deepEquals(o1,o2) + "\n");
        
        Integer[] arr1 = {1,2};
        Integer[] arr2 = {1,2};
        System.out.println(Objects.equals(arr1,arr2));
        System.out.println(Objects.deepEquals(arr1,arr2));
        System.out.println(Arrays.deepEquals(arr1,arr2));
        System.out.println(Objects.deepEquals(null,arr2));
        System.out.println(Objects.deepEquals(arr1,null));
        System.out.println(Objects.deepEquals(null,null));
    }
}
//
true
false
false
true
true

false
true
true
false
false
true
```



### 해시 코드(hash(), hashCode())

Objects.hash() 메소드는 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을 한다.

- 주어진 매개값들로 배열을 생성하고 Arrays.hashCode(Object[]) 를 호출해서 해시 코드를 얻고 이 값을 리턴한다.
- 클래스가 여러 가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면 동일한 필드값을 가지는 객체는 동일한 해시 코드를 가질 수 있다.

``` java
@Override
public int hashCode(){
    return Objcets.hash(field1, field2, field3);
}
```

Objects.hashCode() 메소드는 매개값으로 주어진 객체의 해시코드를 리턴하기 때문에 o.hashCode()의 리턴값과 동일하다.

- 차이점은 매개값이 null이면 0을 리턴한다.

``` java
import java.util.Objects;

public class HashCodeExample {
    public static void main(String[] args){
        Student s1 = new Student(1,"홍길동");
        Student s2 = new Student(1,"홍길동");
        System.out.println(s1.hashCode());
        System.out.println(Objects.hashCode(s2));
    }
    
    static class Student{
        int sno;
        String name;
        Student(int sno, String name){
            this.sno = sno;
            this.name = name;
        }
        @Override
        public int hashCode(){
            return Objects.hash(sno,name); // 학생 번호와 이름이 동일하면 같은 해시 코드를 리턴.
        }
    }
}
//
54151054
54151054
```



### 널 여부 조사(isNull(), nonNull(), requireNonNull())

isNull은 매개값이 null일 경우 true를 리턴

nonNull은 매개값이 not null일 경우 true를 리턴

requireNonNull은 아래 표처럼 오버라이딩 되어있다.

| 리턴 타입 | 메소드(매개 변수)                                     | 설명                                                         |
| --------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| T         | requireNonNull(T obj)                                 | not null -> obj<br/>null-> NullPointerException              |
| T         | requireNonNull(T obj,<br>String message)              | not null -> obj<br/>null-> NullPointerException(message)     |
| T         | requireNonNull(T obj<br>Supplier<String> msgSupplier) | not null -> obj<br/>null -> NullPointerException(msgSupplier.get()) |

첫 번째 매개값이 not null이면 첫 번째 매개값을 리턴하고, null이면 모두 NullPointerException을 발생

두 번째 매개값은 NullPointerException의 예외 메시지를 제공한다.

``` java
import java.util.Objects;

public class NullExample {
    public static void main(String args[]){
        String str1 = "홍길동";
        String str2 = null;
        
        System.out.println(Objects.requireNonNull(str1));
        
        try{
            String name = Objects.requireNonNull(str2);
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        
        try {
            String name = Objects.requireNonNull(str2, "이름이 없습니다.");
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        
        try{
            String name = Objects.requireNonNull(str2, ()->"이름이 없다니깐요");
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
    }
}
//
홍길동
null
이름이 없습니다.
이름이 없다니깐요
```



### 객체 문자 정보 (toString())

toString()은 객체의 문자 정보를 리턴

| 리턴 타입 | 메소드(매개 변수)                      | 설명                                            |
| --------- | -------------------------------------- | ----------------------------------------------- |
| String    | toString(Objcet o)                     | not null -> o.toString()<br>not -> "null"       |
| String    | toString(Objcet o, String nullDefault) | not null -> o.toString()<br>null -> nullDefault |

첫 번째 매개값이 

not null이면 toString()으로 얻은 값을 리턴

null이면 "null"또는 두 번째 매개값인 nullDefault를 리턴

``` java
import java.util.Objects;

public class ToStringExample_ {
    public static void main(String args[]){
        String str1 = "홍길동";
        String str2 = null;
        
        System.out.println(Objects.toString(str1));
        System.out.println(Objects.toString(str2));
        System.out.println(Objects.toString(str2, "이름이 없습니다."));
    }
}
//
홍길동
null
이름이 없습니다.
```



## 11.5 System 클래스 

---

System클래스란?

- java 프로그램은 운영체제상에서 실행되는게 아니라 JVM 위에서 실행된다. 따라서 자바 코드로 운영체제의 기능에 접근하기 어렵다

  -> java.lang 패키지의 System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있다!



System클래스의 특징

- System 클래스의 모든 필드와 메소드는 정적으로 구성되어 있다.



### 프로그램 종료(exit()) 

강제적으로 JVM을 종료하기 위함.

``` java
System.exit(0); // ()안의 int값을 "종료 상태값" 이라고 함. 정상 종료시 0, 비정상 종료시 다른 값을 준다.
```



특정 값이 입력되었을 경우에만 종료하고 싶을 경우 자바의 "보안 관리자"를 직접 설정해서 종료 상태값을 확인하면 된다.

```java
System.setSecurityManager(new SecurityManager(){
    @Override
    public void checkExit(int status){ // exit()메소드가 실행되면 자동으로 호출되는 checkExit()메소드를 오버라이딩 했다.
        if(status != 5 ){  // 5가 입력되면
            throw new SecurityException(); // 예외처리
        }
    }
});
```



``` java
import java.lang.System;

public class ExitExample {
    public static void main(String args[]){
        // 보안 관리자 설정
        System.setSecurityManager(new SecurityManager(){
            @Override
            public void checkExit(int status){
                if(status != 5){
                    throw new SecurityException();
                }
            }
        });


        for (int i = 0; i<10;i++){
            // i값 출력
            System.out.println(i);
            try{
                //JVM 종료 요청
                System.exit(i);
            }catch (SecurityException e){}
        }
    }
}
//
0
1
2
3
4
5
```



### 쓰레기 수집기 실행(gc()) 

자바에서는 사용하지 않는 객체를 자동으로 제거하는 "쓰레기 수집기"가 자동으로 메모리를 관리해 준다.

```java
System.gc();
```

위 메소드를 호출하면 바로 쓰레기 수집기가 실행되는 것이 아니라, JVM이 빠른 시간 내에 실행시키기 위해 노력한다.!

- 쓰레기 수집기가 실행되면 정작 수행되어야 할 프로그램의 속도가 떨어지기 때문에 메모리가 충분하면 실행할 필요가 없다.



``` java
public class GcExample {
    public static void main(String args[]){
        Employee emp;
        
        emp = new Employee(1); // 쓰레기가 됨
        emp = null;
        emp = new Employee(2); // 쓰레기가 됨
        emp = new Employee(3);
        
        System.out.println("emp가 최종적으로 참조하는 사원번호: ");
        System.out.println(emp.eno);
        System.gc(); // 쓰레기 수집기 실행 요청
    }
    
    static class Employee{
        public int eno;
        
        public Employee(int eno) {
            this.eno = eno;
            System.out.println("Employee(" + eno + ") 가 메모리에 생성됨");
        }
        
        public void finalize(){ // 소멸자
            System.out.println("Employee(" + eno + ") 가 메모리에서 제거됨");
        }
    }
}
//
Employee(1) 가 메모리에 생성됨
Employee(2) 가 메모리에 생성됨
Employee(3) 가 메모리에 생성됨
emp가 최종적으로 참조하는 사원번호:3
Employee(2) 가 메모리에서 제거됨
Employee(1) 가 메모리에서 제거됨
```



### 현재 시각 읽기(currentTimeMillis(),nanoTime()) 

컴퓨터 시계로 부터 현재 시간을 읽어 1/1000초 단위와 1/10^9 초 단위의 long값을 리턴해 준다.

``` java
long time = System.currentTimeMills();
long time = System.nanoTime();
```



``` java
public class SystemTimeExample {
    public static void main(String[] args){
        long time1 = System.nanoTime(); // 시작 시간 읽기
        
        int sum = 0;
        for(int i = 1;i <= 1000000; i++){
            sum += i;
        }
        
        long time2 = System.nanoTime(); // 끝 시간 읽기
        
        System.out.println("1~1000000까지의 합: " + sum);
        System.out.println("계산에 " + (time2-time1) + " 나노초가 소요되었습니.");
    }
}
//
1~1000000까지의 합: 1784293664
계산에 3316200 나노초가 소요되었습니다.
```



### 시스템 프로퍼티 읽기(getProperty()) 

시스템 프로퍼티란?

- JVM이 시작할 때 자동으로 설정되는 시스템의 속성값이다.
- 키와 값으로 구성되어 있다.

| 키(key)        | 설명                                  | 값(value)           |
| -------------- | ------------------------------------- | ------------------- |
| java.version   | 자바의 버전                           | 1.8.0_20            |
| java.home      | 사용하는 JRE 의 파일 경로             | <jdk 설치경로>\jre  |
| os.name        | Operating system name                 | Windows 7           |
| file.separator | Fild separator("/" on UNIX)           | \                   |
| user.name      | 사용자의 이름                         | 사용자계정          |
| user.home      | 사용자의 홈 디렉토리                  | C:\Users\사용자계정 |
| user.dir       | 사용자가 현재 작업 중인 디렉토리 경로 | 다양                |



시스템 프로퍼티를 읽어오기 위한 메소드이다.

``` java
String value = System.getProperty(String key); // 키 이름을 매개값으로 받아, 해당 키에 대한 값을 문자열로 리턴한다.
```



``` java
import java.util.Properties;
import java.util.Set;

public class GetPropertyExample {
    public static void main(String args[]){
        String osName = System.getProperty("os.name");
        String userName = System.getProperty("user.name");
        String userHome = System.getProperty("user.home");
        
        System.out.println("운영체제 이름: " + osName); // 개별 속성 읽기
        System.out.println("사용자 이름: " + userName);
        System.out.println("사용자 홈 디렉토리: " + userHome);
        
        System.out.println("----");
        System.out.println(" [key] value");
        System.out.println("----");

        Properties props = System.getProperties(); // (키,값) 쌍을 저장하고 있는 Properties 객체를 리턴한다.
        Set keys = props.keySet(); // 키만으로 구성된 Set 객체를 얻을 수 있다.
        for(Object objKey : keys){ // 모든 속성의 키 값와 값을 출력 
            String key = (String) objKey;
            String value = System.getProperty(key);
            System.out.println("[ " + key + "]  " + value);
        }
    }
}
//
운영체제 이름: Windows 10
사용자 이름: heeyoung
사용자 홈 디렉토리: C:\Users\user
----
 [key] value
----
[ java.runtime.name]  Java(TM) SE Runtime Environment
[ sun.boot.library.path]  C:\Program Files\Java\jdk1.8.0_271\jre\bin
[ java.vm.version]  25.271-b09
[ java.vm.vendor]  Oracle Corporation
[ java.vendor.url]  http://java.oracle.com/
[ path.separator]  ;
[ java.vm.name]  Java HotSpot(TM) 64-Bit Server VM
[ file.encoding.pkg]  sun.io
[ user.country]  KR
[ user.script]  
[ sun.java.launcher]  SUN_STANDARD
[ sun.os.patch.level]  
[ java.vm.specification.name]  Java Virtual Machine Specification
[ user.dir]  C:\Users\user\Desktop\study\java\javaTutorial
[ java.runtime.version]  1.8.0_271-b09
[ java.awt.graphicsenv]  sun.awt.Win32GraphicsEnvironment
[ java.endorsed.dirs]  C:\Program Files\Java\jdk1.8.0_271\jre\lib\endorsed
[ os.arch]  amd64
[ java.io.tmpdir]  C:\Users\user\AppData\Local\Temp\
[ line.separator]  

[ java.vm.specification.vendor]  Oracle Corporation
[ user.variant]  
[ os.name]  Windows 10
[ sun.jnu.encoding]  MS949
[ java.library.path]  C:\Program Files\Java\jdk1.8.0_271\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files\Git\cmd;C:\Program Files\dotnet\;C:\Program Files (x86)\dotnet\;C:\Users\user\AppData\Local\Microsoft\WindowsApps;C:\Program Files\Bandizip\;C:\Users\user\AppData\Local\Programs\Microsoft VS Code\bin;C:\Program Files (x86)\GitHub CLI\;C:\Users\user\.dotnet\tools;.
[ java.specification.name]  Java Platform API Specification
[ java.class.version]  52.0
[ sun.management.compiler]  HotSpot 64-Bit Tiered Compilers
[ os.version]  10.0
[ user.home]  C:\Users\user
[ user.timezone]  
[ java.awt.printerjob]  sun.awt.windows.WPrinterJob
[ file.encoding]  UTF-8
[ java.specification.version]  1.8
[ java.class.path]  C:\Program Files\Java\jdk1.8.0_271\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\rt.jar;C:\Users\user\Desktop\study\java\javaTutorial\out\production\javaTutorial;C:\Users\user\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\203.6682.168\lib\idea_rt.jar
[ user.name]  heeyoung
[ java.vm.specification.version]  1.8
[ sun.java.command]  ch11.GetPropertyExample
[ java.home]  C:\Program Files\Java\jdk1.8.0_271\jre
[ sun.arch.data.model]  64
[ user.language]  ko
[ java.specification.vendor]  Oracle Corporation
[ awt.toolkit]  sun.awt.windows.WToolkit
[ java.vm.info]  mixed mode
[ java.version]  1.8.0_271
[ java.ext.dirs]  C:\Program Files\Java\jdk1.8.0_271\jre\lib\ext;C:\Windows\Sun\Java\lib\ext
[ sun.boot.class.path]  C:\Program Files\Java\jdk1.8.0_271\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_271\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_271\jre\classes
[ java.vendor]  Oracle Corporation
[ file.separator]  \
[ java.vendor.url.bug]  http://bugreport.sun.com/bugreport/
[ sun.io.unicode.encoding]  UnicodeLittle
[ sun.cpu.endian]  little
[ sun.desktop]  windows
[ sun.cpu.isalist]  amd64
```



### 환경 변수 읽기(getenv()) 

- 프로그램상의 변수가 아니라 운영체제에서 이름과 값으로 관리되는 문자열 정보이다.
- 운영체제가 설치될 때 기본적인 내용이 설정되고, 사용자가 직접 설정하거나 응용프로그램이 설치될때 자동적으로 추가 설정된다.

환경 변수의 값이 필요할 경우 매개값으로 환경 변수 이름을 주면 값을 리턴하는 메소드이다.

``` java
String value = System.getenv(String name);
```



``` java
public class SystemEnvExample {
    public static void main(String args[]){
        String OS = System.getenv("OS");
        System.out.println("OS: "+OS);
    }
}
//
OS: Windows_NT
```



## 11.6 Class 클래스

---

자바는 클래스와 인터페이스의 메타 데이터를 java.lang 패키지에 소속된 Class 클래스로 관리한다.

메타 데이터란? 클래스의 이름, 생성자 정보, 필드 정보, 메소드 정보를 말함.

### Class 객체 얻기(getClass(), forName()) 

Class 객체를 얻기 위해 Object클래스의 getClass() 메소드를 이용.

``` java
class clazz = obj.getClass();
```



정적 메소드인 forName()메소드는 클래스 전체 이름을 매개값으로 받고 Class 객체를 리턴한다.

``` java
try{
    Class clazz = Class.forName(String className); 
} catch(ClassNotFoundException e){    // 매개값으로 주어진 클래스를 찾지 못할경우 발생하는 예외 처리
}
```



``` java
public class ClassExample {
    public static void main(String args[]){
        Car car = new Car();
        Class clazz1 = car.getClass();
        System.out.println(clazz1.getName()); // 전체 이름
        System.out.println(clazz1.getSimpleName()); // 간단한 이름
        System.out.println(clazz1.getPackage().getName()); // 패키지 이름
        System.out.println();
        
        try{
            Class clazz2 = Class.forName("ch11.Car");
            System.out.println(clazz2.getName());
            System.out.println(clazz2.getSimpleName());
            System.out.println(clazz2.getPackage().getName());
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
    }
}
//
ch11.Car 
Car
ch11

ch11.Car
Car
ch11
```



### 리플렉션(getDeclaredConstructors(), getDeclareFields(), getDeclaredMethods()) 

Class 객체를 이용하여 클래스의 생성자, 필드, 메소드 정보를 알애는 것.



- 세 클래스 모두 java.lang.reflect 패키지에 소속되어있다.

- etDeclaredFields(),getDecalredMethods() 는 클래스에 선언된 멤버만 가져오고 상속된 멤버는 가져오지 않는다.

  -> 상속된 멤버를 가져오고 싶으면 getFields(), getMethods()를 이용해야 한다.

``` java
Consturctor[] constructors = clazz.getDeclaredConstructors();
Field[] fields = clazz.getDeclaredFields();
Method[] methods = clazz.getDecalredMethods();
```



``` java
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectionExample {
    public static void main(String args[]) throws Exception{
        Class clazz = Class.forName("ch11.Car");

        System.out.println("[클래스 이름]");
        System.out.println(clazz.getName());
        System.out.println();

        System.out.println("[생성자 정보]");
        Constructor[] constructors = clazz.getConstructors();
        for(Constructor constructor : constructors){
            System.out.println(constructor.getName() + "(");
            Class[] parameters = constructor.getParameterTypes();
            printParameters(parameters);
            System.out.println(")");
        }
        System.out.println();

        System.out.println("[필드 정보]");
        Field[] fields = clazz.getDeclaredFields();
        for(Field field : fields){
            System.out.println(field.getType().getSimpleName() +
            " " + field.getName());
        }
        System.out.println();

        System.out.println("[메소드 정보]");
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods){
            System.out.println(method.getName() + "(");
            Class[] parameters = method.getParameterTypes();
            printParameters(parameters);
            System.out.println(")");
        }
    }

    private static void printParameters(Class[] parameters){
        for(int i=0;i<parameters.length;i++){
            System.out.println(parameters[i].getName());
            if(i<parameters.length-1) {
                System.out.println(",");
            }
        }
    }
}
//
[생성자 정보]
ch11.Car(
java.lang.String
)
ch11.Car(
)

[필드 정보]
String model

[메소드 정보]

```



### 동적 객체 생성(newInstance()) 

Class 객체를 이용하면 new 연산자를 사용하지 않고 동적으로 객체를 생성할 수 있다.

``` java
try{
    Class clazz = Class.forName("런타임 시 결정되는 클래스 이름"); // Class 객체를 얻고
    Object obj = clazz.newInstance(); // newInstance() 메소드를 호출하면 Object타입의 객체를 얻을 수 있다.
} catch (ClassNotFoundException e){
    
} catch (InstantiationException e){
    
} catch (IllegalAccessException e){
    
}
```

- newInstance() 메소드는 기본 생성자를 호출해서 객체를 생성하기 때문에 반드시 클래스에 기본 생성자가 존재해야 한다.

- 만약 매개변수가 있는 생성자를 호출하고 싶다면 Constructor 객체를 얻어 newInstance() 메소드를 호출하면 된다.

- newInstance()의 두가지 예외
  - InstantiationException -> 해당 클래스가 추상 클래스이거나 인터페이스일 경우에 발생
  - IllegalAccessException -> 클래스나 생성자가 접근 제한자로 인해 접근할 수 없을 경우에 발생

``` java
Class clazz = Class.forName("SendAction" 또는 "RecieveAction");
Action action = (Action) clazz.newInstance(); //newInstance() 메소드로 얻어진 Object 객체는 모두Action으로 변환가능
action.execute(); // -> SendAction 또는 RecieveAction이 실행됨.
```



``` java
public interface Action {
    public void execute();
}
```

``` java
public class SendAction implements Action{
    @Override
    public void execute(){
        System.out.println("데이터를 보냅니다.");
    }
}
```

``` java
public class ReceiveAction implements Action{
    @Override
    public void execute(){
        System.out.println("데이터를 받습니다.");
    }
}
```

```java
import java.lang.reflect.InvocationTargetException;

public class NewInstanceExample {
    public static void main(String[] args){
        try{
            //Class clazz = Class.forName("ch11.SendAction"); 
            Class clazz = Class.forName("ch11.ReceiveAction");
            Action action = (Action) clazz.getDeclaredConstructor().newInstance();
            action.execute();
        } catch (ClassNotFoundException e){
            e.printStackTrace();
        } catch (InstantiationException e){
            e.printStackTrace();
        } catch (IllegalAccessException e){
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
// 데이터를 보냅니다.
데이터를 받습니다.
```

-> sendAction과 ReceiveAction을 호출할 때마다 서로 다른 결과가 나온다.

## 11.7 String 클래스 

---

### String  생성자

- String 클래스의 다양한 생성자를 이용해서 String 객체를 생성할 수 있다.
- 약 13개의 생성자를 제공한다.
- 사용 빈도가 높은 생성자들이며 파일의 내용을 읽거나, 네트워크를 통해 받은 데이터는 bye[]배열이므로 이것을 문자열로 변환하기 위해 사용된다.

``` java
// 배열 전체를 String 객체로 생성
String str = new String(byte[] bytes);
// 지정한 문자셋으로 디코딩
String str = new String(byte[] bytes, String charsetName);

// 배열의 offset 인덱스 위치부터 length만큼 String 객체로 생성
String str = new String(byte[] bytes, int offset, int length);
// 지정한 문자셋으로 디코딩
String str = new String(byte[] bytes, int offset, int length, String charsetName)
```



``` java
public class ByteToStringExmaple {
    public static void main(String[] args){
        byte[] bytes = {72,101,108,108,111,32,74,97,118,97};

        String str1 = new String(bytes);
        System.out.println(str1);

        String str2 = new String(bytes,6,4); // 74번 위치 4개
        System.out.println(str2);
    }
}
//
Hello Java
Java
```



``` java
import java.io.IOException;

public class keyBoardToStringExample {
    public static void main(String[] args) throws IOException {
        byte[] bytes = new byte[100]; // 읽은 바이트를 저장하기 위한 배열 생성

        System.out.print("입력: ");
        int readByteNo = System.in.read(bytes); // 배열에 읽은 바이트를 저장하고 읽은 바이트 수를  리턴

        String str = new String(bytes, 0, readByteNo-1); // 배열을 문자열로 리턴
        System.out.println(str);
    }
}
//
입력: Hello
Hello
```

-> 알파벳을 제외한 다른 언어는 보통 2byte로 표현되기 때문에 입력된 문자 수와 읽은 바이트 수가 다를 수 있다.

### String 메소드

사용 빈도수가 높은 메소드들

| 리턴 타입 | 메소드명(매개 변수)                                      | 설명                                                         |
| --------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| char      | charAt(int index)                                        | 특정 위치의 문자 리턴                                        |
| boolean   | equals(Object anObject)                                  | 두 문자열을 비교                                             |
| byte[]    | getBytes()                                               | byte[]로 리턴                                                |
| byte[]    | getBytes(Charset charset)                                | 주어진 문자셍으로 인코딩한 byte[]로 리턴                     |
| int       | indexOf(String str)                                      | 문자열 내에서 주어진 문자열의 위치를 리턴                    |
| int       | length                                                   | 총 문자의 수를 리턴                                          |
| String    | replace(CharSequence target,<br>CharSequence replacemet) | target 부분을 replacemetn로 대치한 새로운 문자열을 리턴      |
| String    | substring(int beginIndex)                                | beginIndex 위치에서 끄탂지 잘라낸 새로운 문자열을 리턴       |
| String    | substring(int beginindex,<br>int endIndex)               | beginIndex 위치에서 endIndex 전까지 잘라낸 새로운 문자열을 리턴 |
| String    | toLowerCase()                                            | 알파벳 소문자로 변환한 새로운 문자열을 리턴                  |
| String    | toUpeerCase()                                            | 알파벳 대문자로 변환한 새로운 문자열을 리턴                  |
| String    | trim()                                                   | 앞뒤 공백을 제거한 새로운 문자열을 리턴                      |
| String    | valueOf(int i)<br>valuseOf(double d)                     | 기본 타입값을 문자열로 리턴                                  |



#### 문자열 추출 (charAt())

매개값으로 주어진 인덱스의 문자를 리턴한다.

```java
String subject = "자바 프로그래밍";
char charValue = subject.charAt(3); // 프
```



``` java
public class StringCharAtExample {
    public static void main(String[] args){
        String ssn = "010624-1230123";
        char sex = ssn.charAt(7); // 7번째 문자의 값으로 남, 여를 비교
        switch (sex){
            case '1':
            case '3':
                System.out.println("남자 입니다.");
                break;
            case '2':
            case '4':
                System.out.println("여자 입니다.");
                break;
        }
    }
}
```



#### 문자열 비교(equals())

문자열을 비교할 때 == 을 사용하면 번지를 비교한다.

``` java
strVar1 == strVar2 -> false
strVar2 == strVar3 -> true
```

equals 메소드를 사용하면 문자열의 값을 비교할 수 있다.

``` java
strVar1.equals(strVar2) -> true
strVar2.equals(strVar3) -> true
```

-> equals는 String 클래스에서 오버라이딩해서 문자열을 비교하도록 되어있다.



``` java
public class StringEqualsExample {
    public static void main(String[] args){
        String strVar1 = new String("신민철");
        String strVar2 = "신민철";
        
        if(strVar1 == strVar2){
            System.out.println("같은 String 객체를 참조");
        }
        else{
            System.out.println("다른 String 객체를 참조");
        }
        
        if(strVar1.equals(strVar2)){
            System.out.println("같은 문자열을 가짐");
        }
        else{
            System.out.println("다른 문자열을 가짐");
        }
    }
}
//
다른 String 객체를 참조
같은 문자열을 가짐
```



#### 바이트 배열로 변환(getBytes())

문자열을 바이트 배열로 변환하는 두 가지 메소드.

```java
byte[] bytes = "문자열".getBytes();
byte[] bytes = "문자열".getBytes(Charset charset);
```



getBytes() 메소드는 시스템의 기본 문자셋으로 인코딩된 바이트 배열을 리턴한다.

특정 문자셋으로 인코딩된 바이트 배열을 얻으려면 두 번째 메소드를 사용하면 된다.

``` java
try{
    byte[] bytes = "문자열".getBytes("EUC-KR"); -> 알파벳은 1바이트, 한글은 2바이트
    byte[] bytes = "문자열".getBytes("UTF-8"); -> 알파벳은 1바이트 한글은 3바이트
} catch (UnsupportedEncodingException e){ // 잘못된 문자셋을 매개값으로 줄 경우 발생하는 예외를 위한 예외 처리
    
}
```



시스템 기본 문자셋과 다른 문자셋으로 인코딩된 바이트 배열일 경우 다음 String 생성자를 이용해서 디코딩하면 된다.

``` java
String str = new String(byte[] bytes, String charsetName);
```



``` java
import java.io.UnsupportedEncodingException;

public class StringGetBytesExample {
    public static void main(String[] args){
        String str = "안녕하세요";
        
        byte[] bytes1 = str.getBytes(); // 기본 문자셋으로 인코딩과 디코딩
        System.out.println("bytes1.length: " + bytes1.length);
        String str1 = new String(bytes1);
        System.out.println("bytes1->String " + str1);
        
        try{
            byte[] bytes2 = str.getBytes("EUC_KR"); // EUC_KR을 이용해서 인코딩과 디코딩
            System.out.println("byte2.length: " + bytes2.length);
            String str2 = new String(bytes2,"EUC-KR");
            System.out.println("byte2->String: " + str2);
            
            byte[] bytes3 = str.getBytes("UTF-8"); // UTF-8을 이용해서 인코딩과 디코딩
            System.out.println("bytes3.length: " + bytes3.length);
            String str3 = new String(bytes3, "UTF-8");
            System.out.println("bytes3->String: " + str3);
        }catch (UnsupportedEncodingException e){
            e.printStackTrace();
        }
    }
}
//
bytes1.length: 15
bytes1->String 안녕하세요
byte2.length: 10
byte2->String: 안녕하세요
bytes3.length: 15
bytes3->String: 안녕하세요
```



#### 문자열 찾기(indexOf())

주어진 문자열이 시작되는 인덱스를 리턴해 준다. / 문자열이 포함되어 있지 않으면 -1을 리턴한다.

``` java
String subject = "자바 프로그래밍";
int index = subject.inedxOf("프로그래밍");
```



```java
if(문자열.indexOf("찾는 문자열") != -1){
    // 포함되어 있는 경우
}
else{
    // 포함되어 있지 않는 경우
}
```



``` java
public class StringIndexOfExample {
    public static void main(String[] args){
        String subject = "자바 프로그래밍";
        
        int location = subject.indexOf("프로그래밍");
        System.out.println(location);
        
        if(subject.indexOf("자바") != -1){
            System.out.println("자바와 관련된 책이군요");
        }
        else{
            System.out.println("자바와 관련없는 책이군요");
        }
    }
}
//
3
자바와 관련된 책이군요
```



#### 문자열 길이(length())

문자열의 길이를 리턴해 준다.

``` java
String subject = "자바 프로그래밍";
int length = subject.length();
```



``` java
public class StringLengthExample {
    public static void main(String[] args){
        String ssn = "123434545";
        int length = ssn.length();
        if(length == 13){
            System.out.println("주민번호 자리수가 맞습니다.");
        }
        else{
            System.out.println("주민번호 자리수가 틀립니다.");
        }
    }
}
//
주민번호 자리수가 틀립니다.
```



#### 문자열 대치(replace())

첫 번째 매개값인 문자열을 찾아 두 번째 매개값인 문자열로 대치한 새로운 문자열을 생성하고 리턴한다.

``` java
String oldStr = "자바 프로그래밍";
String newStr = OldStr.replace("자바","JAVA")
```

`-> String 객체의 문자열은 변경이 불가한 특성 때문에 replace() 메소드가 리턴하는 문자열은 원래의 문자열이 아니라 새로운 문자열이다!!`



``` java
public class StringReplaceExample {
    public static void main(String[] args){
        String oldStr = "자바는 객체지향언어 입니다. 자바는 풍부한 API를 지원합니다.";
        String newStr = oldStr.replace("자바","JAVA");
        System.out.println(oldStr);
        System.out.println(newStr);
    }
}
//
자바는 객체지향언어 입니다. 자바는 풍부한 API를 지원합니다.
JAVA는 객체지향언어 입니다. JAVA는 풍부한 API를 지원합니다.
```



#### 문자열 잘라내기 (substring())

주어진 인덱스에서 문자열을 추출한다.

``` java
String ssn = "880815-1234567";
String firstNum = ssn.substring(0,6); // 첫번째 인덱스부터 마지막 인덱스 사이까지.
String secondNum = ssn.substring(7); // 주어진 인덱스부터 끝까지.
```



``` java
public class StringSubstringExample {
    public static void main(String args[]){
        String ssn = "880815-1234567";
        
        String firstNum = ssn.substring(0,6);
        System.out.println(firstNum);
        
        String seconNum = ssn.substring(7);
        System.out.println(seconNum);
    }
}
//
880815
1234567
```



#### 알파벳 소.대문자 변경(toLowerCase(),toUpperCase())

``` java
String original = "Java Programming";
String lowerCase = original.toLowerCase(); // 소문자로 변경
String upperCase = original.toUpperCase(); // 대문자로 변경
```

-> 이 메소드 또한 새로운 문자열을 참조한다.



``` java
public class StringToLowerUpperCaseExample {
    public static void main(String[] args){
        String str1 = "Java Programming";
        String str2 = "JAVA Programming";

        System.out.println(str1.equals(str2));

        String lowerStr1 = str1.toLowerCase();
        String lowerStr2 = str2.toLowerCase();
        System.out.println(lowerStr1.equals(lowerStr2));

        System.out.println(str1.equalsIgnoreCase(str2)); // 두 문자열의 대소문자가 다를경우 비교해주는 메소드
    }
}
//
false
true
true
```



#### 문자열 앞뒤 공백 잘라내기(trim())

문자열의 앞뒤 공백을 제거해 새로운 문자열을 생성하고 리턴 -> 중간 공백은 제거하지 않음.

``` java
String oldStr = "     자바 프로그래밍    ";
String newStr = oldStr.trim();
```



``` java
public class StringTrimExample {
    public static void main(String[] args){
        String tel1 = "   02";
        String tel2 = "123   ";
        String tel3 = "    12312   ";
        
        String tel = tel1.trim() + tel2.trim() + tel3.trim();
        System.out.println(tel);
    }
}
//
0212312312
```



#### 문자열 변환(valueOf)

기본 타입의 값을 문자열로 변경해주는 기능

매개 변수 타입별로 valueOf 메소드가 오버라이딩 되어있음.

``` java
static String valueOf(boolean b)
static String valueOf(char c)
static String valueOf(int i)
static String valueOf(long l)
static String valueOf(double d)
static String valueOf(float f)
```



``` java
public class StringValueOfExample {
    public static void main(String[] args){
        String str1 = String.valueOf(10);
        String str2 = String.valueOf(10.5);
        String str3 = String.valueOf(true);
        
        System.out.println(str1);
        System.out.println(str2);
        System.out.println(str3);
    }
}
//
10
10.5
true
```



## 11.8 StringTokenizer 클래스 

---

문자열이 특정 그분자로 연결되어 있을 경우, 구분자를 기준으로 문자열을 분리하기 위해선 split() 메소드말고 StringTokenizer() 메소드를 이용할 수 있다.

split()은 정규 표현식으로 구분하고

StringTokenizer은 문자로 구분한다.

### split() 메소드

split() 메소드의 호출 방법

``` java
String[] result = "문자열".split("정규표현식");
```



``` java
홍길동&이수홍, 박연수, 김자바-최명호
```

위 문자열에서 이름만을 뽑아내고 싶은 경우, 아래처럼 split()메소드를 선언하면 기호들을 구분자로 문자열을 출력한다.

```java
String[] names = text.split("&|,|-");
```



``` java
public class StringSplitExample {
    public static void main(String[] args){
        String text = "홍길동&이수홍,박연수,김자바-최명호";

        String[] names = text.split("&|,|-");
        
        for(String name : names){
            System.out.println(name);
        }
    }
}
//
홍길동
이수홍
박연수
김자바
최명호
```



### StringTokenizer 클래스

문자열이 한 졸류의 구분자로 연결되어 있을 경우 사용한다.

``` java
StringTokenizer st = new StringTokenizer("문자열", "구분자"); // 첫 번째 매개값으로 전체 문자열을 주고, 두 번째 매개값으로 구분값을 준다.
```

-> 구분자를 생략하면 공백이 기본 구분자가 된다.



/가 구분자로 구분되어있을 경우의 예시

```java
String text  = "홍길동/이수홍/박연수";
StringTokenizer st = new StringTokenizer(text,"/");
```



다음 메소드들을 이용해 전체 토큰 수, 남아있는 토큰의 수를 알수있다.

| 메소드  |                  | 설명                            |
| ------- | ---------------- | ------------------------------- |
| int     | countTokens()    | 꺼내지 않고 남아 있는 토큰의 수 |
| boolean | hashMoreTokens() | 남아 있는 토큰이 있는지 여부    |
| String  | nextToken()      | 토큰을 하나씩 꺼내옴            |

- nextToken() 메소드로 토큰을 하나 꺼내오면 StringTokenizer 객체에는 해당 토큰이 없어진다.
- 만약 가져올 토큰이 없다면 nextToken() 메소드는 NoSuchElementException 예외를 발생시킨다.
- 위 에러를 방지하기 위한 아래의 예시이다.

```java
import java.util.StringTokenizer;

public class StringTokenizerExample {
    public static void main(String[] args){
        String text  = "홍길동/이수홍/박연수";
        
        //how1 : 전체 토큰 수를 얻어 for문으로 루핑
        StringTokenizer st = new StringTokenizer(text,"/");
        int countTokens = st.countTokens();
        for(int i=0;i<countTokens;i++){
            String token = st.nextToken();
            System.out.println(token);
        }
        
        System.out.println();
        
        //how2 : 남아 있는 토큰을 확인하고 while문으로 루핑
        st = new StringTokenizer(text,"/");
        while (st.hasMoreTokens()){
            String token = st.nextToken();
            System.out.println(token);
        }
    }
}
//
홍길동
이수홍
박연수

홍길동
이수홍
박연수
```



## 11.9 StringBuffer, StringBuilder 클래스 

---

String은 내부의 문자열을 수정할 수 없다.

``` java
String data = "ABC";
data += "DEF"; // -> ABCDEF라는 새로운 객체가 생성된다.
```

-> 위가 반복되면 String객체가 늘어나 프로그램의 성능이 느려진다.

위를 막기 위해 사용하는 것이 StringBuffer, StringBuidler클래스이다.



StringBuffer은 멀티 스래드 환경에서만 사용 가능 -> 12장 skip



StringBuilder 클래스의 생성자

``` java
StringBuilder sb = new StringBuilder(); // 16개의 문자들을 저장할 수 있는 초기 버퍼를 만듬
StringBuilder sb = new StringBuilder(16); // 주어진 개수만큼 문자들을 저장할 수 있는 초기 버퍼를 만듬
StringBuilder sb = new StringBuilder("Java"); // str로 주어진 매개값을 버퍼의 초기값으로 저장
```

-> StringBuilder 클래스는 버퍼가 부족할 경우 자동으로 버퍼 크기를 늘리기 떄문에 초기 버퍼의 크기는 중요하지 않다.



StringBuilder 객체에서 사용할 수 있는 메소드

| 메소드                                  | 설명                                              |
| --------------------------------------- | ------------------------------------------------- |
| append(...)                             | 문자열 끝에 주어진 매개값을 추가                  |
| insert(int offset, ...)                 | 문자열 중간에 주어진 매개값을 추가                |
| delete(int start, int end)              | 문자열의 일부분을 삭제                            |
| deleteCharAt(int index)                 | 문자열에서 주어진 index의 문자를 삭제             |
| replace(int start, int end, String str) | 문자열의 일부분을 다른 문자열로 대치              |
| reverse                                 | 문자열의 순서를 뒤바꿈                            |
| setCharAt(int indext, char ch)          | 문자열에서 주어진 index의 문자를 다른 문자로 대치 |



``` java
public class StringBuilderExmaple {
    public static void main(String[] args){
        StringBuilder sb = new StringBuilder();
        
        sb.append("Java ");
        sb.append("Program Study"); // 문자열 끝에 '추가'
        System.out.println(sb.toString());
        
        sb.insert(4,"2"); // index4 위치 뒤에 2를 '삽입'
        System.out.println(sb.toString());
        
        sb.setCharAt(4,'6');  // index4위치의 문자를 6으로 '변경'
        System.out.println(sb.toString());
        
        sb.replace(6,13,"Book"); // index6부터 index13 '전' 까지를 "Book"문자열로 '대치'
        System.out.println(sb.toString());
        
        sb.delete(4,5); // indxe4부터 indxe5'전'까지 '삭제'
        System.out.println(sb.toString());
        
        int length = sb.length(); // 총 문자 수 얻기
        System.out.println("총문자수: " + length);
        
        String result = sb.toString(); // 버퍼에 있는 것을 String 타입으로 리턴
        System.out.println(result);
    }
}
//
Java Program Study
Java2 Program Study
Java6 Program Study
Java6 Book Study
Java Book Study
총문자수: 15
Java Book Study
```



## 11.10 정규 표현식과 Pattern 클래스 

---

문자열이 정해져 있는 형식으로 구성되어 있는지 검증해야 하는 경우 정규 표현식과 비교한다. (이메일, 전화번호 등..)

정규 표현식이란? 문자 또는 숫자 기호와 반복 기호가 결합된 문자열이다.

### 정규 표현식 작성 방법 

java.util.regex.Patter 클래스를 찾아 Summary of regular-expression constructs를 참조하면 된다. (?)

| 기호  | 설명                                                  |          |                          |
| ----- | ----------------------------------------------------- | -------- | ------------------------ |
| []    | 한개의 문자                                           | [abc]    | a,b,c 중 하나의 문자     |
|       |                                                       | [^abc]   | a,b,c 이외의 하나의 문자 |
|       |                                                       | [a-zA-Z] | a-z, A-Z중 하나의 문자   |
| \w    | 한 개의 알파벳 또는 한 개의 숫자, [a-zA-Z_0-9]와 동일 |          |                          |
| ?     | 없음 또는 한 개                                       |          |                          |
| *     | 없음 또는 한 개 이상                                  |          |                          |
| +     | 한 개 이상                                            |          |                          |
| {n}   | 정확히 n개                                            |          |                          |
| {n,}  | 최소한 n개                                            |          |                          |
| {n,m} | n개에서부터 m까지                                     |          |                          |
| ()    | 그룹핑                                                |          |                          |
| \s    | 공백                                                  |          |                          |
| \d    | 한 개의 숫자,[0-9]와 동일                             |          |                          |



예시1) 

``` java
(02|010)-\d{3,4}-\d{4}
```

| 기호      | 설명                  |
| --------- | --------------------- |
| (02\|010) | 02 또는 010           |
| -         | - 포함                |
| \d{3,4}   | 3자리 또는 4자리 숫자 |
| -         | - 포함                |
| \d{4}     | 4자리 숫자            |



예시2)

``` java
\w+@\w+\.\w+(\.\w+)?
```

| 기호       | 설명                                 |
| ---------- | ------------------------------------ |
| \w+        | 한 개 이상의 알파벳 또는 숫자        |
| @          | @                                    |
| \w+        | 한 개 이상의 알파벳 또는 숫자        |
| \\.        | .                                    |
| \w+        | 한 개 이상의 알파벳 또는 수자        |
| (\\.\\w+)? | \\.\\w+이 없거나 한 번 더 올 수 있음 |

-> \\.과 .은 다르다 

\\.은 문자로서의 .  

.은 모든 문자 중에서 한 갱의 문자 

### Pattern 클래스

정규 표현식으로 문자열을 검증하는 방법.

문자열 정규 표현식으로 검증하는 기능은 java.util.regex.Pattern 클래스의 정적 메소드인 matches() 메소드가 제공한다.

``` java
boolean result = Pattern.matches("정규식", "검증할 문자열"); // 첫 번째 매개값으로 정규 표현식, 두 번째 매개값으로 검증할 문자열
```

-> 검증 후 결과는 boolean타입으로 리턴된다.



```java
import java.util.regex.Pattern;

public class PatterExample {
    public static void main(String args[]){
        String regExp = "(02|010)-\\d{3,4}-\\d{4}";
        String data = "010-123-4567";
        boolean result = Pattern.matches(regExp,data);
        if(result){
            System.out.println("정규식과 일치합니다.");
        }
        else{
            System.out.println("정규식과 일치하지 않습니다.");
        }

        regExp = "\\w+@\\w+\\.\\w+(\\.\\w+)?";
        data = "angel@navercom"; // -> naver.com으로 써야 true
        result = Pattern.matches(regExp,data);
        if(result){
            System.out.println("정규식과 일치합니다.");
        }
        else{
            System.out.println("정규식과 일치하지 않습니다.");
        }
    }
}
//
정규식과 일치합니다.
정규식과 일치하지 않습니다.
```



## 11.11 Arrays 클래스 

---

배열의 조작 기능을 가지고 있다.

단순한 복사는 System.arraycopy()가 있으나

Arrays는 추가적인 항목 정렬, 항목 검색등과 같은 기능을 제공한다.



Arrays클래스의 메소드들이다.

| 리턴 타입 | 메소드 이름                                   | 설명                                                         |
| --------- | --------------------------------------------- | ------------------------------------------------------------ |
| int       | binarySearch(배열, 찾는값)                    | 전체 배열 항목에서 찾는 값이 있는 인덱스 리턴                |
| 타겟 배열 | copyOf(원본배열, 복사할길이)                  | 원본 배열의 0번 인덱스에서 복사할 길이만큼 복사한 배열 리턴 복사<br>할 길이는 원본 배열의 길이보다 커도 되며, 타겟 배열의 길이가 된다. |
| 타겟 배열 | copyOfRange(원본배열,<br>시작인덱스,끝인덱스) | 원본 배열의 시ㄱ작 인덱스에서 끝 인덱스까지 복사한 배열 리턴 |
| boolean   | deepEquals(배열,배열)                         | 두 배열의 깊은 비교(중첩 배열의 항목까지 비교)               |
| boolean   | equals(배열,배열)                             | 두 배열의 얕은 비교(중첩 배열의 항목은 비교하지않음)         |
| void      | fill(배열,값)                                 | 전체 배열 항목에 동일한 값을 저장                            |
| void      | fill(배열,시작인덱스,끝인덱스,값)             | 시작 인덱스부터 끝 인덱스까지 항목에만 동일한 값을 저장      |
| void      | sort(배열)                                    | 배열의 전체 항목을 오름차순으로 정렬                         |
| String    | toString(배열)                                | "[값1, 값2, ... ]" 와 같은 문자열 리턴                       |



### 배열 복사

배열 복사를 위해 사용할 수 있는 메소드는 copyOf() , copyOfRange()



copyOf 메소드는?

- 원본 배열의 0번 인덱스에서 복사할 길이만큼 복사한 타겟 배열을 리턴.
- 복사할 길이는 원본 배열의 길이보다 커도 된다. -> 타겟 배열의 길이가 된다.

``` java
char[] arr1 = {'J','A','V','A'};
char[] arr2 = Arrays.copyOf(arr1,arr1.length);
```



CopyOfRange 메소드는?

- 원본 배열의 시작 인덱스에서 끝 인덱스까지 복사한 배열을 리턴한다. (끝은 미포함)

``` java
char[] arr1 = {'J','A','V','A'};
char[] arr2 = Arrays.copyOfRange(arr1,1,3);
```



System.arraycopy 메소드는?

- 단순히 배열을 복사할 목적일 경우 사용.

```java
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 
    				// 원본배열, 원본시작인덱스, 타겟배열, 타겟시작인덱스, 복사개수
```



```java
import java.util.Arrays;

public class ArrayCopyExample {
    public static void main(String[] args){
        char[] arr1 = {'J','A','V','A'};
        
        // 방법1
        char[] arr2 = Arrays.copyOf(arr1,arr1.length); // arr1 전체를 arr2로 복사
        System.out.println(Arrays.toString(arr2));
        
        // 방법2
        char[] arr3 = Arrays.copyOfRange(arr1,1,3); // arr[1] ~ arr[2]를 arr3[0] ~ arr3[1]로 복사
        System.out.println(Arrays.toString(arr3));
        
        // 방법3
        char[] arr4 = new char[arr1.length];
        System.arraycopy(arr1, 0 ,arr4,0,arr1.length); // arr1 전체를 arr4로 복사
        for(int i=0;i<arr4.length;i++){
            System.out.println("arr4[" + i + "]=" + arr4[i]);
        }
    }
}
//
[J, A, V, A]
[A, V]
arr4[0]=J
arr4[1]=A
arr4[2]=V
arr4[3]=A
```



### 배열 항목 비교

equals()와 deepEquals()는 배열 항목을 비교한다.

equals()는 1차 항목의 값만 비교하고

deepEquals()는 1차 항목이 서로 다른 배열을 참조할 경우 중첩된 배열의 항목까지 비교한다.

``` java
import java.util.Arrays;

public class EqualsExample {
    public static void main(String args[]){
        int[][] original = {{1,2},{3,4}};
        
        // 얕은 복사후 비교
        System.out.println("[얕은 복제후 비교]");
        int[][] cloned1 = Arrays.copyOf(original,original.length);
        System.out.println("배열 번지 비교: " + original.equals(cloned1));
        System.out.println("1차 배열 항목값 비교: " + Arrays.equals(original,cloned1));
        System.out.println("중첩 배열 항목값 비교: " + Arrays.deepEquals(original,cloned1));
        
        // 깊은 복사후 비교
        System.out.println("[깊은 복제후 비교]");
        int[][] cloned2 = Arrays.copyOf(original,original.length);
        cloned2[0] = Arrays.copyOf(original[0],original[0].length);
        cloned2[1] = Arrays.copyOf(original[1],original[1].length);
        System.out.println("배열 번지 비교: " + original.equals(cloned2));
        System.out.println("1차 배열 항목값 비교: " + Arrays.equals(original,cloned2));
        System.out.println("중첩 배열 항목값 비교: " +Arrays.deepEquals(original,cloned2));
    }
}
//
[얕은 복제후 비교]
배열 번지 비교: false
1차 배열 항목값 비교: true
중첩 배열 항목값 비교: true
[깊은 복제후 비교]
배열 번지 비교: false
1차 배열 항목값 비교: false
중첩 배열 항목값 비교: true
```



### 배열 항목 정리

Arrays.sort() 메소드는 자동으로 오름차순 정렬을 해준다.



사용자 정의 클래스 타입일 경우 클래스가 Comparable 인터페이스를 구현하고 있어야 정렬이된다.

Member1배열에서 Member1객체들을 name필드값으로 정려하는 Member클래스이다.

```java
public class Member1 implements Comparable<Member1>{ // Member1타입만 비교하기 위해 제네릭<>
    String name;
    Member1(String name){
        this.name = name;
    }
    @Override // 비교값을 리턴하도록 오버라이딩.
    public int compareTo(Member1 o){
        return name.compareTo(o.name);
    }
}
```



```java
import java.util.Arrays;

public class SortExample {
    public static void main(String[] args){
        int[] scores = {99,97,98};
        Arrays.sort(scores);
        for(int i =0;i<scores.length;i++){
            System.out.println("scores[" + i + "]=" + scores[i] );
        }
        System.out.println();
        
        String[] names = {"홍길동","박동수" , "김민수"};
        Arrays.sort(names);
        for(int i =0;i<names.length;i++){
            System.out.println("name[" + i + "]=" + names[i]);
        }
        System.out.println();
        
        Member1 m1 = new Member1("홍길동");
        Member1 m2 = new Member1("박동수");
        Member1 m3 = new Member1("김민수");
        Member1[] members = {m1,m2,m3};
        Arrays.sort(members);
        for(int i=0;i<members.length;i++){
            System.out.println("member[" + i + "].name=" + members[i].name);
        }
    }
}
//
scores[0]=97
scores[1]=98
scores[2]=99

name[0]=김민수
name[1]=박동수
name[2]=홍길동

member[0].name=김민수
member[1].name=박동수
member[2].name=홍길동
```



### 배열 항목 검색

특정 값이 위치한 인덱스를 얻는 것.

먼저 Arrays.sort() 메소드로 항목들을 오름차순으로 정렬한 후,

Arrays.binarySearch() 메소드로 항목을 찾아야 한다.

```java
public class SearchExample {
    public static void main(String[] args){
        // 기본 타입값 검색
        int[] scores = {99,97,98};
        Arrays.sort(scores);
        int index = Arrays.binarySearch(scores,99);
        System.out.println("찾은 인덱스: " + index);

        // 문자열 검색
        String[] names = {"홍길동","박동수","김민수"};
        Arrays.sort(names);
        index = Arrays.binarySearch(names,"홍길동");
        System.out.println("찾은 인덱스: " + index);

        // 객체 검색
        Member1 m1 =new Member1("홍길동");
        Member1 m2 = new Member1("박동수");
        Member1 m3 = new Member1("김민수");
        Member1[] members ={m1,m2,m3};
        Arrays.sort(members);
        index = Arrays.binarySearch(members,m1);
        System.out.println("찾은 인덱스: "+index);
    }
}
//
찾은 인덱스: 2
찾은 인덱스: 2
찾은 인덱스: 2
```



## 11.12 Wrapper(포장) 클래스 

---

- 자바는 기본 타입의 값을 갖는 객체를 생성할 수 있다

   -> 이 객체가 Wrapper 객체라고 하고 기본 타입의 값을 내부에 두고 포장하기 때문이다.

- 포장하고 있는 기본 타입 값은 외부에서 변경할 수 없다.

- 포장클래스는  java.lang 패키지에 포함되어있다. 

| 기본 타입 | 포장 클래스 |
| --------- | ----------- |
| byte      | Byte        |
| char      | Character   |
| short     | Short       |
| int       | Integer     |
| long      | Long        |
| float     | Float       |
| double    | Double      |
| boolean   | Boolean     |



### 박싱(Boxing)과 언박싱(Unboxing)

박싱: 기본 타입의 값을 포장 객체로 만드는 과정

언박싱: 포장 객체에서 기본 타입의 값을 얻어내는 과정

| 기본 타입의 값을 줄 경우             | 문자열을 줄 경우                   |
| ------------------------------------ | ---------------------------------- |
| Byte obj = new Byte(10);             | Byte obj = new Byte("10");         |
| Character obj = new Character('가'); | 없음                               |
| Short obj = new Short(100);          | Short obj = new Short("100");      |
| Integer obj = new Integer(1000);     | Integer obj = new Integer("1000"); |
| Long obj = new Long(10000);          | Long obj = new Long("10000");      |
| Float obj = new Float(2.5F);         | Float obj = new Float("2.5F");     |
| Double obj = new Double(3.5);        | Double obj = new Double("3.5");    |
| Boolean obj = new Boolean(true);     | Boolean obj = new Boolean("true"); |



생성자를 이용하지 않아도 다음과 같이 각 포장 클래스마다 가지고 있는 정적 valueOf() 메소드를 사용할 수도 있다.

``` java
Integer obj = Integer.valueOf(1000);
Integer obj = Integer.valueOf("1000");
```



이렇게 박싱된 포장 객체에서 다시 기본 타입의 값을 얻어내기 위해서는 "기본 타입명 + Value()" 메소드를 호출하면 된다.

| 기본 타입의 값을 이용                |
| ------------------------------------ |
| byte     num = obj.byteValue();      |
| char     ch = obj.charValue();       |
| short    num = obj.shortValue();     |
| int         num = obj.intValue();    |
| long     num = obj.longValue();      |
| float      num = obj.floatValue();   |
| double   num = obj.doubleValue();    |
| boolean  bool = obj. booleanValue(); |



``` java
public class BoxingUnBoxingExample {
    public static void main(String[] args){
        //Boxing
        Integer obj1 = new Integer(100);
        Integer obj2 = new Integer("200");
        Integer obj3 = Integer.valueOf("300");
        
        //unBoxing
        int value1 = obj1.intValue();
        int value2 = obj2.intValue();
        int value3 = obj3.intValue();
        
        System.out.println(value1);
        System.out.println(value2);
        System.out.println(value3);
    }
}
//
100
200
300
```



### 자동 박싱과 언박싱

자동 박싱은 포장 클래스 타입에 기본값이 대입될 경우 발생한다.

ex) int타입의 값을 Integer 클래스 변수에 대입하면 자동 박싱이 일어나 힙 영역에 Integer객체가 생성된다.

``` java
Integer obj1 = 100; // 자동 박싱
```



자동 언박싱은 기본 타입에 포장 객체가 대입될 경우 발생한다.

ex) Integer 객체를 int 타입 변수에 대입하거나, Integer객체와 int 타입값을 연산하면 Integer 객체로부터 int타입 값이 자동 언박싱되어 연산된다.

``` java
Integer obj = new Interger(200);
int value1 = obj; // 자동 언박싱 -> 대입
int value2 = obj + 100; // 자동 언박싱 -> 연산
```



int 값을 저장하면 자동 박싱이 일어나 Integer객체가 저장된다. (자바 5이후 추가된 기능)

``` java
List<Integer> list = new ArrrayList<Integer>();
list.add(200); // 자동 박싱
```



```java
public class AutoBoxingUnBoxingExample {
    public static void main(String[] args){
        // 자동 Boxing
        Integer obj = 100;
        System.out.println("value: " + obj.intValue());

        // 대입 시 자동 UnBoxing
        int value = obj;
        System.out.println("value: " + value);

        // 연산 시 자동 UnBoxing
        int result = obj + 100;
        System.out.println("result: " + result);
    }
}
//
value: 100
value: 100
result: 200
```



### 문자열을 기본 타입 값으로 변환

문자열을 기본 타입 값으로 변환할 때에도 많이 사용된다.

대부분의 포장 클래스에는 "parse + 기본타입" 명으로 되어 있는 정적 메소드가 있다.

메소드는 문자열을 매개값으로 받아 기본 타입 값으로 변환한다.

| 기본 타입의 값을 이용                          |
| ---------------------------------------------- |
| byte       num = Byte.parseByte("10");         |
| short      num = Short.parseShort("100");      |
| int          num = Integer.parseShort("1000"); |
| long       num = Long.parseLong("10000");      |
| float       num = Float.parseFloat("2.5F");    |
| double   num = Double.parseDouble("3.5");      |
| boolean  bool = Boolean.parseBoolean("true");  |

```java
public class StringToPrimitiveValueExample {
    public static void main(String[] args){
        int value1 = Integer.parseInt("10");
        double value2 = Double.parseDouble("3.14");
        boolean value3 = Boolean.parseBoolean("true");
        
        System.out.println("value1: " + value1);
        System.out.println("value2: " + value2);
        System.out.println("value3: " + value3);
    }
}
//
value1: 10
value2: 3.14
value3: true
```



### 포장 값 비교

포장 객체에서는 ==와 != 연산자를 사용할 수 없다. -> 포장 객체의 참조를 비교하기 때문이다.

``` java
Integer obj1 = 300;
Integer obj2 = 300;
System.out.println(obj1 == obj2); // false
```

- 내부의 값만 비교하려면 언박싱한 값을 얻어 비교해야 한다.

- 박싱된 값이 아래 표에 있는 값이라면 ==와 !=을 사용해서 값을 비교할 수 있다.

- equals 메소드로 내부 값을 비교하자

| 타입             | 값의 범위       |
| ---------------- | --------------- |
| boolean          | true, false     |
| char             | \u0000 ~ \u007f |
| byte, short, int | - 128 ~ 127     |



```java
public class ValueCompareExample {
    public static void main(String[] args){
        System.out.println("[-128~127 초기값일 경우]");
        Integer obj1 = 300;
        Integer obj2 = 300;
        System.out.println("==결과: " + (obj1 == obj2));
        System.out.println("언박싱후 ==결과: " + (obj1.intValue() == obj2.intValue()));
        System.out.println("equals() 결과: " + obj1.equals(obj2));
        System.out.println();
        
        System.out.println("[-128~127 범위값일 경우]");
        Integer obj3 = 10;
        Integer obj4 = 10;
        System.out.println("==결과: " + (obj3 == obj4));
        System.out.println("언박싱후 ==결과: " + (obj3.intValue() == obj4.intValue()));
        System.out.println("equals() 결과: " + obj3.equals(obj4));
    }
}
//
==결과: false
언박싱후 ==결과: true
equals() 결과: true

[-128~127 범위값일 경우]
==결과: true
언박싱후 ==결과: true
equals() 결과: true
```



## 11.13 Math, Random 클래스 

---

### Math 클래스

java.lang.Math 클래스는 수학 계산에 사용할 수 있는 메소드들을 제공한다.

모두 정적이므로 Math클래스로 바로 사용가능하다.



Math클래스가 제공하는 메소드들의 표

| 메소드                                                  | 설명                 | 예제 코드                                                    | 리턴값                 |
| ------------------------------------------------------- | -------------------- | ------------------------------------------------------------ | ---------------------- |
| int abs(int a)<br>double abs(double a)                  | 절대값               | int v1 = Math.abs(-5);<br>double v2 = Math.abs(-3.14);       | v1 = 5<br>v2 = 3.14    |
| double ceil(double a)                                   | 올림값               | double v3 = Math.ceil(5,3);<br>double v4 = Math.ceil(-5,3)   | v3 = 6.0<br>v4 = -5.0  |
| double floor(double a)                                  | 버림값               | double v5 = Math.floor(5,3)<br>double v6 = Math.floor(-5,3)  | v5 = 5.0<br>v6 = -6.0  |
| int max(int a, int b)<br>double max(double a, double b) | 최대값               | int v7 = Math.max(5,9);<br>double v8 = Math.max(5.3,2.5);    | v7 = 9<br>v8 = 5.3     |
| int min(int a,int b)<br>double min(double a,double b)   | 최소값               | int v9 = Math.min(5,9);<br>double v10 = Math.math(5.3,2.5);  | v9 = 5<br>v10 = 2.5    |
| double random()                                         | 랜덤값               | double v11 = Math.random();                                  | 0.0<= v11 <1.0         |
| double rint(double a)                                   | 가까운 정수의 실수값 | double v12 = Math.rint(5.3);<br>double v13 = Math.rint(5.7); | v12 = 5.0<br>v13 = 6.0 |
| long round(double a)                                    | 반올림값             | long v14 = Math.round(5.3);<br>long v15 = Math.round(5.7);   | v14 = 5<br>v15 = 6     |



``` java
public class MathExample {
    public static void main(String args[]){
        int v1 = Math.abs(-5); // 절대
        double v2 = Math.abs(-3.14); 
        System.out.println("v1=" + v1);
        System.out.println("v2=" + v2);

        double v3 = Math.ceil(5.3); // 올림
        double v4 = Math.ceil(-5.3);
        System.out.println("v3=" + v3);
        System.out.println("v4=" + v4);

        double v5 = Math.floor(5.3); // 내림
        double v6 = Math.floor(-5.3);
        System.out.println("v5=" + v5);
        System.out.println("v6=" + v6);

        int v7 = Math.max(5,9); // 최대
        double v8 = Math.max(5.3,2.5);
        System.out.println("v7=" + v7);
        System.out.println("v8=" + v8);

        int v9 = Math.min(5,9); // 최소
        double v10 = Math.min(5.3,2.5);
        System.out.println("v9=" + v9);
        System.out.println("v10=" + v10);

        double v11 = Math.random(); // 랜덤
        System.out.println("v11=" + v11);

        double v12 = Math.rint(5.3); // 가장 가까운 실수
        double v13 = Math.rint(5.7);
        System.out.println("v12=" + v12);
        System.out.println("v13=" + v13);

        long v14 = Math.round(5.3); // 반올림
        long v15 = Math.round(5.7);
        System.out.println("v14=" + v14);
        System.out.println("v15=" + v15);

        double value = 12.3456;
        double temp1 = value * 100;
        long temp2 = Math.round(temp1);
        double v16 = temp2 / 100.0;
        System.out.println("v16=" + v16);
    }
}
//
v1=5
v2=3.14
v3=6.0
v4=-5.0
v5=5.0
v6=-6.0
v7=9
v8=5.3
v9=5
v10=2.5
v11=0.3682806803587705
v12=5.0
v13=6.0
v14=5
v15=6
v16=12.35
```



Math.random() 메소드는 아래 값에 속하는 하나의 double 타입의 값을 리턴한다.

``` java
0.0 < = Math.random() < 1.0
```

- 임의의 정수 값을 얻고싶으면 (int) Math.random()
- 좀 더 큰 범위의 값에서 얻고싶으면 양 옆에 * 

``` java
public class MathRandomExample{
    public static void main(String[] args){
        int num = (int) (Math.random()*6) + 1;
        System.out.println("주사위 눈: " + num);
    }
}
//
주사위 눈: 3
```



### Random클래스

java.util.Random() 클래스는 난수를 얻어내기 위한 다양한 메소드를 제공한다.



Math.random() 메소드와는 다르게

- booelan,int,long,float,double 의 난수를 얻을 수 있다.
- 종자값(seed)를 설정할 수 있다. -> 종자값이 같으면 같은 난수를 얻는다.

| 생성자            | 설명                                                      |
| ----------------- | --------------------------------------------------------- |
| Random()          | 호출 시마다 다른 종자값(현재시간 이용시)이 자동 설정된다. |
| Random(long seed) | 매개값으로 주어진 종자값이 설정된다.                      |



| 리턴값  | 메소드(매개 변수) | 설명                                           |
| ------- | ----------------- | ---------------------------------------------- |
| boolean | nextBoolean()     | boolean 타입의 난수를 리턴                     |
| double  | nextDouble()      | double 타입의 난수를 리턴(0.0 <= ~ < 1.0)      |
| int     | nextInt()         | int 타입의 난수를 리턴(-2^31 <= ~ <= 2^31 -1); |
| int     | nextInt(int n)    | int 타입의 난수를 리턴(0 <= ~ < n)             |



``` java
import java.util.Arrays;
import java.util.Random;

public class RandomExample {
    public static void main(String args[]){
        // 선택 번호
        int[] selectNumber = new int[6]; // 선택 번호 6개가 저장될 배열 생성
        Random random = new Random(3); // 선택 번호를 얻기 위한 Random객체 생성
        System.out.println("선택 번호: ");
        for(int i=0;i<6;i++){
            selectNumber[i] = random.nextInt(45) + 1; // 선택 번호를 얻어 배열에 저장
            System.out.println(selectNumber[i] + " ");
        }
        System.out.println();

        int[] winningNumber = new int[6]; // 당첨 번호 6개가 저장될 배열 생성
        random = new Random(5); // 당첨 번호를 얻기 위한 Random 객체 생성
        System.out.println("당첨 번호: ");
        for(int i=0;i<6;i++){ 
            winningNumber[i] = random.nextInt(45) + 1; // 당첨 번호를 얻어 배열에 저장
            System.out.println(winningNumber[i] + " ");
        }
        System.out.println();

        // 당첨여부
        Arrays.sort(selectNumber);
        Arrays.sort(winningNumber);
        boolean result = Arrays.equals(selectNumber, winningNumber); // 배열의 항목 값 비교
        System.out.println("당첨 여부: ");
        if(result){
            System.out.println("1등에 당첨되셨습니다.");
        }
        else{
            System.out.println("당첨되지 않았습니다.");
        }
    }
}
//
선택 번호: 15 21 16 17 34 28 
당첨 번호: 18 38 45 15 22 36 
당첨 여부: 당첨되지 않았습니다.
```

-> 종자값이 달라 선택 번호와 당첨 번호는 다를 수 밖에 없다.



## 11.14 Date, Calender 클래스 

---

### Date 클래스

Date는 날짜를 표현하는 클래스

Date() 생성자는 컴퓨터의 현재 날짜를 읽어 Date() 객체로 만든다.

``` java
Date now = new Date();
```



``` java
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateExample {
    public static void main(String[] args){
        Date now = new Date();
        String strNow1 = now.toString(); // toString() 메소드는 영문으로 된 날짜를 리턴
        System.out.println(strNow1);

        SimpleDateFormat sdf=
                new SimpleDateFormat("yyyy년 MM년 dd일 hh시 mm분 ss초");
        String strNow2 = sdf.format(now);
        System.out.println(strNow2);
    }
}
//
Wed Feb 17 04:45:31 KST 2021
2021년 02년 17일 04시 45분 31초
```



### Calender 클래스

Calender는 달력을 표현하는 클래스.

- 추상 클래스이므로 new연산자를 이용해서 인스턴스를 생성할 수 없다. -> 지역과 문화,나라마다 다르기 때문
- 날짜와 시간을 계산하는데 꼭 필요한 메소드들만 선언되어 있고, 특정한 역법을 따르는 계산 로직은 하위 클래스에서 구현되어 있음



Calender클래스의 정적 메소드인 getInstance() 메소드를 이용해 현재 운영체제에 설정되어있는 시간대를 기준으로한 Calender하위 객체를 얻을 수 있음

``` java
Calender now = Calendar.getInstance();
```



getInstance()메소드로 Calendar객체를 얻었다면 get() 메소드를 이용해 날짜와 시간에 대한 정보를 얻을 수 있다.

``` java
int year = now.get(Calendar.YEAR); // 년
int month = now.get(Calendar.MONTH) + 1; // 월
int day = now.get(Calendar.DAY_OF_WEEK); // 일
int amPm = now.get(Calendar.AM_PM); // 요일
int hour = now.get(Calendar.HOUR); // 시간
int minute = now.get(Calendar.MINUTE); // 분
int second = now.get(Calendar.SECOND); // 초
```



``` java
import java.util.Calendar;

public class CalendarExample {
    public static void main(String args[]){
        Calendar now = Calendar.getInstance();
        
        int year = now.get(Calendar.YEAR); // 년
        int month = now.get(Calendar.MONTH) + 1; // 월
        int day = now.get(Calendar.DAY_OF_MONTH); // 일
        
        int week = now.get(Calendar.DAY_OF_WEEK); // 요일
        String strWeek = null;
        switch (week){
            case Calendar.MONDAY:
                strWeek = "월";
                break;
            case Calendar.TUESDAY:
                strWeek = "화";
                break;
            case Calendar.WEDNESDAY:
                strWeek = "수";
                break;
            case Calendar.THURSDAY:
                strWeek = "목";
                break;
            case Calendar.FRIDAY:
                strWeek = "금";
                break;
            case Calendar.SATURDAY:
                strWeek = "토";
                break;
            default:
                strWeek = "일";
        }
        
        int amPm = now.get(Calendar.AM_PM); // 오전 오후
        String strAmPM = null;
        if(amPm == Calendar.AM){
            strAmPM = "오전";
        }
        else{
            strAmPM = "오후";
        }
        
        int hour = now.get(Calendar.HOUR); // 시간
        int minute = now.get(Calendar.MINUTE); // 분
        int second = now.get(Calendar.SECOND); // 초
        
        System.out.println(year + "년");
        System.out.println(month + "월");
        System.out.println(day + "일");
        System.out.println(strWeek + "요일");
        System.out.println(strAmPM + " ");
        System.out.println(hour + "시");
        System.out.println(minute + "분");
        System.out.println(second + "초");
    }
}
//
2021년2월17일
수요일오전 
4시52분58초
```



다른 나라의 시간대를 얻고 싶다면?

java.util.TimeZone 객체를 얻어 getInstance() 메소드의 매개값으로 넘겨주면 된다.

``` java
TimeZone timeZone = TimeZone.getTimeZone("America/Los_Angeles");
Calendar now = Calendar.getInstance( timeZone );
```



``` java
import java.util.TimeZone;

public class PrintTimeZoneID {
    public static void main(String[] args){
        String[] availablesIDs = TimeZone.getAvailableIDs();
        for(String id: availablesIDs){
            System.out.println(id);
        }
    }
}
//
사용 가능 시간대의 문자열을 출력하는데 너무 많아서 생략
```



## 11.15 Format 클래스 

---

나열된 문자열들을 , 소수점 한자리 등.. 일정하게 맞추어 출력하기 위해 만들어진 클래스

- 숫자 형식을 위한 DecimalFormat
- 날짜 형식을 위한 SimpleDateFormat
- 매개 변수화된 문자열 형식을 위한 MessageFormat

### 숫자 형식 클래스(DecimalFormat)

숫자 데이터를 원하는 형식으로 표현하기 위해서 사용 하는 패턴 표

| 기호   | 의미                                             | 패턴 예                      | 1234567.89 -> 변환 결과                  |
| ------ | ------------------------------------------------ | ---------------------------- | ---------------------------------------- |
| 0      | 10진수(빈자리는 0으로 채움)                      | 0<br>0.0<br>0000000000.00000 | 1234568<br>1234567.9<br>0001234567.89000 |
| #      | 10진수(빈자리는 채우지 않음)                     | #<br>#.#<br>##########.##### | 1234568<br>1234567.9<br>1234567.89       |
| .      | 소수점                                           | #.0                          | 1234567.9                                |
| -      | 음수 기호                                        | +#.0<br>-#.0                 | +1234567.9<br>-1234567.9                 |
| ,      | 단위 구분                                        | #.###.0                      | 1,234,567.9                              |
| E      | 지수 문자                                        | 0.0E0                        | 1.2E6                                    |
| ;      | 수와 음수의 패턴을 모두 기술할 경우, 패턴 구분자 | +#,### ; -#,###              | +1,234,568(양수)<br>-1,234,568(음수)     |
| %      | 100을 곱한 후에 % 문자 붙임                      | #.# %                        | 123456789 %                              |
| \u00A4 | 통화 기호                                        | \u00A4 #,###                 | \ 1,234,568                              |



적용할 패턴을 구했다면 DecimalFormat 생성자 매개값으로 지정해서 객체를 생성하고

format() 메소드를 호출해서 패턴이 적용된 문자열을 얻으면 된다.

``` java
DecimalFormat df = new DecimalFormat("#,###.0");
String result = df.format(1234567.89);
```



```java
import java.text.DecimalFormat;

public class DecimalFormatExample {
    public static void main(String[] args){
        double num = 1234567.89;

        DecimalFormat df = new DecimalFormat("0");
        System.out.println( df.format(num)); // 1234568
        
        df = new DecimalFormat("0.0");
        System.out.println(df.format(num)); // 1234567.9
        
        df = new DecimalFormat("0000000000.00000");
        System.out.println(df.format(num)); // 0001234567.89000
        
        df = new DecimalFormat("#");
        System.out.println(df.format(num)); // 1234568
        
        df = new DecimalFormat("#.#");
        System.out.println(df.format(num)); // 1234567.9
        
        df = new DecimalFormat("##########.#####");
        System.out.println(df.format(num)); // 1234567.89
        
        df = new DecimalFormat("#.0");
        System.out.println(df.format(num)); // 1234567.9
        
        df = new DecimalFormat("+#.0");
        System.out.println(df.format(num)); // +1234567.9
        
        df = new DecimalFormat("-#.0");
        System.out.println(df.format(num)); // -1234567.9
        
        df = new DecimalFormat("#,###.0");
        System.out.println(df.format(num)); // 1,234,567.9
        
        df = new DecimalFormat("0.0E0");
        System.out.println(df.format(num)); // 1.2E6
        
        df = new DecimalFormat("+#,### ; -#,###");
        System.out.println(df.format(num)); // +1,234,568 
        
        df = new DecimalFormat("#.# %");
        System.out.println(df.format(num)); // 123456789 %
        
        df = new DecimalFormat("\u00A4 #,###");
        System.out.println(df.format(num)); // ￦ 1,234,568
    }
}
```



### 날짜 형식 클래스(SimpleDateFormat)

Date 클래스의 toString() 메소드는 영문으로만 된 문자열을 리턴한다.

-> 특정 문자열 포맷으로 얻고 싶다면 java.text.SimpleDateFormat 클래스를 이용하면 된다.

SimpleDateFormat의 패턴 작성에 사용되는 기호 표

| 패턴 문자 | 의미                     | 패턴 문자 | 의미                 |
| --------- | ------------------------ | --------- | -------------------- |
| y         | 년                       | H         | 시(0~23)             |
| M         | 월                       | h         | 시(1~12)             |
| d         | 일                       | K         | 시(0~11)             |
| D         | 월 구분이 없는 일(1~365) | k         | 시(1~24)             |
| E         | 요일                     | m         | 분                   |
| a         | 오전/오후                | s         | 초                   |
| w         | 년의 몇 번째 주          | S         | 밀리세컨드(1/1000초) |
| W         | 월의 몇 번째 주          |           |                      |



패턴에는 자리수에 맞게 기호들을 반복해서 작성할 수 있다.

적용할 패턴을 작성했다면 이 패턴을 SimpleDateFormat의 생성자로 매개값을 지정해서 객체를 생성하고

format() 메소드를 호출해서 패턴이 적용된 문자열을 얻으면 된다.

``` java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy년 MM월 dd일"); // 년도는 4자리 월, 일은 2자리
String strDate = sdf.format(new Date());
```



``` java
import java.text.SimpleDateFormat;
import java.util.Date;

public class SimpleDateForamtExample {
    public static void main(String[] args){
        Date now = new Date();

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        System.out.println(sdf.format(now));
        
        sdf = new SimpleDateFormat("yyyy년 MM월 dd일");
        System.out.println(sdf.format(now));
        
        sdf = new SimpleDateFormat("yyyy.MM.dd a HH:mm:ss");
        System.out.println(sdf.format(now));
        
        sdf = new SimpleDateFormat("오늘은 E요일");
        System.out.println(sdf.format(now));
        
        sdf = new SimpleDateFormat("올해의 D번째 날");
        System.out.println(sdf.format(now));
        
        sdf = new SimpleDateFormat("이달의 d번째 날");
        System.out.println(sdf.format(now));
    }
}
//
2021-02-17
2021년 02월 17일
2021.02.17 오전 05:07:54
오늘은 수요일
올해의 48번째 날
이달의 17번째 날
```



### 문자열 형식 클래스(MessageFormat)

문자열에 데이터가 들어갈 자리를 표시해 두고, 프로그램이 실행하면서 동적으로 데이터를 삽입해 문자열을 완성시킨다.

예로 다음 문자열을 출력한다면

``` java
회원 ID: blue
회원 이름: 신용권
회원 전화: 010-123-1234
```

``` java
String result = "회원 ID: " + id + "\n회원 이름: " + name + "\n회원 전화: " + tel;  // 문자열 연결 연산자로 문자열을 생성할 수 있다.
```

-> MessageFormat 클래스를 사용하면 좀 더 깔끔하게 데이터를 삽입시켜주고 전체 문자열을 쉽게 예측할 수 있다.

``` java
String message = "회원 ID: {0} \n회원 이름: {1} \n회원 전화: {2}";
String result = MessageFormat.format(message, id, name, tel);
```



MessageFormate은 정적 format() 메소드를 호출해서 완성된 문자열을 리턴시킨다.

format() 메소드의 첫 번째 매개값은 매개 변수화된 문자열을 저장하고, 두 번째 이후의 매개값은 인덱스 순서에 맞게 값을 나열하면 된다. (배열도 가능.)

``` java
String text = "회원 ID: {0} \n회원 이름: {1} \n회원 전화: {2}";
Object[] arguments = {id, name, tel};
String result = MessageFormat.format(text,arguments);
```



```java
import java.text.MessageFormat;

public class MessageFormatExample {
    public static void main(String args[]){
        String id = "java";
        String name = "신용권";
        String tel = "010-123-5678";

        String text = "회원 ID: {0} \n회원 이름: {1} \n회원 전화: {2}";
        String result1 = MessageFormat.format(text, id, name, tel); // text 문자열에 id, name, tel 순으로 값을 넣음
        System.out.println(result1);
        System.out.println();
        
        String sql = "insert into member values({0}, {1}, {2})";
        Object[] arguments = {"'java'" ,"'신용권'","'010-123-5678'"};
        String result2 = MessageFormat.format(sql,arguments); // sql에 arguments 배열의 값들을 순서대로 넣음
        System.out.println(result2);
    }
}
//
회원 ID: java 
회원 이름: 신용권 
회원 전화: 010-123-5678

insert into member values('java', '신용권', '010-123-5678')
```



## 11.16 java.time 패키지

---

Date와 Calendar 클래스의 불충분한 기능을 보안하기 위해 (자바 8이후)

날짜와 시간을 나타내는 API가 추가되었다. 

java.time 패키지의 하위 패키지로 적용되고 그 표이다.

| 패키지             | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| java.time          | 날짜와 시간을 나타내는 핵심 API인 LocalDate, LocalTime, LocalDateTime, ZonedDateTime을 포함하고 있다. 이 클래스들은 ISO-8601에 정의된 달력 시스템에 기초한다. |
| java.time.chrono   | ISO-8601에 정의된 달력 이외에 다른 달력 시스템이 필요할 때 사용할 수 있는 API들이 포함되어 있다. |
| java.time.format   | 날짜와 시간을 파싱하고 포맷팅하는 API들이 포함되어 있다.     |
| java.time.temporal | 날짜와 시간을 연산하기 위한 보조 API들이 포함되어 있다.      |
| java.time.zone     | 타임존을 지원하는 API들이 포함되어있다.                      |



### 날짜와 시간 객체 생성

java.time 패키지에는 날짜와 시간을 표현하는 5개의 클래스가 있다.

| 클래스명      | 설명                                            |
| ------------- | ----------------------------------------------- |
| LocalDate     | 로컬 날짜 클래스                                |
| LocalTime     | 로컬 시간 클래스                                |
| LocalDateTime | 로컬 날자 및 시간 클래스(LocalDate + LocalTime) |
| ZonedDateTime | 특정 타임존(TimeZone)의 날짜와 시간 클래스      |
| Instant       | 특정 시점의 Time-Stamp 클래스                   |



#### LocalDate

로컬 날짜 클래스

- 날짜 정보만 저장할 수 있다.

- 객체를 두 가지 정적 메소드로 얻을 수 있는데,

  - now()는 컴퓨터의 현재 날짜 정보를 저장한 LocalDate 객체를 리턴

  - of()는 매개값으로 주어진 날짜 정보를 저장한 LocalDate 객체를 리턴

```java
LocalDate currDate = LocalDate.now();
LocalDate targetDate = LocalDate.of(int year, int month, int dayOfMonth);
```



#### LocalTime

로컬 시간 클래스

- 시간 정보만 저장할 수 있다.
- LocalDate와 동일
  - now()는 컴퓨터의 현재 시간 정보를 저장한 LocalDate 객체를 리턴
  - of()는 매개값으로 주어진 시간 정보를 저장한 LocalTime 객체를 리턴

```java
LocalTime currTime = LocalTime.now();
LocalTime targetTime = LocalTime.of(int hour,int minute,int second,int nanoOfSecond);
```



#### LocalDateTime

LocalDate와 LocalTime을 결합한 클래스

- 날짜와 시간을 모두 저장할 수 있다.
- 위와 마찬가지로
  - now()는 컴퓨터의 현재 날짜와 시간 정보를 저장한 LocalDateTime 객체를 리턴
  - of()는 매개값으로 주어진 날짜와 시간 정보를 저장한 LocalDateTime 객체를 리턴

``` java
LocalDateTime currDateTime = LocalDateTime.now();
LocalDateTime targetTime = LocalDateTime.of(int year, int month, int dayOfMonth, int hour, int minute
                                           int second, int nonoOfSecond);
```



#### ZonedDateTime

ISO-8601 달력 시스템에서 정의하고 있는 타임존의 날짜와 시간을 저장하는 클래스.

- 저장 형태는 2014-04-21T07:50:24.017+09:00[Asia/Seoul]와 같이 맨 뒤에 타임존에 대한 정보(+- 존 오프셋[존아이디]) 가 추가적으로 붙는다.

  - 존 오프셋은 협정세계시와 차이나는 시간을 말함

  - ZonedDateTime은 now() 정적 메소드에 ZoneId를 매개값으로 주고 얻을 수 있다.
  - ZoneId는 of() 메소드로 얻을 수 있고, of()의 매개값은 java.util.TimeZone의 getAvailablesIDs() 메소드가 리턴하는 유효한 값 중에 하나이다.

``` java
ZonedDateTime utcDateTime = ZonedDateTime.now(ZoneId.of("UTC"));
ZonedDateTime londonDateTime = ZonedDateTime.now(ZoneId.of("EUROPE/LONDON"));
ZonedDateTime seoulDateTime = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
```



#### Instant

특정 시점의 타임스탬프로 사용

- 보통 특정한 두 시점 간의 시간적 우선순위를 따질 때 사용
- Date와의 차이점은 Date는 로컬 컴퓨터의 현재 날짜와 시간 정보를 기준으로 하나, Instant는 협정 세계시를 기준으로 한다.

```java
Instant instant1 = Instant.now();
Instant instant2 = Instant.now();
if(instant1.isBefor(instant2)){System.out.println("instant1이 빠릅니다.");} // isBefore, isAfter은 시간의 앞뒤 여부를 확인하는 메소드
else if(instant1.isAfter(instant2)){System.out.println("instant1이 늦습니다.");}
else{System.out.println("동일한 시간입니다.");}
System.out.println("차이(nanos): " + instant1.until(instant2, ChronoUnit.NANOS)); // until()은 시점의 차이를 리턴
```



``` java
import java.time.*;
import java.time.temporal.ChronoUnit;

public class DateTimeCreateExample {
    public static void main(String args[]) throws InterruptedException {
        // 날짜 얻기
        LocalDate currDate = LocalDate.now();
        System.out.println("현재 날짜: "+currDate);

        LocalDate targetDate = LocalDate.of(2024,5,10);
        System.out.println("목표 날짜: " + targetDate + "\n");

        // 시간 얻기
        LocalTime currTime = LocalTime.now();
        System.out.println("현재 시간: " + currTime);

        LocalTime targetTime = LocalTime.of(6,30,0,0);
        System.out.println("목표 시간: "+ targetTime + "\n");

        // 날짜와 시간 얻기
        LocalDateTime currentDateTime = LocalDateTime.now();
        System.out.println("현재 날짜와 시간: " + currentDateTime);

        LocalDateTime targetDateTime = LocalDateTime.of(2024,5,10,6,30,0,0);
        System.out.println("목표 날짜와 시간: " + targetDateTime + "\n");

        // 협정 세계시와 시간존 (Timezone)
        ZonedDateTime utcDateTime = ZonedDateTime.now(ZoneId.of("UTC"));
        System.out.println("협정 세계시: " + utcDateTime);
        ZonedDateTime newyorkDateTime =
                ZonedDateTime.now(ZoneId.of("America/New_York"));
        System.out.println("뉴욕 시간존: "+newyorkDateTime + "\n");

        // 특정 시점의 타임스탬프 얻기
        Instant instant1 = Instant.now();
        Thread.sleep(10);
        Instant instant2 = Instant.now();
        if(instant1.isBefore(instant2)){
            System.out.println("instant1이 빠릅니다.");
        }
        else if(instant1.isAfter(instant2)){
            System.out.println("instant2가 빠릅니다.");
        }
        else{
            System.out.println("동일한 시간입니다.");
        }
        System.out.println("차이(nanos): " + instant1.until(instant2, ChronoUnit.NANOS));
    }
}
//
현재 날짜: 2021-02-17
목표 날짜: 2024-05-10

현재 시간: 05:27:29.367
목표 시간: 06:30

현재 날짜와 시간: 2021-02-17T05:27:29.367
목표 날짜와 시간: 2024-05-10T06:30

협정 세계시: 2021-02-16T20:27:29.368Z[UTC]
뉴욕 시간존: 2021-02-16T15:27:29.369-05:00[America/New_York]

instant1이 빠릅니다.
차이(nanos): 17000000
```



### 날짜와 시간에 대한 정보 얻기

LocalDate와 LocalTime의 프로그램에서 날짜와 시간 정보를 얻기위해 사용되는 메소드 표

| 클래스    | 리턴 타입 | 메소드(매개 변수) | 설명              |
| --------- | --------- | ----------------- | ----------------- |
| LocalDate | int       | getYear()         | 년                |
|           | Month     | getMonth()        | Month 열거값      |
|           | int       | getMonthValue()   | 월                |
|           | int       | getDayOfYear      | 일년의 몇 번째 일 |
|           | int       | getDayOfMonth()   | 월의 몇 번째 일   |
|           | DayOfWeek | getDayOfWeek()    | 요일              |
|           | boolean   | isLeapYear()      | 윤년 여부         |
| LocalTime | int       | getHour()         | 시간              |
|           | int       | getMinute()       | 분                |
|           | int       | getSecond()       | 초                |
|           | int       | getNano()         | 나노초 리턴       |

-> LocalDateTime과 ZonedDateTime은 날짜와 시간 정보를 모두 갖고 있다

--- > 단 isLeapYear()은 LocalDateTime에만 있기 떄문에 toLocalDate() 메소드로 LocalDate로 변환 후 사용할 수 있다. 



ZonedDateTime의 시간 존에 대한 정보를 제공하는 메소드 표

| 클래스        | 리턴 타입  | 메소드(매개 변수) | 설명                            |
| ------------- | ---------- | ----------------- | ------------------------------- |
| ZonedDateTime | Zoneld     | getZone()         | 존아이디를 리턴(예: Asia/Seoul) |
|               | ZoneOffset | getOffset()       | 존 오프셋(시차)을 리턴          |

```java
import java.time.*;

public class DateTimeInfoExample {
    public static void main(String[] args){
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);

        String strDateTime = now.getYear() + "년 ";
        strDateTime += now.getMonthValue() + "월 ";
        strDateTime += now.getDayOfMonth() + "일 ";
        strDateTime += now.getDayOfWeek() + " ";
        strDateTime += now.getHour() + "시 ";
        strDateTime += now.getMinute() + "분 ";
        strDateTime += now.getSecond() + "초 ";
        strDateTime += now.getNano() + "나노초";
        System.out.println(strDateTime + "\n");

        LocalDate nowDate = now.toLocalDate();
        if(nowDate.isLeapYear()){
            System.out.println("올해는 윤년: 2월은 29일까지 있습니다.\n");
        }
        else {
            System.out.println("올해는 평년: 2월은 28일까지 있습니다.\n");
        }

        // 협정 세계시와 존오프셋
        ZonedDateTime utcDateTime = ZonedDateTime.now(ZoneId.of("UTC"));
        System.out.println("협정 세계시: " + utcDateTime);
        ZonedDateTime seoulDateTime = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));
        System.out.println("서울 타임존: " + seoulDateTime);
        ZoneId seoulZoneId = seoulDateTime.getZone();
        System.out.println("서울 존아이디: " + seoulZoneId);
        ZoneOffset seoulZoneOffset = seoulDateTime.getOffset();
        System.out.println("서울 존오프셋: " + seoulZoneOffset + "\n");
    }
}
//
2021-02-17T05:31:16.992
2021년 2월 17일 WEDNESDAY 5시 31분 16초 992000000나노초

올해는 평년: 2월은 28일까지 있습니다.

협정 세계시: 2021-02-16T20:31:16.993Z[UTC]
서울 타임존: 2021-02-17T05:31:16.994+09:00[Asia/Seoul]
서울 존아이디: Asia/Seoul
서울 존오프셋: +09:00
```



### 날짜와 시간을 조작하기

#### 빼기와 더하기

날짜와 시간을 뺴거나 더하는 메소드 표

| 클래스                                      | 리턴 타입                                     | 메소드(매개 변수)  | 설명          |
| ------------------------------------------- | --------------------------------------------- | ------------------ | ------------- |
| LocalDate<br>LocalDateTime<br>LocalDateTime | LocalDate<br>LocalDateTime<br>LocalDateTime   | minusYears(long)   | 년 빼기       |
|                                             |                                               | minusMonth(long)   | 달 빼기       |
|                                             |                                               | minusDays(long)    | 일 빼기       |
|                                             |                                               | minusWeeks(long)   | 주 배기       |
|                                             |                                               | plusYears(long)    | 년 더하기     |
|                                             |                                               | plusMonths(long)   | 달 더하기     |
|                                             |                                               | plusWeeks(long)    | 주 더하기     |
|                                             |                                               | plusDays(long)     | 일 더하기     |
| LocalTime<br>LocalDateTime<br>ZonedDateTime | LocalTime<br/>LocalDateTime<br/>ZonedDateTime | minusHours(long)   | 시간 빼기     |
|                                             |                                               | minusMinutes(long) | 분 빼기       |
|                                             |                                               | minusSeconds(long) | 초 빼기       |
|                                             |                                               | minusNanos(long)   | 나노초 빼기   |
|                                             |                                               | plusHours(long)    | 시간 더하기   |
|                                             |                                               | plusMinutes(long)  | 분 더하기     |
|                                             |                                               | plusSeconds(long)  | 초 더하기     |
|                                             |                                               | plusNanos(long)    | 나노초 더하기 |

-> 각 메소드들은 수정된 LocalDate, LocalTime, LocalDateTime을 리턴하기 떄문에 . 연산자로 연결해서 순차적으로 호출 가능하다.



```java
import java.time.LocalDateTime;

public class DataTimeOperationExample {
    public static void main(String args[]){
        LocalDateTime now = LocalDateTime.now();
        
        System.out.println("현재시: " + now);
        
        LocalDateTime targetDateTime = now
                .plusYears(1)
                .minusMonths(2)
                .plusDays(3)
                .plusHours(4)
                .minusMinutes(5)
                .plusSeconds(6);
        System.out.println("연산후: " + targetDateTime);
    }
}
//
현재시: 2021-02-17T05:33:12.636
연산후: 2021-12-20T09:28:18.636
```



#### 변경하기

날짜와 시간을 변경하는 메소드 표

| 클래스                                      | 리턴 타입                                     | 메소드(매개 변수)               | 설명         |
| ------------------------------------------- | --------------------------------------------- | ------------------------------- | ------------ |
| LocalDate<br>LocalDateTime<br>ZonedDateTime | LocalDate<br/>LocalDateTime<br/>ZonedDateTime | withYear(int)                   | 년 변경      |
|                                             |                                               | withMonth(int)                  | 월 변경      |
|                                             |                                               | withDayOfMonth(int)             | 월의 일 변경 |
|                                             |                                               | withDayOfYear(int)              | 년의 일 변경 |
|                                             |                                               | with(TemporalAdjuster adjuster) | 상대 변경    |
| LocalTime<br>LocalDateTime<br>ZonedDateTime | LocalTime<br/>LocalDateTime<br/>ZonedDateTime | withHours(int)                  | 시간 변경    |
|                                             |                                               | withMinute(int)                 | 분 변경      |
|                                             |                                               | withSecond(int)                 | 초 변경      |
|                                             |                                               | withNano(int)                   | 나노초 변경  |

-> with() 메소드는 현재 날짜를 기준으로 해의 첫 번째 일 또는 마지막 일, 달의 첫 번째 일 또는 마지막 일등 상대적인 날짜를 리턴한다.

---> 매개값은 TemporalAdjuster 타입으로 다음 표에 있는 TemporalAdjusters의 정적 메소드를 호출하면 얻을 수 있다.

| 리턴 타입        | 메소드(매개 변수)                   | 설명                     |
| ---------------- | ----------------------------------- | ------------------------ |
| TemporalAdjuster | firstDayOfYear()                    | 이번 해의 첫 번째 일     |
|                  | lastDayOfYear()                     | 이번 해의 마지막 일      |
|                  | firstDayOfNextYear()                | 다음 해의 첫 번째 일     |
|                  | firstDayOfMonth()                   | 이번 달의 첫 번째 일     |
|                  | lastDayOfMonth()                    | 이번 달의 마지막 일      |
|                  | firstDayOfNextMonth()               | 다음 달의 첫 번째 일     |
|                  | firstInMonth(DayOfWeek dayOfWeek)   | 이번 달의 첫 번째 요일   |
|                  | lastInMonth(DayOfWeek dayOfWeek)    | 이번 달의 마지막 요일    |
|                  | next(DayOfWeek dayOfWeek)           | 돌아오는 요일            |
|                  | nextOrSame(DayOfWeek dayOfWeek)     | 돌아오는 요알(오늘 포함) |
|                  | previous(DayOfWeek dayOfWeek)       | 지난 요일                |
|                  | previousOrSame(DayOfWeek dayOfWeek) | 지난 요일(오늘 포함)     |



``` java
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.temporal.TemporalAdjusters;

public class DateTimeChangeExample {
    public static void main(String[] args){
        LocalDateTime now = LocalDateTime.now();
        System.out.println("현재: "+now);
        
        LocalDateTime targetDateTime = null;
        
        // 직접 변경
        targetDateTime = now
                .withYear(2024)
                .withMonth(10)
                .withDayOfMonth(5)
                .withHour(13)
                .withMinute(30)
                .withSecond(20);
        System.out.println("직접 변경: "+ targetDateTime);
        
        // 년도 상대 변경
        targetDateTime = now.with(TemporalAdjusters.firstDayOfYear());
        System.out.println("이번 해의 첫 일: " + targetDateTime);
        targetDateTime = now.with(TemporalAdjusters.lastDayOfYear());
        System.out.println("이번 해의 마지막 일: "+targetDateTime);
        targetDateTime = now.with(TemporalAdjusters.firstDayOfNextYear());
        System.out.println("다음 해의 첫 일: " + targetDateTime);
        
        // 월 상대 변경
        targetDateTime = now.with(TemporalAdjusters.firstDayOfNextMonth());
        System.out.println("이번 달의 첫 일: " +targetDateTime);
        targetDateTime = now.with(TemporalAdjusters.lastDayOfMonth());
        System.out.println("이번 달의 마지막 일: " +targetDateTime);
        targetDateTime = now.with(TemporalAdjusters.firstDayOfNextMonth());
        System.out.println("다음 달의 첫 일: " +targetDateTime);
        
        // 요일 상대 변경
        targetDateTime = now.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
        System.out.println("이번 달의 첫 월요일: " + targetDateTime );
        targetDateTime =now.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
        System.out.println("돌아오는 월요일: "+targetDateTime);
        targetDateTime = now.with(TemporalAdjusters.previous(DayOfWeek.MONDAY));
        System.out.println("지난 월요일: " +targetDateTime);
    }
}
//
현재: 2021-02-17T05:36:28.159
직접 변경: 2024-10-05T13:30:20.159
이번 해의 첫 일: 2021-01-01T05:36:28.159
이번 해의 마지막 일: 2021-12-31T05:36:28.159
다음 해의 첫 일: 2022-01-01T05:36:28.159
이번 달의 첫 일: 2021-03-01T05:36:28.159
이번 달의 마지막 일: 2021-02-28T05:36:28.159
다음 달의 첫 일: 2021-03-01T05:36:28.159
이번 달의 첫 월요일: 2021-02-01T05:36:28.159
돌아오는 월요일: 2021-02-22T05:36:28.159
지난 월요일: 2021-02-15T05:36:28.159
```



### 날짜와 시간을 비교하기

날짜와 시간 클래스들의 비교하거나 차이를 구하는 메소드 표

| 클래스                                    | 리턴 타입 | 메소드(매개 변수)                                            | 설명               |
| ----------------------------------------- | --------- | ------------------------------------------------------------ | ------------------ |
| LocalDate<br>LocalDateTime                | boolean   | isAfter(ChronoLoclaDate other)                               | 이후 날짜인지 비교 |
|                                           |           | isBefore(ChronoLocalDate other)                              | 이전 날짜인지 비교 |
|                                           |           | isEqual(ChronoLocalDate other)                               | 동일 날짜인지 비교 |
| LocalTime<br/>LocalDateTIme               | boolean   | isAfter(LocalTime other)                                     | 이후 시간인지 비교 |
|                                           |           | isBefore(LocalTime other)                                    | 이전 시간인지 비교 |
| LocalDate                                 | Period    | until(ChronoLocalDate endDateExclusive)                      | 날짜 차이          |
| LocalDate<br/>LocalTime<br/>LocalDateTime | long      | until(<br>Temporal endExclusive,<br>TemporalUnit unit<br>)   | 시간 차이          |
| Period                                    | Period    | between(<br>Temporal startInclusive,<br>Temporal endDateExclusive<br>) | 날짜 차이          |
| Duration                                  | Duration  | between(<br>Temporal startInclusive,<br>Temporal endExclusive<br>) | 시간 차이          |
| ChronoUnit.YEARS                          | long      | between(<br>Temporal temporal1Inclusive,<br>Temporal temporal2Exclusive<br>) | 전체 년 차이       |
| ChronoUnit.MONTHS                         | -         |                                                              | 전체 달 차이       |
| ChronoUnit.WEEKS                          | -         |                                                              | 전체 주 차이       |
| ChronoUnit.DAY                            | -         |                                                              | 전체 일 차이       |
| ChronoUnit.HOURS                          | -         |                                                              | 전체 시간 차이     |
| ChronoUnit.SECONDS                        | -         |                                                              | 전체 초 차이       |
| ChronoUnit.MILLIS                         | -         |                                                              | 전체 밀리초 차이   |
| ChronoUnit.NANOS                          | -         |                                                              | 전체 나노초 차이   |

- Period는 년, 달, 일의 양을 나타내는 클래스
- Duration은 시, 분 ,초, 나노초의 양을 나타내는 클래스

-> D-day나 D-time을 구할 때 사용가능

| 클래스   | 리턴 타입 | 메소드(매개 변수) | 설명          |
| -------- | --------- | ----------------- | ------------- |
| Period   | int       | getYears()        | 년의 차이     |
| -        | int       | getMonths()       | 달의 차이     |
| -        | int       | getDays()         | 일의 차이     |
| Duration | int       | getSeconds()      | 초의 차이     |
| -        | int       | getNano()         | 나노초의 차이 |

- Period와 Duration의 between() 은 년, 달, 일, 초의 단순 차이를 리턴

- ChronoUnit 열거 타입의 between()은 전체 시간을 기준으로 차이를 리턴

ex) 2002년 2월과 2003년 4월의 달 차이는 Period의 between()은 2 ChronoUnit의 between의 between()은 14

```java
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.Period;
import java.time.temporal.ChronoUnit;

public class DateTimeCompareExample {
    public static void main(String[] args){
        LocalDateTime startDateTime = LocalDateTime.of(2023,1,1,9,0,0);
        System.out.println("시작일: " + startDateTime);

        LocalDateTime endDateTime = LocalDateTime.of(2024,3,31,18,0,0);
        System.out.println("종료일: " + endDateTime + "\n");
        //----------------------------------------------------
        if(startDateTime.isBefore(endDateTime)){
            System.out.println("진행 중입니다." + "\n");
        }
        else if(startDateTime.isEqual(endDateTime)){
            System.out.println("종료합니다." + "\n");
        }
        else if(startDateTime.isAfter(endDateTime)){
            System.out.println("종료했습니다." + "\n");
        }
        //----------------------------------------------------
        System.out.println("[종료까지 남은 시간]");
        long remainYear = startDateTime.until(endDateTime, ChronoUnit.YEARS);
        long remainMonth = startDateTime.until(endDateTime, ChronoUnit.MONTHS);
        long remainDay = startDateTime.until(endDateTime, ChronoUnit.DAYS);
        long remainHour = startDateTime.until(endDateTime, ChronoUnit.HOURS);
        long remainMinute = startDateTime.until(endDateTime, ChronoUnit.MINUTES);
        long remainSecond = startDateTime.until(endDateTime,ChronoUnit.SECONDS);

        remainYear = ChronoUnit.YEARS.between(startDateTime,endDateTime);
        remainMonth = ChronoUnit.MONTHS.between(startDateTime,endDateTime);
        remainDay = ChronoUnit.DAYS.between(startDateTime,endDateTime);
        remainHour = ChronoUnit.HOURS.between(startDateTime,endDateTime);
        remainSecond =ChronoUnit.SECONDS.between(startDateTime,endDateTime);

        System.out.println("남은 해: " + remainYear);
        System.out.println("남은 달: " + remainMonth);
        System.out.println("남은 일: " + remainDay);
        System.out.println("남은 시간: " + remainHour);
        System.out.println("남은 분: " + remainMinute);
        System.out.println("남은 초: " + remainSecond + "\n");
        //-------------------------------------------------------
        System.out.println("[종료까지 남은 기간]");
        Period period =
                Period.between(startDateTime.toLocalDate(),endDateTime.toLocalDate());
        System.out.print("남은 기간: " + period.getYears() + "년");
        System.out.print(period.getMonths() + "달 ");
        System.out.println(period.getDays() + "일\n");
        //-------------------------------------------------------
        Duration duration =
                Duration.between(startDateTime.toLocalTime(),endDateTime.toLocalTime());
        System.out.println("남은 초: " + duration.getSeconds());
    }
}
//
시작일: 2023-01-01T09:00
종료일: 2024-03-31T18:00

진행 중입니다.

[종료까지 남은 시간]
남은 해: 1
남은 달: 14
남은 일: 455
남은 시간: 10929
남은 분: 655740
남은 초: 39344400

[종료까지 남은 기간]
남은 기간: 1년2달 30일

남은 초: 32400
```



### 파싱과 포맷팅 

문자열을 `파싱`해서 날짜와 시간을 생성하는 메소드와

날짜와 시간을 `포맷팅`된 문자열로 변환하는 메소드

#### 파싱 메소드

날짜와 시간 정보가 포함된 문자열을 파싱해서 날짜와 시간을 생성하는 parse() 정적 메소드이다.

| 클래스                                                   | 리턴 타입                                                   | 메소드(매개 변수)                      |
| -------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------- |
| LocalDate<br>LocalTime<br>LocalDateTime<br>ZonedDateTime | LocalDate<br/>LocalTime<br/>LocalDateTime<br/>ZonedDateTime | parse(CharSequence)                    |
| -                                                        | -                                                           | parse(CharSequence, DateTimeFormatter) |

LocalDate의 pares(CharSequence) 메소드는 기본적으로 ISO_LOCAL_DATE 포멧터를 사용해서 문자열을 파싱한다.

``` java
LocalDate localDate = LocalDate.parse("2024-05-21");
```



만약 다른 포맷터를 이요해서 문자열을 파싱하고 싶다면 parse(CharSequence, DateTimeFormatter) 메소드를 사용할 수 있다.

DateTimeFormatter은 ofParese() 메소드로 정의할 수 있다.

```java
DateTimeFormatter formatter = DateTimeFormatter.ofPatter("yyyy.MM.dd");
LocalDate localDate = LocalDate.parse("2024.05.21",formatter);
```



DateTimeFormatter에서 표준화된 포맷터들이 아래 표처럼 상수로 미리 정의되어있어 ofPattern() 메소드를 사용하지 않고 바로 이용할 수 있다.

| 상수                 | 설명                            | 예                                        |
| -------------------- | ------------------------------- | ----------------------------------------- |
| BASIC_ISO_DATE       | Bais ISO date                   | "20111203"                                |
| ISO_LOCAL_DATE       | ISO Local Date                  | "2011-12-03"                              |
| ISO_OFFSET_DATE      | ISO Date with offset            | "2011-12-03+01:00"                        |
| ISO_DATE             | ISO Date with or without offset | "2011-12-03+01:00";"2011-12-03"           |
| ISO_LOCAL_TIME       | Time without offset             | "10:15:30"                                |
| ISO_OFFSET_TIME      | Time with offset                | "10:15:30+01:00"                          |
| ISO_TIME             | Time with or without offset     | "10:15:30+01:00";"10:15:30"               |
| ISO_LOCAL_DATE_TIME  | ISO Local Date and Time         | "2011-12-03T10:15:30"                     |
| ISO_OFFSET_DATE_TIME | Date Time with Offset           | "2011-12-03T10:15:30+01:00"               |
| ISO_ZONED_DATE_TIME  | Zoned Date Time                 | "2011-12-03T10:15:30+01:00[Europe/Paris]" |
| ISO_DATE_TIME        | Date and time with Zoneld       | "2001-12-03T10:15:30+01:00[Europe/Paris]" |
| ISO_ORIGINAL_DATE    | Year and day of year            | "2012-337"                                |
| ISO_WEEK_DATE        | Year and Week                   | "2012-W48-6"                              |
| ISO_INSTANT          | Date and Time of an Instant     | "2011-12-03T10:15:30Z"                    |
| RFC_1123_DATE_TIME   | RFC 1123 / RFC 822              | "Tue, 3 Jun 2008 11:05:30 GMT"            |



parse(CharSequence) 와 동일하게 "2024-05-21" 이라는 문자열을 파싱해서 LocalDate객체를 얻고 싶으면 아래처럼 작성할 수 있다.

``` java
LocalDate localDate = LocalDate.parse("2024-05-21",DateTimeFormatterISO_LOCAL_DATE);
```



포맷터의 형식과 다른 문자열을 파싱하게 되면 DateTimeParseException이 발생한다.

``` java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class DateTimeParsingExample {
    public static void main(String[] args){
        DateTimeFormatter formatter;
        LocalDate localDate;

        localDate = LocalDate.parse("2024-05-21");
        System.out.println(localDate);

        formatter = DateTimeFormatter.ISO_LOCAL_DATE;
        localDate = LocalDate.parse("2024-05-21",formatter);
        System.out.println(localDate);

        formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd");
        localDate = LocalDate.parse("2024/05/21",formatter);
        System.out.println(localDate);

        formatter = DateTimeFormatter.ofPattern("yyyy.MM.dd");
        localDate = LocalDate.parse("2024.05.21",formatter);
        System.out.println(localDate);
    }
}
//
2024-05-21
2024-05-21
2024-05-21
2024-05-21
```



#### 포맷팅 메소드

| 클래스                                                   | 리턴 타입 | 메소드(매개 변수)                   |
| -------------------------------------------------------- | --------- | ----------------------------------- |
| LocalDate<br>LocalTime<br>LocalDateTime<br>ZonedDateTime | String    | format(DateTimeFormatter formatter) |

format()의 매개값은 DateTimeFormatter인데 해당 형식대로 문자열을 리턴한다.

``` java
LocalDateTime now = LocalDateTime.now();
DateTimeFormatter dateTimeFormatter=
    DateTimeFormatter.ofPattern("yyyy년 M월 d일 a h시 m분");
String nowString = now.format(dateTimeFormatter);
```

``` java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class DateTimeFormatExample {
    public static void main(String[] args){
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter dateTimeFormatter=
                DateTimeFormatter.ofPattern("yyyy년 M월 d일 a h시 m분");
        String nowString = now.format(dateTimeFormatter);
        System.out.println(nowString);
    }
}
//
2021년 2월 17일 오전 5시 57분
```
